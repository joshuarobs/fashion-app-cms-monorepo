# The base colour names that all other colours may be derived from. This includes
# the list of all major classifications of colours.
#
#
# columns and relationships of "base_colours"
#
type base_colours {
  description: String!
  value: String!
}

# aggregated selection of "base_colours"
type base_colours_aggregate {
  aggregate: base_colours_aggregate_fields
  nodes: [base_colours!]!
}

# aggregate fields of "base_colours"
type base_colours_aggregate_fields {
  count(columns: [base_colours_select_column!], distinct: Boolean): Int
  max: base_colours_max_fields
  min: base_colours_min_fields
}

# order by aggregate values of table "base_colours"
input base_colours_aggregate_order_by {
  count: order_by
  max: base_colours_max_order_by
  min: base_colours_min_order_by
}

# input type for inserting array relation for remote table "base_colours"
input base_colours_arr_rel_insert_input {
  data: [base_colours_insert_input!]!
  on_conflict: base_colours_on_conflict
}

# Boolean expression to filter rows from the table "base_colours". All fields are combined with a logical 'AND'.
input base_colours_bool_exp {
  _and: [base_colours_bool_exp]
  _not: base_colours_bool_exp
  _or: [base_colours_bool_exp]
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "base_colours"
enum base_colours_constraint {
  # unique or primary key constraint
  base_colours_pkey
}

enum base_colours_enum {
  Black
  Blue
  Brown
  Cyan
  Green
  Grey
  Indigo
  Lime
  Orange
  Pink
  Purple
  Red
  White
  Yellow
}

# expression to compare columns of type base_colours_enum. All fields are combined with logical 'AND'.
input base_colours_enum_comparison_exp {
  _eq: base_colours_enum
  _in: [base_colours_enum!]
  _is_null: Boolean
  _neq: base_colours_enum
  _nin: [base_colours_enum!]
}

# input type for inserting data into table "base_colours"
input base_colours_insert_input {
  description: String
  value: String
}

# aggregate max on columns
type base_colours_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "base_colours"
input base_colours_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type base_colours_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "base_colours"
input base_colours_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "base_colours"
type base_colours_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [base_colours!]!
}

# input type for inserting object relation for remote table "base_colours"
input base_colours_obj_rel_insert_input {
  data: base_colours_insert_input!
  on_conflict: base_colours_on_conflict
}

# on conflict condition type for table "base_colours"
input base_colours_on_conflict {
  constraint: base_colours_constraint!
  update_columns: [base_colours_update_column!]!
  where: base_colours_bool_exp
}

# ordering options when selecting data from "base_colours"
input base_colours_order_by {
  description: order_by
  value: order_by
}

# primary key columns input for table: "base_colours"
input base_colours_pk_columns_input {
  value: String!
}

# select columns of table "base_colours"
enum base_colours_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "base_colours"
input base_colours_set_input {
  description: String
  value: String
}

# update columns of table "base_colours"
enum base_colours_update_column {
  # column name
  description

  # column name
  value
}

# The main body groups of the human body.
#
#
# columns and relationships of "body_groups"
#
type body_groups {
  # An array relationship
  body_segments(
    # distinct select on columns
    distinct_on: [body_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segments_order_by!]

    # filter the rows returned
    where: body_segments_bool_exp
  ): [body_segments!]!

  # An aggregated array relationship
  body_segments_aggregate(
    # distinct select on columns
    distinct_on: [body_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segments_order_by!]

    # filter the rows returned
    where: body_segments_bool_exp
  ): body_segments_aggregate!
  description: String
  value: String!
}

# aggregated selection of "body_groups"
type body_groups_aggregate {
  aggregate: body_groups_aggregate_fields
  nodes: [body_groups!]!
}

# aggregate fields of "body_groups"
type body_groups_aggregate_fields {
  count(columns: [body_groups_select_column!], distinct: Boolean): Int
  max: body_groups_max_fields
  min: body_groups_min_fields
}

# order by aggregate values of table "body_groups"
input body_groups_aggregate_order_by {
  count: order_by
  max: body_groups_max_order_by
  min: body_groups_min_order_by
}

# input type for inserting array relation for remote table "body_groups"
input body_groups_arr_rel_insert_input {
  data: [body_groups_insert_input!]!
  on_conflict: body_groups_on_conflict
}

# Boolean expression to filter rows from the table "body_groups". All fields are combined with a logical 'AND'.
input body_groups_bool_exp {
  _and: [body_groups_bool_exp]
  _not: body_groups_bool_exp
  _or: [body_groups_bool_exp]
  body_segments: body_segments_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "body_groups"
enum body_groups_constraint {
  # unique or primary key constraint
  body_groups_pkey
}

enum body_groups_enum {
  Arms_And_Hands
  Head_And_Neck
  Legs_And_Feet
  Torso
}

# expression to compare columns of type body_groups_enum. All fields are combined with logical 'AND'.
input body_groups_enum_comparison_exp {
  _eq: body_groups_enum
  _in: [body_groups_enum!]
  _is_null: Boolean
  _neq: body_groups_enum
  _nin: [body_groups_enum!]
}

# input type for inserting data into table "body_groups"
input body_groups_insert_input {
  body_segments: body_segments_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type body_groups_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "body_groups"
input body_groups_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type body_groups_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "body_groups"
input body_groups_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "body_groups"
type body_groups_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [body_groups!]!
}

# input type for inserting object relation for remote table "body_groups"
input body_groups_obj_rel_insert_input {
  data: body_groups_insert_input!
  on_conflict: body_groups_on_conflict
}

# on conflict condition type for table "body_groups"
input body_groups_on_conflict {
  constraint: body_groups_constraint!
  update_columns: [body_groups_update_column!]!
  where: body_groups_bool_exp
}

# ordering options when selecting data from "body_groups"
input body_groups_order_by {
  body_segments_aggregate: body_segments_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "body_groups"
input body_groups_pk_columns_input {
  value: String!
}

# select columns of table "body_groups"
enum body_groups_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "body_groups"
input body_groups_set_input {
  description: String
  value: String
}

# update columns of table "body_groups"
enum body_groups_update_column {
  # column name
  description

  # column name
  value
}

# The different shapes to describe how a layer of a body segment is physically.
#
#
# columns and relationships of "body_segment_mask_shapes"
#
type body_segment_mask_shapes {
  description: String
  value: String!
}

# aggregated selection of "body_segment_mask_shapes"
type body_segment_mask_shapes_aggregate {
  aggregate: body_segment_mask_shapes_aggregate_fields
  nodes: [body_segment_mask_shapes!]!
}

# aggregate fields of "body_segment_mask_shapes"
type body_segment_mask_shapes_aggregate_fields {
  count(columns: [body_segment_mask_shapes_select_column!], distinct: Boolean): Int
  max: body_segment_mask_shapes_max_fields
  min: body_segment_mask_shapes_min_fields
}

# order by aggregate values of table "body_segment_mask_shapes"
input body_segment_mask_shapes_aggregate_order_by {
  count: order_by
  max: body_segment_mask_shapes_max_order_by
  min: body_segment_mask_shapes_min_order_by
}

# input type for inserting array relation for remote table "body_segment_mask_shapes"
input body_segment_mask_shapes_arr_rel_insert_input {
  data: [body_segment_mask_shapes_insert_input!]!
  on_conflict: body_segment_mask_shapes_on_conflict
}

# Boolean expression to filter rows from the table "body_segment_mask_shapes". All fields are combined with a logical 'AND'.
input body_segment_mask_shapes_bool_exp {
  _and: [body_segment_mask_shapes_bool_exp]
  _not: body_segment_mask_shapes_bool_exp
  _or: [body_segment_mask_shapes_bool_exp]
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "body_segment_mask_shapes"
enum body_segment_mask_shapes_constraint {
  # unique or primary key constraint
  body_segment_mask_shape_pkey
}

enum body_segment_mask_shapes_enum {
  CUTOUT_FROM_BOTH_SIDES
  CUTOUT_FROM_BOTTOM
  CUTOUT_FROM_INNER_SIDE
  CUTOUT_FROM_LEFT_SIDE
  CUTOUT_FROM_OUTER_SIDE
  CUTOUT_FROM_RIGHT_SIDE
  CUTOUT_FROM_TOP
  Full
  OTHER
}

# expression to compare columns of type body_segment_mask_shapes_enum. All fields are combined with logical 'AND'.
input body_segment_mask_shapes_enum_comparison_exp {
  _eq: body_segment_mask_shapes_enum
  _in: [body_segment_mask_shapes_enum!]
  _is_null: Boolean
  _neq: body_segment_mask_shapes_enum
  _nin: [body_segment_mask_shapes_enum!]
}

# input type for inserting data into table "body_segment_mask_shapes"
input body_segment_mask_shapes_insert_input {
  description: String
  value: String
}

# aggregate max on columns
type body_segment_mask_shapes_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "body_segment_mask_shapes"
input body_segment_mask_shapes_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type body_segment_mask_shapes_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "body_segment_mask_shapes"
input body_segment_mask_shapes_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "body_segment_mask_shapes"
type body_segment_mask_shapes_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [body_segment_mask_shapes!]!
}

# input type for inserting object relation for remote table "body_segment_mask_shapes"
input body_segment_mask_shapes_obj_rel_insert_input {
  data: body_segment_mask_shapes_insert_input!
  on_conflict: body_segment_mask_shapes_on_conflict
}

# on conflict condition type for table "body_segment_mask_shapes"
input body_segment_mask_shapes_on_conflict {
  constraint: body_segment_mask_shapes_constraint!
  update_columns: [body_segment_mask_shapes_update_column!]!
  where: body_segment_mask_shapes_bool_exp
}

# ordering options when selecting data from "body_segment_mask_shapes"
input body_segment_mask_shapes_order_by {
  description: order_by
  value: order_by
}

# primary key columns input for table: "body_segment_mask_shapes"
input body_segment_mask_shapes_pk_columns_input {
  value: String!
}

# select columns of table "body_segment_mask_shapes"
enum body_segment_mask_shapes_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "body_segment_mask_shapes"
input body_segment_mask_shapes_set_input {
  description: String
  value: String
}

# update columns of table "body_segment_mask_shapes"
enum body_segment_mask_shapes_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "body_segment_masks"
type body_segment_masks {
  # An object relationship
  body_segment: body_segments!
  body_segment_id: Int!
  body_segment_mask_shape: body_segment_mask_shapes_enum!

  # An array relationship
  clothing_shell_and_body_segment_masks(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): [clothing_shell_and_body_segment_mask!]!

  # An aggregated array relationship
  clothing_shell_and_body_segment_masks_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): clothing_shell_and_body_segment_mask_aggregate!

  # An object relationship
  fill_layer: fabric_layers
  fill_layer_id: Int
  fill_percent: numeric!
  id: Int!

  # An object relationship
  interlining_layer: fabric_layers
  interlining_layer_id: Int

  # An object relationship
  lining_layer: fabric_layers
  lining_layer_id: Int

  # An object relationship
  shell_layer: fabric_layers
  shell_layer_id: Int

  # If it is the case, the (same) thickness (in mm) of a part of the item's shape
  # (e.g. a cotton T-shirt sleeve that's 2mm thick; lining and filling can either
  # be all the same thickness or unknown/irrelevant)
  uniform_segment_thickness: numeric
}

# aggregated selection of "body_segment_masks"
type body_segment_masks_aggregate {
  aggregate: body_segment_masks_aggregate_fields
  nodes: [body_segment_masks!]!
}

# aggregate fields of "body_segment_masks"
type body_segment_masks_aggregate_fields {
  avg: body_segment_masks_avg_fields
  count(columns: [body_segment_masks_select_column!], distinct: Boolean): Int
  max: body_segment_masks_max_fields
  min: body_segment_masks_min_fields
  stddev: body_segment_masks_stddev_fields
  stddev_pop: body_segment_masks_stddev_pop_fields
  stddev_samp: body_segment_masks_stddev_samp_fields
  sum: body_segment_masks_sum_fields
  var_pop: body_segment_masks_var_pop_fields
  var_samp: body_segment_masks_var_samp_fields
  variance: body_segment_masks_variance_fields
}

# order by aggregate values of table "body_segment_masks"
input body_segment_masks_aggregate_order_by {
  avg: body_segment_masks_avg_order_by
  count: order_by
  max: body_segment_masks_max_order_by
  min: body_segment_masks_min_order_by
  stddev: body_segment_masks_stddev_order_by
  stddev_pop: body_segment_masks_stddev_pop_order_by
  stddev_samp: body_segment_masks_stddev_samp_order_by
  sum: body_segment_masks_sum_order_by
  var_pop: body_segment_masks_var_pop_order_by
  var_samp: body_segment_masks_var_samp_order_by
  variance: body_segment_masks_variance_order_by
}

# input type for inserting array relation for remote table "body_segment_masks"
input body_segment_masks_arr_rel_insert_input {
  data: [body_segment_masks_insert_input!]!
  on_conflict: body_segment_masks_on_conflict
}

# aggregate avg on columns
type body_segment_masks_avg_fields {
  body_segment_id: Float
  fill_layer_id: Float
  fill_percent: Float
  id: Float
  interlining_layer_id: Float
  lining_layer_id: Float
  shell_layer_id: Float
  uniform_segment_thickness: Float
}

# order by avg() on columns of table "body_segment_masks"
input body_segment_masks_avg_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# Boolean expression to filter rows from the table "body_segment_masks". All fields are combined with a logical 'AND'.
input body_segment_masks_bool_exp {
  _and: [body_segment_masks_bool_exp]
  _not: body_segment_masks_bool_exp
  _or: [body_segment_masks_bool_exp]
  body_segment: body_segments_bool_exp
  body_segment_id: Int_comparison_exp
  body_segment_mask_shape: body_segment_mask_shapes_enum_comparison_exp
  clothing_shell_and_body_segment_masks: clothing_shell_and_body_segment_mask_bool_exp
  fill_layer: fabric_layers_bool_exp
  fill_layer_id: Int_comparison_exp
  fill_percent: numeric_comparison_exp
  id: Int_comparison_exp
  interlining_layer: fabric_layers_bool_exp
  interlining_layer_id: Int_comparison_exp
  lining_layer: fabric_layers_bool_exp
  lining_layer_id: Int_comparison_exp
  shell_layer: fabric_layers_bool_exp
  shell_layer_id: Int_comparison_exp
  uniform_segment_thickness: numeric_comparison_exp
}

# unique or primary key constraints on table "body_segment_masks"
enum body_segment_masks_constraint {
  # unique or primary key constraint
  body_segment_masks_pkey

  # unique or primary key constraint
  body_segment_masks_shell_layer_id_fill_layer_id_lining_layer_id
}

# input type for incrementing integer column in table "body_segment_masks"
input body_segment_masks_inc_input {
  body_segment_id: Int
  fill_layer_id: Int
  fill_percent: numeric
  id: Int
  interlining_layer_id: Int
  lining_layer_id: Int
  shell_layer_id: Int
  uniform_segment_thickness: numeric
}

# input type for inserting data into table "body_segment_masks"
input body_segment_masks_insert_input {
  body_segment: body_segments_obj_rel_insert_input
  body_segment_id: Int
  body_segment_mask_shape: body_segment_mask_shapes_enum
  clothing_shell_and_body_segment_masks: clothing_shell_and_body_segment_mask_arr_rel_insert_input
  fill_layer: fabric_layers_obj_rel_insert_input
  fill_layer_id: Int
  fill_percent: numeric
  id: Int
  interlining_layer: fabric_layers_obj_rel_insert_input
  interlining_layer_id: Int
  lining_layer: fabric_layers_obj_rel_insert_input
  lining_layer_id: Int
  shell_layer: fabric_layers_obj_rel_insert_input
  shell_layer_id: Int
  uniform_segment_thickness: numeric
}

# aggregate max on columns
type body_segment_masks_max_fields {
  body_segment_id: Int
  fill_layer_id: Int
  fill_percent: numeric
  id: Int
  interlining_layer_id: Int
  lining_layer_id: Int
  shell_layer_id: Int
  uniform_segment_thickness: numeric
}

# order by max() on columns of table "body_segment_masks"
input body_segment_masks_max_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# aggregate min on columns
type body_segment_masks_min_fields {
  body_segment_id: Int
  fill_layer_id: Int
  fill_percent: numeric
  id: Int
  interlining_layer_id: Int
  lining_layer_id: Int
  shell_layer_id: Int
  uniform_segment_thickness: numeric
}

# order by min() on columns of table "body_segment_masks"
input body_segment_masks_min_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# response of any mutation on the table "body_segment_masks"
type body_segment_masks_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [body_segment_masks!]!
}

# input type for inserting object relation for remote table "body_segment_masks"
input body_segment_masks_obj_rel_insert_input {
  data: body_segment_masks_insert_input!
  on_conflict: body_segment_masks_on_conflict
}

# on conflict condition type for table "body_segment_masks"
input body_segment_masks_on_conflict {
  constraint: body_segment_masks_constraint!
  update_columns: [body_segment_masks_update_column!]!
  where: body_segment_masks_bool_exp
}

# ordering options when selecting data from "body_segment_masks"
input body_segment_masks_order_by {
  body_segment: body_segments_order_by
  body_segment_id: order_by
  body_segment_mask_shape: order_by
  clothing_shell_and_body_segment_masks_aggregate: clothing_shell_and_body_segment_mask_aggregate_order_by
  fill_layer: fabric_layers_order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer: fabric_layers_order_by
  interlining_layer_id: order_by
  lining_layer: fabric_layers_order_by
  lining_layer_id: order_by
  shell_layer: fabric_layers_order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# primary key columns input for table: "body_segment_masks"
input body_segment_masks_pk_columns_input {
  id: Int!
}

# select columns of table "body_segment_masks"
enum body_segment_masks_select_column {
  # column name
  body_segment_id

  # column name
  body_segment_mask_shape

  # column name
  fill_layer_id

  # column name
  fill_percent

  # column name
  id

  # column name
  interlining_layer_id

  # column name
  lining_layer_id

  # column name
  shell_layer_id

  # column name
  uniform_segment_thickness
}

# input type for updating data in table "body_segment_masks"
input body_segment_masks_set_input {
  body_segment_id: Int
  body_segment_mask_shape: body_segment_mask_shapes_enum
  fill_layer_id: Int
  fill_percent: numeric
  id: Int
  interlining_layer_id: Int
  lining_layer_id: Int
  shell_layer_id: Int
  uniform_segment_thickness: numeric
}

# aggregate stddev on columns
type body_segment_masks_stddev_fields {
  body_segment_id: Float
  fill_layer_id: Float
  fill_percent: Float
  id: Float
  interlining_layer_id: Float
  lining_layer_id: Float
  shell_layer_id: Float
  uniform_segment_thickness: Float
}

# order by stddev() on columns of table "body_segment_masks"
input body_segment_masks_stddev_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# aggregate stddev_pop on columns
type body_segment_masks_stddev_pop_fields {
  body_segment_id: Float
  fill_layer_id: Float
  fill_percent: Float
  id: Float
  interlining_layer_id: Float
  lining_layer_id: Float
  shell_layer_id: Float
  uniform_segment_thickness: Float
}

# order by stddev_pop() on columns of table "body_segment_masks"
input body_segment_masks_stddev_pop_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# aggregate stddev_samp on columns
type body_segment_masks_stddev_samp_fields {
  body_segment_id: Float
  fill_layer_id: Float
  fill_percent: Float
  id: Float
  interlining_layer_id: Float
  lining_layer_id: Float
  shell_layer_id: Float
  uniform_segment_thickness: Float
}

# order by stddev_samp() on columns of table "body_segment_masks"
input body_segment_masks_stddev_samp_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# aggregate sum on columns
type body_segment_masks_sum_fields {
  body_segment_id: Int
  fill_layer_id: Int
  fill_percent: numeric
  id: Int
  interlining_layer_id: Int
  lining_layer_id: Int
  shell_layer_id: Int
  uniform_segment_thickness: numeric
}

# order by sum() on columns of table "body_segment_masks"
input body_segment_masks_sum_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# update columns of table "body_segment_masks"
enum body_segment_masks_update_column {
  # column name
  body_segment_id

  # column name
  body_segment_mask_shape

  # column name
  fill_layer_id

  # column name
  fill_percent

  # column name
  id

  # column name
  interlining_layer_id

  # column name
  lining_layer_id

  # column name
  shell_layer_id

  # column name
  uniform_segment_thickness
}

# aggregate var_pop on columns
type body_segment_masks_var_pop_fields {
  body_segment_id: Float
  fill_layer_id: Float
  fill_percent: Float
  id: Float
  interlining_layer_id: Float
  lining_layer_id: Float
  shell_layer_id: Float
  uniform_segment_thickness: Float
}

# order by var_pop() on columns of table "body_segment_masks"
input body_segment_masks_var_pop_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# aggregate var_samp on columns
type body_segment_masks_var_samp_fields {
  body_segment_id: Float
  fill_layer_id: Float
  fill_percent: Float
  id: Float
  interlining_layer_id: Float
  lining_layer_id: Float
  shell_layer_id: Float
  uniform_segment_thickness: Float
}

# order by var_samp() on columns of table "body_segment_masks"
input body_segment_masks_var_samp_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# aggregate variance on columns
type body_segment_masks_variance_fields {
  body_segment_id: Float
  fill_layer_id: Float
  fill_percent: Float
  id: Float
  interlining_layer_id: Float
  lining_layer_id: Float
  shell_layer_id: Float
  uniform_segment_thickness: Float
}

# order by variance() on columns of table "body_segment_masks"
input body_segment_masks_variance_order_by {
  body_segment_id: order_by
  fill_layer_id: order_by
  fill_percent: order_by
  id: order_by
  interlining_layer_id: order_by
  lining_layer_id: order_by
  shell_layer_id: order_by
  uniform_segment_thickness: order_by
}

# Enum-like types of different body segments (regions) that make up the body.
#
#
# columns and relationships of "body_segments"
#
type body_segments {
  body_group: body_groups_enum
  id: Int!
  name: String!
}

# aggregated selection of "body_segments"
type body_segments_aggregate {
  aggregate: body_segments_aggregate_fields
  nodes: [body_segments!]!
}

# aggregate fields of "body_segments"
type body_segments_aggregate_fields {
  avg: body_segments_avg_fields
  count(columns: [body_segments_select_column!], distinct: Boolean): Int
  max: body_segments_max_fields
  min: body_segments_min_fields
  stddev: body_segments_stddev_fields
  stddev_pop: body_segments_stddev_pop_fields
  stddev_samp: body_segments_stddev_samp_fields
  sum: body_segments_sum_fields
  var_pop: body_segments_var_pop_fields
  var_samp: body_segments_var_samp_fields
  variance: body_segments_variance_fields
}

# order by aggregate values of table "body_segments"
input body_segments_aggregate_order_by {
  avg: body_segments_avg_order_by
  count: order_by
  max: body_segments_max_order_by
  min: body_segments_min_order_by
  stddev: body_segments_stddev_order_by
  stddev_pop: body_segments_stddev_pop_order_by
  stddev_samp: body_segments_stddev_samp_order_by
  sum: body_segments_sum_order_by
  var_pop: body_segments_var_pop_order_by
  var_samp: body_segments_var_samp_order_by
  variance: body_segments_variance_order_by
}

# input type for inserting array relation for remote table "body_segments"
input body_segments_arr_rel_insert_input {
  data: [body_segments_insert_input!]!
  on_conflict: body_segments_on_conflict
}

# aggregate avg on columns
type body_segments_avg_fields {
  id: Float
}

# order by avg() on columns of table "body_segments"
input body_segments_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "body_segments". All fields are combined with a logical 'AND'.
input body_segments_bool_exp {
  _and: [body_segments_bool_exp]
  _not: body_segments_bool_exp
  _or: [body_segments_bool_exp]
  body_group: body_groups_enum_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "body_segments"
enum body_segments_constraint {
  # unique or primary key constraint
  body_segments_name_key

  # unique or primary key constraint
  body_segments_pkey
}

# input type for incrementing integer column in table "body_segments"
input body_segments_inc_input {
  id: Int
}

# input type for inserting data into table "body_segments"
input body_segments_insert_input {
  body_group: body_groups_enum
  id: Int
  name: String
}

# aggregate max on columns
type body_segments_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "body_segments"
input body_segments_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type body_segments_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "body_segments"
input body_segments_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "body_segments"
type body_segments_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [body_segments!]!
}

# input type for inserting object relation for remote table "body_segments"
input body_segments_obj_rel_insert_input {
  data: body_segments_insert_input!
  on_conflict: body_segments_on_conflict
}

# on conflict condition type for table "body_segments"
input body_segments_on_conflict {
  constraint: body_segments_constraint!
  update_columns: [body_segments_update_column!]!
  where: body_segments_bool_exp
}

# ordering options when selecting data from "body_segments"
input body_segments_order_by {
  body_group: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "body_segments"
input body_segments_pk_columns_input {
  id: Int!
}

# select columns of table "body_segments"
enum body_segments_select_column {
  # column name
  body_group

  # column name
  id

  # column name
  name
}

# input type for updating data in table "body_segments"
input body_segments_set_input {
  body_group: body_groups_enum
  id: Int
  name: String
}

# aggregate stddev on columns
type body_segments_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "body_segments"
input body_segments_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type body_segments_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "body_segments"
input body_segments_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type body_segments_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "body_segments"
input body_segments_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type body_segments_sum_fields {
  id: Int
}

# order by sum() on columns of table "body_segments"
input body_segments_sum_order_by {
  id: order_by
}

# update columns of table "body_segments"
enum body_segments_update_column {
  # column name
  body_group

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type body_segments_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "body_segments"
input body_segments_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type body_segments_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "body_segments"
input body_segments_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type body_segments_variance_fields {
  id: Float
}

# order by variance() on columns of table "body_segments"
input body_segments_variance_order_by {
  id: order_by
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# The special features and/or capabilities that some clothing may have
#
#
# columns and relationships of "clothing_features"
#
type clothing_features {
  description: String
  value: String!
}

# aggregated selection of "clothing_features"
type clothing_features_aggregate {
  aggregate: clothing_features_aggregate_fields
  nodes: [clothing_features!]!
}

# aggregate fields of "clothing_features"
type clothing_features_aggregate_fields {
  count(columns: [clothing_features_select_column!], distinct: Boolean): Int
  max: clothing_features_max_fields
  min: clothing_features_min_fields
}

# order by aggregate values of table "clothing_features"
input clothing_features_aggregate_order_by {
  count: order_by
  max: clothing_features_max_order_by
  min: clothing_features_min_order_by
}

# input type for inserting array relation for remote table "clothing_features"
input clothing_features_arr_rel_insert_input {
  data: [clothing_features_insert_input!]!
  on_conflict: clothing_features_on_conflict
}

# Boolean expression to filter rows from the table "clothing_features". All fields are combined with a logical 'AND'.
input clothing_features_bool_exp {
  _and: [clothing_features_bool_exp]
  _not: clothing_features_bool_exp
  _or: [clothing_features_bool_exp]
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "clothing_features"
enum clothing_features_constraint {
  # unique or primary key constraint
  clothing_features_pkey
}

# input type for inserting data into table "clothing_features"
input clothing_features_insert_input {
  description: String
  value: String
}

# aggregate max on columns
type clothing_features_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "clothing_features"
input clothing_features_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type clothing_features_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "clothing_features"
input clothing_features_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "clothing_features"
type clothing_features_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_features!]!
}

# input type for inserting object relation for remote table "clothing_features"
input clothing_features_obj_rel_insert_input {
  data: clothing_features_insert_input!
  on_conflict: clothing_features_on_conflict
}

# on conflict condition type for table "clothing_features"
input clothing_features_on_conflict {
  constraint: clothing_features_constraint!
  update_columns: [clothing_features_update_column!]!
  where: clothing_features_bool_exp
}

# ordering options when selecting data from "clothing_features"
input clothing_features_order_by {
  description: order_by
  value: order_by
}

# primary key columns input for table: "clothing_features"
input clothing_features_pk_columns_input {
  value: String!
}

# select columns of table "clothing_features"
enum clothing_features_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "clothing_features"
input clothing_features_set_input {
  description: String
  value: String
}

# update columns of table "clothing_features"
enum clothing_features_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "clothing_masks"
type clothing_masks {
  id: Int!
  iso_coverage: numeric!
  iso_id: String!
  name: String
}

# aggregated selection of "clothing_masks"
type clothing_masks_aggregate {
  aggregate: clothing_masks_aggregate_fields
  nodes: [clothing_masks!]!
}

# aggregate fields of "clothing_masks"
type clothing_masks_aggregate_fields {
  avg: clothing_masks_avg_fields
  count(columns: [clothing_masks_select_column!], distinct: Boolean): Int
  max: clothing_masks_max_fields
  min: clothing_masks_min_fields
  stddev: clothing_masks_stddev_fields
  stddev_pop: clothing_masks_stddev_pop_fields
  stddev_samp: clothing_masks_stddev_samp_fields
  sum: clothing_masks_sum_fields
  var_pop: clothing_masks_var_pop_fields
  var_samp: clothing_masks_var_samp_fields
  variance: clothing_masks_variance_fields
}

# order by aggregate values of table "clothing_masks"
input clothing_masks_aggregate_order_by {
  avg: clothing_masks_avg_order_by
  count: order_by
  max: clothing_masks_max_order_by
  min: clothing_masks_min_order_by
  stddev: clothing_masks_stddev_order_by
  stddev_pop: clothing_masks_stddev_pop_order_by
  stddev_samp: clothing_masks_stddev_samp_order_by
  sum: clothing_masks_sum_order_by
  var_pop: clothing_masks_var_pop_order_by
  var_samp: clothing_masks_var_samp_order_by
  variance: clothing_masks_variance_order_by
}

# input type for inserting array relation for remote table "clothing_masks"
input clothing_masks_arr_rel_insert_input {
  data: [clothing_masks_insert_input!]!
  on_conflict: clothing_masks_on_conflict
}

# aggregate avg on columns
type clothing_masks_avg_fields {
  id: Float
  iso_coverage: Float
}

# order by avg() on columns of table "clothing_masks"
input clothing_masks_avg_order_by {
  id: order_by
  iso_coverage: order_by
}

# Boolean expression to filter rows from the table "clothing_masks". All fields are combined with a logical 'AND'.
input clothing_masks_bool_exp {
  _and: [clothing_masks_bool_exp]
  _not: clothing_masks_bool_exp
  _or: [clothing_masks_bool_exp]
  id: Int_comparison_exp
  iso_coverage: numeric_comparison_exp
  iso_id: String_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "clothing_masks"
enum clothing_masks_constraint {
  # unique or primary key constraint
  clothing_masks_pkey
}

# input type for incrementing integer column in table "clothing_masks"
input clothing_masks_inc_input {
  id: Int
  iso_coverage: numeric
}

# input type for inserting data into table "clothing_masks"
input clothing_masks_insert_input {
  id: Int
  iso_coverage: numeric
  iso_id: String
  name: String
}

# aggregate max on columns
type clothing_masks_max_fields {
  id: Int
  iso_coverage: numeric
  iso_id: String
  name: String
}

# order by max() on columns of table "clothing_masks"
input clothing_masks_max_order_by {
  id: order_by
  iso_coverage: order_by
  iso_id: order_by
  name: order_by
}

# aggregate min on columns
type clothing_masks_min_fields {
  id: Int
  iso_coverage: numeric
  iso_id: String
  name: String
}

# order by min() on columns of table "clothing_masks"
input clothing_masks_min_order_by {
  id: order_by
  iso_coverage: order_by
  iso_id: order_by
  name: order_by
}

# response of any mutation on the table "clothing_masks"
type clothing_masks_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_masks!]!
}

# input type for inserting object relation for remote table "clothing_masks"
input clothing_masks_obj_rel_insert_input {
  data: clothing_masks_insert_input!
  on_conflict: clothing_masks_on_conflict
}

# on conflict condition type for table "clothing_masks"
input clothing_masks_on_conflict {
  constraint: clothing_masks_constraint!
  update_columns: [clothing_masks_update_column!]!
  where: clothing_masks_bool_exp
}

# ordering options when selecting data from "clothing_masks"
input clothing_masks_order_by {
  id: order_by
  iso_coverage: order_by
  iso_id: order_by
  name: order_by
}

# primary key columns input for table: "clothing_masks"
input clothing_masks_pk_columns_input {
  id: Int!
}

# select columns of table "clothing_masks"
enum clothing_masks_select_column {
  # column name
  id

  # column name
  iso_coverage

  # column name
  iso_id

  # column name
  name
}

# input type for updating data in table "clothing_masks"
input clothing_masks_set_input {
  id: Int
  iso_coverage: numeric
  iso_id: String
  name: String
}

# aggregate stddev on columns
type clothing_masks_stddev_fields {
  id: Float
  iso_coverage: Float
}

# order by stddev() on columns of table "clothing_masks"
input clothing_masks_stddev_order_by {
  id: order_by
  iso_coverage: order_by
}

# aggregate stddev_pop on columns
type clothing_masks_stddev_pop_fields {
  id: Float
  iso_coverage: Float
}

# order by stddev_pop() on columns of table "clothing_masks"
input clothing_masks_stddev_pop_order_by {
  id: order_by
  iso_coverage: order_by
}

# aggregate stddev_samp on columns
type clothing_masks_stddev_samp_fields {
  id: Float
  iso_coverage: Float
}

# order by stddev_samp() on columns of table "clothing_masks"
input clothing_masks_stddev_samp_order_by {
  id: order_by
  iso_coverage: order_by
}

# aggregate sum on columns
type clothing_masks_sum_fields {
  id: Int
  iso_coverage: numeric
}

# order by sum() on columns of table "clothing_masks"
input clothing_masks_sum_order_by {
  id: order_by
  iso_coverage: order_by
}

# update columns of table "clothing_masks"
enum clothing_masks_update_column {
  # column name
  id

  # column name
  iso_coverage

  # column name
  iso_id

  # column name
  name
}

# aggregate var_pop on columns
type clothing_masks_var_pop_fields {
  id: Float
  iso_coverage: Float
}

# order by var_pop() on columns of table "clothing_masks"
input clothing_masks_var_pop_order_by {
  id: order_by
  iso_coverage: order_by
}

# aggregate var_samp on columns
type clothing_masks_var_samp_fields {
  id: Float
  iso_coverage: Float
}

# order by var_samp() on columns of table "clothing_masks"
input clothing_masks_var_samp_order_by {
  id: order_by
  iso_coverage: order_by
}

# aggregate variance on columns
type clothing_masks_variance_fields {
  id: Float
  iso_coverage: Float
}

# order by variance() on columns of table "clothing_masks"
input clothing_masks_variance_order_by {
  id: order_by
  iso_coverage: order_by
}

# Clothing segment bounds enum values. This is for validation purposes. Rows in
# this table must match values found in the clothing-enums package.
#
#
# columns and relationships of "clothing_segment_bounds"
#
type clothing_segment_bounds {
  value: smallint!
}

# aggregated selection of "clothing_segment_bounds"
type clothing_segment_bounds_aggregate {
  aggregate: clothing_segment_bounds_aggregate_fields
  nodes: [clothing_segment_bounds!]!
}

# aggregate fields of "clothing_segment_bounds"
type clothing_segment_bounds_aggregate_fields {
  avg: clothing_segment_bounds_avg_fields
  count(columns: [clothing_segment_bounds_select_column!], distinct: Boolean): Int
  max: clothing_segment_bounds_max_fields
  min: clothing_segment_bounds_min_fields
  stddev: clothing_segment_bounds_stddev_fields
  stddev_pop: clothing_segment_bounds_stddev_pop_fields
  stddev_samp: clothing_segment_bounds_stddev_samp_fields
  sum: clothing_segment_bounds_sum_fields
  var_pop: clothing_segment_bounds_var_pop_fields
  var_samp: clothing_segment_bounds_var_samp_fields
  variance: clothing_segment_bounds_variance_fields
}

# order by aggregate values of table "clothing_segment_bounds"
input clothing_segment_bounds_aggregate_order_by {
  avg: clothing_segment_bounds_avg_order_by
  count: order_by
  max: clothing_segment_bounds_max_order_by
  min: clothing_segment_bounds_min_order_by
  stddev: clothing_segment_bounds_stddev_order_by
  stddev_pop: clothing_segment_bounds_stddev_pop_order_by
  stddev_samp: clothing_segment_bounds_stddev_samp_order_by
  sum: clothing_segment_bounds_sum_order_by
  var_pop: clothing_segment_bounds_var_pop_order_by
  var_samp: clothing_segment_bounds_var_samp_order_by
  variance: clothing_segment_bounds_variance_order_by
}

# input type for inserting array relation for remote table "clothing_segment_bounds"
input clothing_segment_bounds_arr_rel_insert_input {
  data: [clothing_segment_bounds_insert_input!]!
  on_conflict: clothing_segment_bounds_on_conflict
}

# aggregate avg on columns
type clothing_segment_bounds_avg_fields {
  value: Float
}

# order by avg() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_avg_order_by {
  value: order_by
}

# Boolean expression to filter rows from the table "clothing_segment_bounds". All fields are combined with a logical 'AND'.
input clothing_segment_bounds_bool_exp {
  _and: [clothing_segment_bounds_bool_exp]
  _not: clothing_segment_bounds_bool_exp
  _or: [clothing_segment_bounds_bool_exp]
  value: smallint_comparison_exp
}

# unique or primary key constraints on table "clothing_segment_bounds"
enum clothing_segment_bounds_constraint {
  # unique or primary key constraint
  clothing_segment_bounds_pkey
}

# input type for incrementing integer column in table "clothing_segment_bounds"
input clothing_segment_bounds_inc_input {
  value: smallint
}

# input type for inserting data into table "clothing_segment_bounds"
input clothing_segment_bounds_insert_input {
  value: smallint
}

# aggregate max on columns
type clothing_segment_bounds_max_fields {
  value: smallint
}

# order by max() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_max_order_by {
  value: order_by
}

# aggregate min on columns
type clothing_segment_bounds_min_fields {
  value: smallint
}

# order by min() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_min_order_by {
  value: order_by
}

# response of any mutation on the table "clothing_segment_bounds"
type clothing_segment_bounds_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_segment_bounds!]!
}

# input type for inserting object relation for remote table "clothing_segment_bounds"
input clothing_segment_bounds_obj_rel_insert_input {
  data: clothing_segment_bounds_insert_input!
  on_conflict: clothing_segment_bounds_on_conflict
}

# on conflict condition type for table "clothing_segment_bounds"
input clothing_segment_bounds_on_conflict {
  constraint: clothing_segment_bounds_constraint!
  update_columns: [clothing_segment_bounds_update_column!]!
  where: clothing_segment_bounds_bool_exp
}

# ordering options when selecting data from "clothing_segment_bounds"
input clothing_segment_bounds_order_by {
  value: order_by
}

# primary key columns input for table: "clothing_segment_bounds"
input clothing_segment_bounds_pk_columns_input {
  value: smallint!
}

# select columns of table "clothing_segment_bounds"
enum clothing_segment_bounds_select_column {
  # column name
  value
}

# input type for updating data in table "clothing_segment_bounds"
input clothing_segment_bounds_set_input {
  value: smallint
}

# aggregate stddev on columns
type clothing_segment_bounds_stddev_fields {
  value: Float
}

# order by stddev() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_stddev_order_by {
  value: order_by
}

# aggregate stddev_pop on columns
type clothing_segment_bounds_stddev_pop_fields {
  value: Float
}

# order by stddev_pop() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_stddev_pop_order_by {
  value: order_by
}

# aggregate stddev_samp on columns
type clothing_segment_bounds_stddev_samp_fields {
  value: Float
}

# order by stddev_samp() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_stddev_samp_order_by {
  value: order_by
}

# aggregate sum on columns
type clothing_segment_bounds_sum_fields {
  value: smallint
}

# order by sum() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_sum_order_by {
  value: order_by
}

# update columns of table "clothing_segment_bounds"
enum clothing_segment_bounds_update_column {
  # column name
  value
}

# aggregate var_pop on columns
type clothing_segment_bounds_var_pop_fields {
  value: Float
}

# order by var_pop() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_var_pop_order_by {
  value: order_by
}

# aggregate var_samp on columns
type clothing_segment_bounds_var_samp_fields {
  value: Float
}

# order by var_samp() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_var_samp_order_by {
  value: order_by
}

# aggregate variance on columns
type clothing_segment_bounds_variance_fields {
  value: Float
}

# order by variance() on columns of table "clothing_segment_bounds"
input clothing_segment_bounds_variance_order_by {
  value: order_by
}

# columns and relationships of "clothing_segment_data"
type clothing_segment_data {
  body_front_back_is_same: Boolean!
  body_is_symmetrical: Boolean!

  # An object relationship
  clothing_shell_maindata: clothing_shell_maindata
  id: uuid!
  left_body_end_back: smallint
  left_body_end_front: smallint
  left_body_start_back: smallint
  left_body_start_front: smallint
  left_sleeve_end_back: smallint
  left_sleeve_end_front: smallint
  left_sleeve_start_back: smallint
  left_sleeve_start_front: smallint
  right_body_end_back: smallint
  right_body_end_front: smallint
  right_body_start_back: smallint
  right_body_start_front: smallint
  right_sleeve_end_back: smallint
  right_sleeve_end_front: smallint
  right_sleeve_start_back: smallint
  right_sleeve_start_front: smallint
  sleeves_front_back_is_same: Boolean!
  sleeves_is_symmetrical: Boolean!
}

# aggregated selection of "clothing_segment_data"
type clothing_segment_data_aggregate {
  aggregate: clothing_segment_data_aggregate_fields
  nodes: [clothing_segment_data!]!
}

# aggregate fields of "clothing_segment_data"
type clothing_segment_data_aggregate_fields {
  avg: clothing_segment_data_avg_fields
  count(columns: [clothing_segment_data_select_column!], distinct: Boolean): Int
  max: clothing_segment_data_max_fields
  min: clothing_segment_data_min_fields
  stddev: clothing_segment_data_stddev_fields
  stddev_pop: clothing_segment_data_stddev_pop_fields
  stddev_samp: clothing_segment_data_stddev_samp_fields
  sum: clothing_segment_data_sum_fields
  var_pop: clothing_segment_data_var_pop_fields
  var_samp: clothing_segment_data_var_samp_fields
  variance: clothing_segment_data_variance_fields
}

# order by aggregate values of table "clothing_segment_data"
input clothing_segment_data_aggregate_order_by {
  avg: clothing_segment_data_avg_order_by
  count: order_by
  max: clothing_segment_data_max_order_by
  min: clothing_segment_data_min_order_by
  stddev: clothing_segment_data_stddev_order_by
  stddev_pop: clothing_segment_data_stddev_pop_order_by
  stddev_samp: clothing_segment_data_stddev_samp_order_by
  sum: clothing_segment_data_sum_order_by
  var_pop: clothing_segment_data_var_pop_order_by
  var_samp: clothing_segment_data_var_samp_order_by
  variance: clothing_segment_data_variance_order_by
}

# input type for inserting array relation for remote table "clothing_segment_data"
input clothing_segment_data_arr_rel_insert_input {
  data: [clothing_segment_data_insert_input!]!
  on_conflict: clothing_segment_data_on_conflict
}

# aggregate avg on columns
type clothing_segment_data_avg_fields {
  left_body_end_back: Float
  left_body_end_front: Float
  left_body_start_back: Float
  left_body_start_front: Float
  left_sleeve_end_back: Float
  left_sleeve_end_front: Float
  left_sleeve_start_back: Float
  left_sleeve_start_front: Float
  right_body_end_back: Float
  right_body_end_front: Float
  right_body_start_back: Float
  right_body_start_front: Float
  right_sleeve_end_back: Float
  right_sleeve_end_front: Float
  right_sleeve_start_back: Float
  right_sleeve_start_front: Float
}

# order by avg() on columns of table "clothing_segment_data"
input clothing_segment_data_avg_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# Boolean expression to filter rows from the table "clothing_segment_data". All fields are combined with a logical 'AND'.
input clothing_segment_data_bool_exp {
  _and: [clothing_segment_data_bool_exp]
  _not: clothing_segment_data_bool_exp
  _or: [clothing_segment_data_bool_exp]
  body_front_back_is_same: Boolean_comparison_exp
  body_is_symmetrical: Boolean_comparison_exp
  clothing_shell_maindata: clothing_shell_maindata_bool_exp
  id: uuid_comparison_exp
  left_body_end_back: smallint_comparison_exp
  left_body_end_front: smallint_comparison_exp
  left_body_start_back: smallint_comparison_exp
  left_body_start_front: smallint_comparison_exp
  left_sleeve_end_back: smallint_comparison_exp
  left_sleeve_end_front: smallint_comparison_exp
  left_sleeve_start_back: smallint_comparison_exp
  left_sleeve_start_front: smallint_comparison_exp
  right_body_end_back: smallint_comparison_exp
  right_body_end_front: smallint_comparison_exp
  right_body_start_back: smallint_comparison_exp
  right_body_start_front: smallint_comparison_exp
  right_sleeve_end_back: smallint_comparison_exp
  right_sleeve_end_front: smallint_comparison_exp
  right_sleeve_start_back: smallint_comparison_exp
  right_sleeve_start_front: smallint_comparison_exp
  sleeves_front_back_is_same: Boolean_comparison_exp
  sleeves_is_symmetrical: Boolean_comparison_exp
}

# unique or primary key constraints on table "clothing_segment_data"
enum clothing_segment_data_constraint {
  # unique or primary key constraint
  clothing_segment_data_pkey
}

# input type for incrementing integer column in table "clothing_segment_data"
input clothing_segment_data_inc_input {
  left_body_end_back: smallint
  left_body_end_front: smallint
  left_body_start_back: smallint
  left_body_start_front: smallint
  left_sleeve_end_back: smallint
  left_sleeve_end_front: smallint
  left_sleeve_start_back: smallint
  left_sleeve_start_front: smallint
  right_body_end_back: smallint
  right_body_end_front: smallint
  right_body_start_back: smallint
  right_body_start_front: smallint
  right_sleeve_end_back: smallint
  right_sleeve_end_front: smallint
  right_sleeve_start_back: smallint
  right_sleeve_start_front: smallint
}

# input type for inserting data into table "clothing_segment_data"
input clothing_segment_data_insert_input {
  body_front_back_is_same: Boolean
  body_is_symmetrical: Boolean
  clothing_shell_maindata: clothing_shell_maindata_obj_rel_insert_input
  id: uuid
  left_body_end_back: smallint
  left_body_end_front: smallint
  left_body_start_back: smallint
  left_body_start_front: smallint
  left_sleeve_end_back: smallint
  left_sleeve_end_front: smallint
  left_sleeve_start_back: smallint
  left_sleeve_start_front: smallint
  right_body_end_back: smallint
  right_body_end_front: smallint
  right_body_start_back: smallint
  right_body_start_front: smallint
  right_sleeve_end_back: smallint
  right_sleeve_end_front: smallint
  right_sleeve_start_back: smallint
  right_sleeve_start_front: smallint
  sleeves_front_back_is_same: Boolean
  sleeves_is_symmetrical: Boolean
}

# aggregate max on columns
type clothing_segment_data_max_fields {
  id: uuid
  left_body_end_back: smallint
  left_body_end_front: smallint
  left_body_start_back: smallint
  left_body_start_front: smallint
  left_sleeve_end_back: smallint
  left_sleeve_end_front: smallint
  left_sleeve_start_back: smallint
  left_sleeve_start_front: smallint
  right_body_end_back: smallint
  right_body_end_front: smallint
  right_body_start_back: smallint
  right_body_start_front: smallint
  right_sleeve_end_back: smallint
  right_sleeve_end_front: smallint
  right_sleeve_start_back: smallint
  right_sleeve_start_front: smallint
}

# order by max() on columns of table "clothing_segment_data"
input clothing_segment_data_max_order_by {
  id: order_by
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# aggregate min on columns
type clothing_segment_data_min_fields {
  id: uuid
  left_body_end_back: smallint
  left_body_end_front: smallint
  left_body_start_back: smallint
  left_body_start_front: smallint
  left_sleeve_end_back: smallint
  left_sleeve_end_front: smallint
  left_sleeve_start_back: smallint
  left_sleeve_start_front: smallint
  right_body_end_back: smallint
  right_body_end_front: smallint
  right_body_start_back: smallint
  right_body_start_front: smallint
  right_sleeve_end_back: smallint
  right_sleeve_end_front: smallint
  right_sleeve_start_back: smallint
  right_sleeve_start_front: smallint
}

# order by min() on columns of table "clothing_segment_data"
input clothing_segment_data_min_order_by {
  id: order_by
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# response of any mutation on the table "clothing_segment_data"
type clothing_segment_data_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_segment_data!]!
}

# input type for inserting object relation for remote table "clothing_segment_data"
input clothing_segment_data_obj_rel_insert_input {
  data: clothing_segment_data_insert_input!
  on_conflict: clothing_segment_data_on_conflict
}

# on conflict condition type for table "clothing_segment_data"
input clothing_segment_data_on_conflict {
  constraint: clothing_segment_data_constraint!
  update_columns: [clothing_segment_data_update_column!]!
  where: clothing_segment_data_bool_exp
}

# ordering options when selecting data from "clothing_segment_data"
input clothing_segment_data_order_by {
  body_front_back_is_same: order_by
  body_is_symmetrical: order_by
  clothing_shell_maindata: clothing_shell_maindata_order_by
  id: order_by
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
  sleeves_front_back_is_same: order_by
  sleeves_is_symmetrical: order_by
}

# primary key columns input for table: "clothing_segment_data"
input clothing_segment_data_pk_columns_input {
  id: uuid!
}

# select columns of table "clothing_segment_data"
enum clothing_segment_data_select_column {
  # column name
  body_front_back_is_same

  # column name
  body_is_symmetrical

  # column name
  id

  # column name
  left_body_end_back

  # column name
  left_body_end_front

  # column name
  left_body_start_back

  # column name
  left_body_start_front

  # column name
  left_sleeve_end_back

  # column name
  left_sleeve_end_front

  # column name
  left_sleeve_start_back

  # column name
  left_sleeve_start_front

  # column name
  right_body_end_back

  # column name
  right_body_end_front

  # column name
  right_body_start_back

  # column name
  right_body_start_front

  # column name
  right_sleeve_end_back

  # column name
  right_sleeve_end_front

  # column name
  right_sleeve_start_back

  # column name
  right_sleeve_start_front

  # column name
  sleeves_front_back_is_same

  # column name
  sleeves_is_symmetrical
}

# input type for updating data in table "clothing_segment_data"
input clothing_segment_data_set_input {
  body_front_back_is_same: Boolean
  body_is_symmetrical: Boolean
  id: uuid
  left_body_end_back: smallint
  left_body_end_front: smallint
  left_body_start_back: smallint
  left_body_start_front: smallint
  left_sleeve_end_back: smallint
  left_sleeve_end_front: smallint
  left_sleeve_start_back: smallint
  left_sleeve_start_front: smallint
  right_body_end_back: smallint
  right_body_end_front: smallint
  right_body_start_back: smallint
  right_body_start_front: smallint
  right_sleeve_end_back: smallint
  right_sleeve_end_front: smallint
  right_sleeve_start_back: smallint
  right_sleeve_start_front: smallint
  sleeves_front_back_is_same: Boolean
  sleeves_is_symmetrical: Boolean
}

# aggregate stddev on columns
type clothing_segment_data_stddev_fields {
  left_body_end_back: Float
  left_body_end_front: Float
  left_body_start_back: Float
  left_body_start_front: Float
  left_sleeve_end_back: Float
  left_sleeve_end_front: Float
  left_sleeve_start_back: Float
  left_sleeve_start_front: Float
  right_body_end_back: Float
  right_body_end_front: Float
  right_body_start_back: Float
  right_body_start_front: Float
  right_sleeve_end_back: Float
  right_sleeve_end_front: Float
  right_sleeve_start_back: Float
  right_sleeve_start_front: Float
}

# order by stddev() on columns of table "clothing_segment_data"
input clothing_segment_data_stddev_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# aggregate stddev_pop on columns
type clothing_segment_data_stddev_pop_fields {
  left_body_end_back: Float
  left_body_end_front: Float
  left_body_start_back: Float
  left_body_start_front: Float
  left_sleeve_end_back: Float
  left_sleeve_end_front: Float
  left_sleeve_start_back: Float
  left_sleeve_start_front: Float
  right_body_end_back: Float
  right_body_end_front: Float
  right_body_start_back: Float
  right_body_start_front: Float
  right_sleeve_end_back: Float
  right_sleeve_end_front: Float
  right_sleeve_start_back: Float
  right_sleeve_start_front: Float
}

# order by stddev_pop() on columns of table "clothing_segment_data"
input clothing_segment_data_stddev_pop_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# aggregate stddev_samp on columns
type clothing_segment_data_stddev_samp_fields {
  left_body_end_back: Float
  left_body_end_front: Float
  left_body_start_back: Float
  left_body_start_front: Float
  left_sleeve_end_back: Float
  left_sleeve_end_front: Float
  left_sleeve_start_back: Float
  left_sleeve_start_front: Float
  right_body_end_back: Float
  right_body_end_front: Float
  right_body_start_back: Float
  right_body_start_front: Float
  right_sleeve_end_back: Float
  right_sleeve_end_front: Float
  right_sleeve_start_back: Float
  right_sleeve_start_front: Float
}

# order by stddev_samp() on columns of table "clothing_segment_data"
input clothing_segment_data_stddev_samp_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# aggregate sum on columns
type clothing_segment_data_sum_fields {
  left_body_end_back: smallint
  left_body_end_front: smallint
  left_body_start_back: smallint
  left_body_start_front: smallint
  left_sleeve_end_back: smallint
  left_sleeve_end_front: smallint
  left_sleeve_start_back: smallint
  left_sleeve_start_front: smallint
  right_body_end_back: smallint
  right_body_end_front: smallint
  right_body_start_back: smallint
  right_body_start_front: smallint
  right_sleeve_end_back: smallint
  right_sleeve_end_front: smallint
  right_sleeve_start_back: smallint
  right_sleeve_start_front: smallint
}

# order by sum() on columns of table "clothing_segment_data"
input clothing_segment_data_sum_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# update columns of table "clothing_segment_data"
enum clothing_segment_data_update_column {
  # column name
  body_front_back_is_same

  # column name
  body_is_symmetrical

  # column name
  id

  # column name
  left_body_end_back

  # column name
  left_body_end_front

  # column name
  left_body_start_back

  # column name
  left_body_start_front

  # column name
  left_sleeve_end_back

  # column name
  left_sleeve_end_front

  # column name
  left_sleeve_start_back

  # column name
  left_sleeve_start_front

  # column name
  right_body_end_back

  # column name
  right_body_end_front

  # column name
  right_body_start_back

  # column name
  right_body_start_front

  # column name
  right_sleeve_end_back

  # column name
  right_sleeve_end_front

  # column name
  right_sleeve_start_back

  # column name
  right_sleeve_start_front

  # column name
  sleeves_front_back_is_same

  # column name
  sleeves_is_symmetrical
}

# aggregate var_pop on columns
type clothing_segment_data_var_pop_fields {
  left_body_end_back: Float
  left_body_end_front: Float
  left_body_start_back: Float
  left_body_start_front: Float
  left_sleeve_end_back: Float
  left_sleeve_end_front: Float
  left_sleeve_start_back: Float
  left_sleeve_start_front: Float
  right_body_end_back: Float
  right_body_end_front: Float
  right_body_start_back: Float
  right_body_start_front: Float
  right_sleeve_end_back: Float
  right_sleeve_end_front: Float
  right_sleeve_start_back: Float
  right_sleeve_start_front: Float
}

# order by var_pop() on columns of table "clothing_segment_data"
input clothing_segment_data_var_pop_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# aggregate var_samp on columns
type clothing_segment_data_var_samp_fields {
  left_body_end_back: Float
  left_body_end_front: Float
  left_body_start_back: Float
  left_body_start_front: Float
  left_sleeve_end_back: Float
  left_sleeve_end_front: Float
  left_sleeve_start_back: Float
  left_sleeve_start_front: Float
  right_body_end_back: Float
  right_body_end_front: Float
  right_body_start_back: Float
  right_body_start_front: Float
  right_sleeve_end_back: Float
  right_sleeve_end_front: Float
  right_sleeve_start_back: Float
  right_sleeve_start_front: Float
}

# order by var_samp() on columns of table "clothing_segment_data"
input clothing_segment_data_var_samp_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# aggregate variance on columns
type clothing_segment_data_variance_fields {
  left_body_end_back: Float
  left_body_end_front: Float
  left_body_start_back: Float
  left_body_start_front: Float
  left_sleeve_end_back: Float
  left_sleeve_end_front: Float
  left_sleeve_start_back: Float
  left_sleeve_start_front: Float
  right_body_end_back: Float
  right_body_end_front: Float
  right_body_start_back: Float
  right_body_start_front: Float
  right_sleeve_end_back: Float
  right_sleeve_end_front: Float
  right_sleeve_start_back: Float
  right_sleeve_start_front: Float
}

# order by variance() on columns of table "clothing_segment_data"
input clothing_segment_data_variance_order_by {
  left_body_end_back: order_by
  left_body_end_front: order_by
  left_body_start_back: order_by
  left_body_start_front: order_by
  left_sleeve_end_back: order_by
  left_sleeve_end_front: order_by
  left_sleeve_start_back: order_by
  left_sleeve_start_front: order_by
  right_body_end_back: order_by
  right_body_end_front: order_by
  right_body_start_back: order_by
  right_body_start_front: order_by
  right_sleeve_end_back: order_by
  right_sleeve_end_front: order_by
  right_sleeve_start_back: order_by
  right_sleeve_start_front: order_by
}

# A many-to-many relationship table representing a clothing shell having multiple
# body segment masks. Body segment masks may be reused within other clothing
# shells, hence the many-to-many relationship.
#
#
# columns and relationships of "clothing_shell_and_body_segment_mask"
#
type clothing_shell_and_body_segment_mask {
  # An object relationship
  body_segment_mask: body_segment_masks!
  body_segment_mask_id: Int!

  # An object relationship
  clothing_shell: clothing_shells!
  clothing_shell_id: Int!
}

# aggregated selection of "clothing_shell_and_body_segment_mask"
type clothing_shell_and_body_segment_mask_aggregate {
  aggregate: clothing_shell_and_body_segment_mask_aggregate_fields
  nodes: [clothing_shell_and_body_segment_mask!]!
}

# aggregate fields of "clothing_shell_and_body_segment_mask"
type clothing_shell_and_body_segment_mask_aggregate_fields {
  avg: clothing_shell_and_body_segment_mask_avg_fields
  count(columns: [clothing_shell_and_body_segment_mask_select_column!], distinct: Boolean): Int
  max: clothing_shell_and_body_segment_mask_max_fields
  min: clothing_shell_and_body_segment_mask_min_fields
  stddev: clothing_shell_and_body_segment_mask_stddev_fields
  stddev_pop: clothing_shell_and_body_segment_mask_stddev_pop_fields
  stddev_samp: clothing_shell_and_body_segment_mask_stddev_samp_fields
  sum: clothing_shell_and_body_segment_mask_sum_fields
  var_pop: clothing_shell_and_body_segment_mask_var_pop_fields
  var_samp: clothing_shell_and_body_segment_mask_var_samp_fields
  variance: clothing_shell_and_body_segment_mask_variance_fields
}

# order by aggregate values of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_aggregate_order_by {
  avg: clothing_shell_and_body_segment_mask_avg_order_by
  count: order_by
  max: clothing_shell_and_body_segment_mask_max_order_by
  min: clothing_shell_and_body_segment_mask_min_order_by
  stddev: clothing_shell_and_body_segment_mask_stddev_order_by
  stddev_pop: clothing_shell_and_body_segment_mask_stddev_pop_order_by
  stddev_samp: clothing_shell_and_body_segment_mask_stddev_samp_order_by
  sum: clothing_shell_and_body_segment_mask_sum_order_by
  var_pop: clothing_shell_and_body_segment_mask_var_pop_order_by
  var_samp: clothing_shell_and_body_segment_mask_var_samp_order_by
  variance: clothing_shell_and_body_segment_mask_variance_order_by
}

# input type for inserting array relation for remote table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_arr_rel_insert_input {
  data: [clothing_shell_and_body_segment_mask_insert_input!]!
  on_conflict: clothing_shell_and_body_segment_mask_on_conflict
}

# aggregate avg on columns
type clothing_shell_and_body_segment_mask_avg_fields {
  body_segment_mask_id: Float
  clothing_shell_id: Float
}

# order by avg() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_avg_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# Boolean expression to filter rows from the table
# "clothing_shell_and_body_segment_mask". All fields are combined with a logical 'AND'.
input clothing_shell_and_body_segment_mask_bool_exp {
  _and: [clothing_shell_and_body_segment_mask_bool_exp]
  _not: clothing_shell_and_body_segment_mask_bool_exp
  _or: [clothing_shell_and_body_segment_mask_bool_exp]
  body_segment_mask: body_segment_masks_bool_exp
  body_segment_mask_id: Int_comparison_exp
  clothing_shell: clothing_shells_bool_exp
  clothing_shell_id: Int_comparison_exp
}

# unique or primary key constraints on table "clothing_shell_and_body_segment_mask"
enum clothing_shell_and_body_segment_mask_constraint {
  # unique or primary key constraint
  body_segment_mask_and_clothing_shell_pkey
}

# input type for incrementing integer column in table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_inc_input {
  body_segment_mask_id: Int
  clothing_shell_id: Int
}

# input type for inserting data into table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_insert_input {
  body_segment_mask: body_segment_masks_obj_rel_insert_input
  body_segment_mask_id: Int
  clothing_shell: clothing_shells_obj_rel_insert_input
  clothing_shell_id: Int
}

# aggregate max on columns
type clothing_shell_and_body_segment_mask_max_fields {
  body_segment_mask_id: Int
  clothing_shell_id: Int
}

# order by max() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_max_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# aggregate min on columns
type clothing_shell_and_body_segment_mask_min_fields {
  body_segment_mask_id: Int
  clothing_shell_id: Int
}

# order by min() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_min_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# response of any mutation on the table "clothing_shell_and_body_segment_mask"
type clothing_shell_and_body_segment_mask_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_shell_and_body_segment_mask!]!
}

# input type for inserting object relation for remote table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_obj_rel_insert_input {
  data: clothing_shell_and_body_segment_mask_insert_input!
  on_conflict: clothing_shell_and_body_segment_mask_on_conflict
}

# on conflict condition type for table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_on_conflict {
  constraint: clothing_shell_and_body_segment_mask_constraint!
  update_columns: [clothing_shell_and_body_segment_mask_update_column!]!
  where: clothing_shell_and_body_segment_mask_bool_exp
}

# ordering options when selecting data from "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_order_by {
  body_segment_mask: body_segment_masks_order_by
  body_segment_mask_id: order_by
  clothing_shell: clothing_shells_order_by
  clothing_shell_id: order_by
}

# primary key columns input for table: "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_pk_columns_input {
  body_segment_mask_id: Int!
  clothing_shell_id: Int!
}

# select columns of table "clothing_shell_and_body_segment_mask"
enum clothing_shell_and_body_segment_mask_select_column {
  # column name
  body_segment_mask_id

  # column name
  clothing_shell_id
}

# input type for updating data in table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_set_input {
  body_segment_mask_id: Int
  clothing_shell_id: Int
}

# aggregate stddev on columns
type clothing_shell_and_body_segment_mask_stddev_fields {
  body_segment_mask_id: Float
  clothing_shell_id: Float
}

# order by stddev() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_stddev_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# aggregate stddev_pop on columns
type clothing_shell_and_body_segment_mask_stddev_pop_fields {
  body_segment_mask_id: Float
  clothing_shell_id: Float
}

# order by stddev_pop() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_stddev_pop_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# aggregate stddev_samp on columns
type clothing_shell_and_body_segment_mask_stddev_samp_fields {
  body_segment_mask_id: Float
  clothing_shell_id: Float
}

# order by stddev_samp() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_stddev_samp_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# aggregate sum on columns
type clothing_shell_and_body_segment_mask_sum_fields {
  body_segment_mask_id: Int
  clothing_shell_id: Int
}

# order by sum() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_sum_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# update columns of table "clothing_shell_and_body_segment_mask"
enum clothing_shell_and_body_segment_mask_update_column {
  # column name
  body_segment_mask_id

  # column name
  clothing_shell_id
}

# aggregate var_pop on columns
type clothing_shell_and_body_segment_mask_var_pop_fields {
  body_segment_mask_id: Float
  clothing_shell_id: Float
}

# order by var_pop() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_var_pop_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# aggregate var_samp on columns
type clothing_shell_and_body_segment_mask_var_samp_fields {
  body_segment_mask_id: Float
  clothing_shell_id: Float
}

# order by var_samp() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_var_samp_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# aggregate variance on columns
type clothing_shell_and_body_segment_mask_variance_fields {
  body_segment_mask_id: Float
  clothing_shell_id: Float
}

# order by variance() on columns of table "clothing_shell_and_body_segment_mask"
input clothing_shell_and_body_segment_mask_variance_order_by {
  body_segment_mask_id: order_by
  clothing_shell_id: order_by
}

# A many-to-many relationship table representing all the clothing features that a
# clothing shell can have. It also can map all unique clothing shells that a
# clothing feature belongs to.
#
#
# columns and relationships of "clothing_shell_and_clothing_feature"
#
type clothing_shell_and_clothing_feature {
  clothing_feature: String!

  # An object relationship
  clothing_shell: clothing_shells!
  clothing_shell_id: Int!
}

# aggregated selection of "clothing_shell_and_clothing_feature"
type clothing_shell_and_clothing_feature_aggregate {
  aggregate: clothing_shell_and_clothing_feature_aggregate_fields
  nodes: [clothing_shell_and_clothing_feature!]!
}

# aggregate fields of "clothing_shell_and_clothing_feature"
type clothing_shell_and_clothing_feature_aggregate_fields {
  avg: clothing_shell_and_clothing_feature_avg_fields
  count(columns: [clothing_shell_and_clothing_feature_select_column!], distinct: Boolean): Int
  max: clothing_shell_and_clothing_feature_max_fields
  min: clothing_shell_and_clothing_feature_min_fields
  stddev: clothing_shell_and_clothing_feature_stddev_fields
  stddev_pop: clothing_shell_and_clothing_feature_stddev_pop_fields
  stddev_samp: clothing_shell_and_clothing_feature_stddev_samp_fields
  sum: clothing_shell_and_clothing_feature_sum_fields
  var_pop: clothing_shell_and_clothing_feature_var_pop_fields
  var_samp: clothing_shell_and_clothing_feature_var_samp_fields
  variance: clothing_shell_and_clothing_feature_variance_fields
}

# order by aggregate values of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_aggregate_order_by {
  avg: clothing_shell_and_clothing_feature_avg_order_by
  count: order_by
  max: clothing_shell_and_clothing_feature_max_order_by
  min: clothing_shell_and_clothing_feature_min_order_by
  stddev: clothing_shell_and_clothing_feature_stddev_order_by
  stddev_pop: clothing_shell_and_clothing_feature_stddev_pop_order_by
  stddev_samp: clothing_shell_and_clothing_feature_stddev_samp_order_by
  sum: clothing_shell_and_clothing_feature_sum_order_by
  var_pop: clothing_shell_and_clothing_feature_var_pop_order_by
  var_samp: clothing_shell_and_clothing_feature_var_samp_order_by
  variance: clothing_shell_and_clothing_feature_variance_order_by
}

# input type for inserting array relation for remote table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_arr_rel_insert_input {
  data: [clothing_shell_and_clothing_feature_insert_input!]!
  on_conflict: clothing_shell_and_clothing_feature_on_conflict
}

# aggregate avg on columns
type clothing_shell_and_clothing_feature_avg_fields {
  clothing_shell_id: Float
}

# order by avg() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_avg_order_by {
  clothing_shell_id: order_by
}

# Boolean expression to filter rows from the table
# "clothing_shell_and_clothing_feature". All fields are combined with a logical 'AND'.
input clothing_shell_and_clothing_feature_bool_exp {
  _and: [clothing_shell_and_clothing_feature_bool_exp]
  _not: clothing_shell_and_clothing_feature_bool_exp
  _or: [clothing_shell_and_clothing_feature_bool_exp]
  clothing_feature: String_comparison_exp
  clothing_shell: clothing_shells_bool_exp
  clothing_shell_id: Int_comparison_exp
}

# unique or primary key constraints on table "clothing_shell_and_clothing_feature"
enum clothing_shell_and_clothing_feature_constraint {
  # unique or primary key constraint
  clothing_shell_and_clothing_feature_pkey
}

# input type for incrementing integer column in table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_inc_input {
  clothing_shell_id: Int
}

# input type for inserting data into table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_insert_input {
  clothing_feature: String
  clothing_shell: clothing_shells_obj_rel_insert_input
  clothing_shell_id: Int
}

# aggregate max on columns
type clothing_shell_and_clothing_feature_max_fields {
  clothing_feature: String
  clothing_shell_id: Int
}

# order by max() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_max_order_by {
  clothing_feature: order_by
  clothing_shell_id: order_by
}

# aggregate min on columns
type clothing_shell_and_clothing_feature_min_fields {
  clothing_feature: String
  clothing_shell_id: Int
}

# order by min() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_min_order_by {
  clothing_feature: order_by
  clothing_shell_id: order_by
}

# response of any mutation on the table "clothing_shell_and_clothing_feature"
type clothing_shell_and_clothing_feature_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_shell_and_clothing_feature!]!
}

# input type for inserting object relation for remote table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_obj_rel_insert_input {
  data: clothing_shell_and_clothing_feature_insert_input!
  on_conflict: clothing_shell_and_clothing_feature_on_conflict
}

# on conflict condition type for table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_on_conflict {
  constraint: clothing_shell_and_clothing_feature_constraint!
  update_columns: [clothing_shell_and_clothing_feature_update_column!]!
  where: clothing_shell_and_clothing_feature_bool_exp
}

# ordering options when selecting data from "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_order_by {
  clothing_feature: order_by
  clothing_shell: clothing_shells_order_by
  clothing_shell_id: order_by
}

# primary key columns input for table: "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_pk_columns_input {
  clothing_feature: String!
  clothing_shell_id: Int!
}

# select columns of table "clothing_shell_and_clothing_feature"
enum clothing_shell_and_clothing_feature_select_column {
  # column name
  clothing_feature

  # column name
  clothing_shell_id
}

# input type for updating data in table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_set_input {
  clothing_feature: String
  clothing_shell_id: Int
}

# aggregate stddev on columns
type clothing_shell_and_clothing_feature_stddev_fields {
  clothing_shell_id: Float
}

# order by stddev() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_stddev_order_by {
  clothing_shell_id: order_by
}

# aggregate stddev_pop on columns
type clothing_shell_and_clothing_feature_stddev_pop_fields {
  clothing_shell_id: Float
}

# order by stddev_pop() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_stddev_pop_order_by {
  clothing_shell_id: order_by
}

# aggregate stddev_samp on columns
type clothing_shell_and_clothing_feature_stddev_samp_fields {
  clothing_shell_id: Float
}

# order by stddev_samp() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_stddev_samp_order_by {
  clothing_shell_id: order_by
}

# aggregate sum on columns
type clothing_shell_and_clothing_feature_sum_fields {
  clothing_shell_id: Int
}

# order by sum() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_sum_order_by {
  clothing_shell_id: order_by
}

# update columns of table "clothing_shell_and_clothing_feature"
enum clothing_shell_and_clothing_feature_update_column {
  # column name
  clothing_feature

  # column name
  clothing_shell_id
}

# aggregate var_pop on columns
type clothing_shell_and_clothing_feature_var_pop_fields {
  clothing_shell_id: Float
}

# order by var_pop() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_var_pop_order_by {
  clothing_shell_id: order_by
}

# aggregate var_samp on columns
type clothing_shell_and_clothing_feature_var_samp_fields {
  clothing_shell_id: Float
}

# order by var_samp() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_var_samp_order_by {
  clothing_shell_id: order_by
}

# aggregate variance on columns
type clothing_shell_and_clothing_feature_variance_fields {
  clothing_shell_id: Float
}

# order by variance() on columns of table "clothing_shell_and_clothing_feature"
input clothing_shell_and_clothing_feature_variance_order_by {
  clothing_shell_id: order_by
}

# Data describing the various data entry aggregates (calculated) for clothing shells.
#
#
# columns and relationships of "clothing_shell_counts"
#
type clothing_shell_counts {
  # An object relationship
  clothing_shell: clothing_shells!
  clothing_shell_id: Int!
  id: Int!
  item_count: Int!
}

# aggregated selection of "clothing_shell_counts"
type clothing_shell_counts_aggregate {
  aggregate: clothing_shell_counts_aggregate_fields
  nodes: [clothing_shell_counts!]!
}

# aggregate fields of "clothing_shell_counts"
type clothing_shell_counts_aggregate_fields {
  avg: clothing_shell_counts_avg_fields
  count(columns: [clothing_shell_counts_select_column!], distinct: Boolean): Int
  max: clothing_shell_counts_max_fields
  min: clothing_shell_counts_min_fields
  stddev: clothing_shell_counts_stddev_fields
  stddev_pop: clothing_shell_counts_stddev_pop_fields
  stddev_samp: clothing_shell_counts_stddev_samp_fields
  sum: clothing_shell_counts_sum_fields
  var_pop: clothing_shell_counts_var_pop_fields
  var_samp: clothing_shell_counts_var_samp_fields
  variance: clothing_shell_counts_variance_fields
}

# order by aggregate values of table "clothing_shell_counts"
input clothing_shell_counts_aggregate_order_by {
  avg: clothing_shell_counts_avg_order_by
  count: order_by
  max: clothing_shell_counts_max_order_by
  min: clothing_shell_counts_min_order_by
  stddev: clothing_shell_counts_stddev_order_by
  stddev_pop: clothing_shell_counts_stddev_pop_order_by
  stddev_samp: clothing_shell_counts_stddev_samp_order_by
  sum: clothing_shell_counts_sum_order_by
  var_pop: clothing_shell_counts_var_pop_order_by
  var_samp: clothing_shell_counts_var_samp_order_by
  variance: clothing_shell_counts_variance_order_by
}

# input type for inserting array relation for remote table "clothing_shell_counts"
input clothing_shell_counts_arr_rel_insert_input {
  data: [clothing_shell_counts_insert_input!]!
  on_conflict: clothing_shell_counts_on_conflict
}

# aggregate avg on columns
type clothing_shell_counts_avg_fields {
  clothing_shell_id: Float
  id: Float
  item_count: Float
}

# order by avg() on columns of table "clothing_shell_counts"
input clothing_shell_counts_avg_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# Boolean expression to filter rows from the table "clothing_shell_counts". All fields are combined with a logical 'AND'.
input clothing_shell_counts_bool_exp {
  _and: [clothing_shell_counts_bool_exp]
  _not: clothing_shell_counts_bool_exp
  _or: [clothing_shell_counts_bool_exp]
  clothing_shell: clothing_shells_bool_exp
  clothing_shell_id: Int_comparison_exp
  id: Int_comparison_exp
  item_count: Int_comparison_exp
}

# unique or primary key constraints on table "clothing_shell_counts"
enum clothing_shell_counts_constraint {
  # unique or primary key constraint
  clothing_shell_counts_clothing_shell_id_key

  # unique or primary key constraint
  clothing_shell_counts_pkey
}

# input type for incrementing integer column in table "clothing_shell_counts"
input clothing_shell_counts_inc_input {
  clothing_shell_id: Int
  id: Int
  item_count: Int
}

# input type for inserting data into table "clothing_shell_counts"
input clothing_shell_counts_insert_input {
  clothing_shell: clothing_shells_obj_rel_insert_input
  clothing_shell_id: Int
  id: Int
  item_count: Int
}

# aggregate max on columns
type clothing_shell_counts_max_fields {
  clothing_shell_id: Int
  id: Int
  item_count: Int
}

# order by max() on columns of table "clothing_shell_counts"
input clothing_shell_counts_max_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate min on columns
type clothing_shell_counts_min_fields {
  clothing_shell_id: Int
  id: Int
  item_count: Int
}

# order by min() on columns of table "clothing_shell_counts"
input clothing_shell_counts_min_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# response of any mutation on the table "clothing_shell_counts"
type clothing_shell_counts_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_shell_counts!]!
}

# input type for inserting object relation for remote table "clothing_shell_counts"
input clothing_shell_counts_obj_rel_insert_input {
  data: clothing_shell_counts_insert_input!
  on_conflict: clothing_shell_counts_on_conflict
}

# on conflict condition type for table "clothing_shell_counts"
input clothing_shell_counts_on_conflict {
  constraint: clothing_shell_counts_constraint!
  update_columns: [clothing_shell_counts_update_column!]!
  where: clothing_shell_counts_bool_exp
}

# ordering options when selecting data from "clothing_shell_counts"
input clothing_shell_counts_order_by {
  clothing_shell: clothing_shells_order_by
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# primary key columns input for table: "clothing_shell_counts"
input clothing_shell_counts_pk_columns_input {
  id: Int!
}

# select columns of table "clothing_shell_counts"
enum clothing_shell_counts_select_column {
  # column name
  clothing_shell_id

  # column name
  id

  # column name
  item_count
}

# input type for updating data in table "clothing_shell_counts"
input clothing_shell_counts_set_input {
  clothing_shell_id: Int
  id: Int
  item_count: Int
}

# aggregate stddev on columns
type clothing_shell_counts_stddev_fields {
  clothing_shell_id: Float
  id: Float
  item_count: Float
}

# order by stddev() on columns of table "clothing_shell_counts"
input clothing_shell_counts_stddev_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate stddev_pop on columns
type clothing_shell_counts_stddev_pop_fields {
  clothing_shell_id: Float
  id: Float
  item_count: Float
}

# order by stddev_pop() on columns of table "clothing_shell_counts"
input clothing_shell_counts_stddev_pop_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate stddev_samp on columns
type clothing_shell_counts_stddev_samp_fields {
  clothing_shell_id: Float
  id: Float
  item_count: Float
}

# order by stddev_samp() on columns of table "clothing_shell_counts"
input clothing_shell_counts_stddev_samp_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate sum on columns
type clothing_shell_counts_sum_fields {
  clothing_shell_id: Int
  id: Int
  item_count: Int
}

# order by sum() on columns of table "clothing_shell_counts"
input clothing_shell_counts_sum_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# update columns of table "clothing_shell_counts"
enum clothing_shell_counts_update_column {
  # column name
  clothing_shell_id

  # column name
  id

  # column name
  item_count
}

# aggregate var_pop on columns
type clothing_shell_counts_var_pop_fields {
  clothing_shell_id: Float
  id: Float
  item_count: Float
}

# order by var_pop() on columns of table "clothing_shell_counts"
input clothing_shell_counts_var_pop_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate var_samp on columns
type clothing_shell_counts_var_samp_fields {
  clothing_shell_id: Float
  id: Float
  item_count: Float
}

# order by var_samp() on columns of table "clothing_shell_counts"
input clothing_shell_counts_var_samp_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate variance on columns
type clothing_shell_counts_variance_fields {
  clothing_shell_id: Float
  id: Float
  item_count: Float
}

# order by variance() on columns of table "clothing_shell_counts"
input clothing_shell_counts_variance_order_by {
  clothing_shell_id: order_by
  id: order_by
  item_count: order_by
}

# Main data about clothing shells.
#
#
# columns and relationships of "clothing_shell_maindata"
#
type clothing_shell_maindata {
  # An object relationship
  clothing_segment_data: clothing_segment_data!
  clothing_segment_data_id: uuid!

  # An object relationship
  default_fill_layer: fabric_layers

  # The default fill layer (fabric layer) that is used if there isn't any present in any of its body segment masks.
  default_fill_layer_id: Int

  # An object relationship
  default_interlining_layer: fabric_layers

  # The default lining layer (fabric layer) that is used if there isn't any present in any of its body segment masks.
  default_interlining_layer_id: Int

  # An object relationship
  default_lining_layer: fabric_layers

  # The default lining layer (fabric layer) that is used if there isn't any present in any of its body segment masks.
  default_lining_layer_id: Int

  # An object relationship
  default_shell_layer: fabric_layers

  # The default shell layer (fabric layer) that is used if there isn't any present in any of its body segment masks.
  default_shell_layer_id: Int
  id: uuid!
  is_release: Boolean!
  item_type: item_types_enum!

  # The name that describes this clothing shell. This typically is set as a
  # generic item, such as "Blue Denim Jeans" and "White Cotton T-Shirt". This will
  # only appear in the CMS and nowhere else.
  name: String

  # An object relationship
  revision: clothing_shell_maindata_revisions!
  revision_id: uuid!

  # If it is the case, the (same) thickness of the item's shape (e.g. a cotton T-shirt that's 2mm thick everywhere).
  uniform_thickness: numeric
}

# aggregated selection of "clothing_shell_maindata"
type clothing_shell_maindata_aggregate {
  aggregate: clothing_shell_maindata_aggregate_fields
  nodes: [clothing_shell_maindata!]!
}

# aggregate fields of "clothing_shell_maindata"
type clothing_shell_maindata_aggregate_fields {
  avg: clothing_shell_maindata_avg_fields
  count(columns: [clothing_shell_maindata_select_column!], distinct: Boolean): Int
  max: clothing_shell_maindata_max_fields
  min: clothing_shell_maindata_min_fields
  stddev: clothing_shell_maindata_stddev_fields
  stddev_pop: clothing_shell_maindata_stddev_pop_fields
  stddev_samp: clothing_shell_maindata_stddev_samp_fields
  sum: clothing_shell_maindata_sum_fields
  var_pop: clothing_shell_maindata_var_pop_fields
  var_samp: clothing_shell_maindata_var_samp_fields
  variance: clothing_shell_maindata_variance_fields
}

# order by aggregate values of table "clothing_shell_maindata"
input clothing_shell_maindata_aggregate_order_by {
  avg: clothing_shell_maindata_avg_order_by
  count: order_by
  max: clothing_shell_maindata_max_order_by
  min: clothing_shell_maindata_min_order_by
  stddev: clothing_shell_maindata_stddev_order_by
  stddev_pop: clothing_shell_maindata_stddev_pop_order_by
  stddev_samp: clothing_shell_maindata_stddev_samp_order_by
  sum: clothing_shell_maindata_sum_order_by
  var_pop: clothing_shell_maindata_var_pop_order_by
  var_samp: clothing_shell_maindata_var_samp_order_by
  variance: clothing_shell_maindata_variance_order_by
}

# input type for inserting array relation for remote table "clothing_shell_maindata"
input clothing_shell_maindata_arr_rel_insert_input {
  data: [clothing_shell_maindata_insert_input!]!
  on_conflict: clothing_shell_maindata_on_conflict
}

# aggregate avg on columns
type clothing_shell_maindata_avg_fields {
  default_fill_layer_id: Float
  default_interlining_layer_id: Float
  default_lining_layer_id: Float
  default_shell_layer_id: Float
  uniform_thickness: Float
}

# order by avg() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_avg_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# Boolean expression to filter rows from the table "clothing_shell_maindata". All fields are combined with a logical 'AND'.
input clothing_shell_maindata_bool_exp {
  _and: [clothing_shell_maindata_bool_exp]
  _not: clothing_shell_maindata_bool_exp
  _or: [clothing_shell_maindata_bool_exp]
  clothing_segment_data: clothing_segment_data_bool_exp
  clothing_segment_data_id: uuid_comparison_exp
  default_fill_layer: fabric_layers_bool_exp
  default_fill_layer_id: Int_comparison_exp
  default_interlining_layer: fabric_layers_bool_exp
  default_interlining_layer_id: Int_comparison_exp
  default_lining_layer: fabric_layers_bool_exp
  default_lining_layer_id: Int_comparison_exp
  default_shell_layer: fabric_layers_bool_exp
  default_shell_layer_id: Int_comparison_exp
  id: uuid_comparison_exp
  is_release: Boolean_comparison_exp
  item_type: item_types_enum_comparison_exp
  name: String_comparison_exp
  revision: clothing_shell_maindata_revisions_bool_exp
  revision_id: uuid_comparison_exp
  uniform_thickness: numeric_comparison_exp
}

# unique or primary key constraints on table "clothing_shell_maindata"
enum clothing_shell_maindata_constraint {
  # unique or primary key constraint
  clothing_shell_maindata_clothing_segment_data_id_key

  # unique or primary key constraint
  clothing_shell_maindata_pkey

  # unique or primary key constraint
  clothing_shell_maindata_revision_id_is_release_key
}

# input type for incrementing integer column in table "clothing_shell_maindata"
input clothing_shell_maindata_inc_input {
  default_fill_layer_id: Int
  default_interlining_layer_id: Int
  default_lining_layer_id: Int
  default_shell_layer_id: Int
  uniform_thickness: numeric
}

# input type for inserting data into table "clothing_shell_maindata"
input clothing_shell_maindata_insert_input {
  clothing_segment_data: clothing_segment_data_obj_rel_insert_input
  clothing_segment_data_id: uuid
  default_fill_layer: fabric_layers_obj_rel_insert_input
  default_fill_layer_id: Int
  default_interlining_layer: fabric_layers_obj_rel_insert_input
  default_interlining_layer_id: Int
  default_lining_layer: fabric_layers_obj_rel_insert_input
  default_lining_layer_id: Int
  default_shell_layer: fabric_layers_obj_rel_insert_input
  default_shell_layer_id: Int
  id: uuid
  is_release: Boolean
  item_type: item_types_enum
  name: String
  revision: clothing_shell_maindata_revisions_obj_rel_insert_input
  revision_id: uuid
  uniform_thickness: numeric
}

# aggregate max on columns
type clothing_shell_maindata_max_fields {
  clothing_segment_data_id: uuid
  default_fill_layer_id: Int
  default_interlining_layer_id: Int
  default_lining_layer_id: Int
  default_shell_layer_id: Int
  id: uuid
  name: String
  revision_id: uuid
  uniform_thickness: numeric
}

# order by max() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_max_order_by {
  clothing_segment_data_id: order_by
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  id: order_by
  name: order_by
  revision_id: order_by
  uniform_thickness: order_by
}

# aggregate min on columns
type clothing_shell_maindata_min_fields {
  clothing_segment_data_id: uuid
  default_fill_layer_id: Int
  default_interlining_layer_id: Int
  default_lining_layer_id: Int
  default_shell_layer_id: Int
  id: uuid
  name: String
  revision_id: uuid
  uniform_thickness: numeric
}

# order by min() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_min_order_by {
  clothing_segment_data_id: order_by
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  id: order_by
  name: order_by
  revision_id: order_by
  uniform_thickness: order_by
}

# response of any mutation on the table "clothing_shell_maindata"
type clothing_shell_maindata_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_shell_maindata!]!
}

# input type for inserting object relation for remote table "clothing_shell_maindata"
input clothing_shell_maindata_obj_rel_insert_input {
  data: clothing_shell_maindata_insert_input!
  on_conflict: clothing_shell_maindata_on_conflict
}

# on conflict condition type for table "clothing_shell_maindata"
input clothing_shell_maindata_on_conflict {
  constraint: clothing_shell_maindata_constraint!
  update_columns: [clothing_shell_maindata_update_column!]!
  where: clothing_shell_maindata_bool_exp
}

# ordering options when selecting data from "clothing_shell_maindata"
input clothing_shell_maindata_order_by {
  clothing_segment_data: clothing_segment_data_order_by
  clothing_segment_data_id: order_by
  default_fill_layer: fabric_layers_order_by
  default_fill_layer_id: order_by
  default_interlining_layer: fabric_layers_order_by
  default_interlining_layer_id: order_by
  default_lining_layer: fabric_layers_order_by
  default_lining_layer_id: order_by
  default_shell_layer: fabric_layers_order_by
  default_shell_layer_id: order_by
  id: order_by
  is_release: order_by
  item_type: order_by
  name: order_by
  revision: clothing_shell_maindata_revisions_order_by
  revision_id: order_by
  uniform_thickness: order_by
}

# primary key columns input for table: "clothing_shell_maindata"
input clothing_shell_maindata_pk_columns_input {
  id: uuid!
}

# Intended for the table "clothing_shell_maindata_revisions". Contains information
# about changes made, such as and edits, deletes, updates and promotions.
#
#
# columns and relationships of "clothing_shell_maindata_revision_changes"
#
type clothing_shell_maindata_revision_changes {
  action: data_actions_enum
  change_type: data_change_types_enum!

  # An object relationship
  clothing_shell_maindata_revision: clothing_shell_maindata_revisions!
  clothing_shell_maindata_revision_id: uuid!
  date: timestamptz!
  id: uuid!
  to_state: data_states_enum

  # An object relationship
  user: staff_users!
  user_id: Int!
}

# aggregated selection of "clothing_shell_maindata_revision_changes"
type clothing_shell_maindata_revision_changes_aggregate {
  aggregate: clothing_shell_maindata_revision_changes_aggregate_fields
  nodes: [clothing_shell_maindata_revision_changes!]!
}

# aggregate fields of "clothing_shell_maindata_revision_changes"
type clothing_shell_maindata_revision_changes_aggregate_fields {
  avg: clothing_shell_maindata_revision_changes_avg_fields
  count(columns: [clothing_shell_maindata_revision_changes_select_column!], distinct: Boolean): Int
  max: clothing_shell_maindata_revision_changes_max_fields
  min: clothing_shell_maindata_revision_changes_min_fields
  stddev: clothing_shell_maindata_revision_changes_stddev_fields
  stddev_pop: clothing_shell_maindata_revision_changes_stddev_pop_fields
  stddev_samp: clothing_shell_maindata_revision_changes_stddev_samp_fields
  sum: clothing_shell_maindata_revision_changes_sum_fields
  var_pop: clothing_shell_maindata_revision_changes_var_pop_fields
  var_samp: clothing_shell_maindata_revision_changes_var_samp_fields
  variance: clothing_shell_maindata_revision_changes_variance_fields
}

# order by aggregate values of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_aggregate_order_by {
  avg: clothing_shell_maindata_revision_changes_avg_order_by
  count: order_by
  max: clothing_shell_maindata_revision_changes_max_order_by
  min: clothing_shell_maindata_revision_changes_min_order_by
  stddev: clothing_shell_maindata_revision_changes_stddev_order_by
  stddev_pop: clothing_shell_maindata_revision_changes_stddev_pop_order_by
  stddev_samp: clothing_shell_maindata_revision_changes_stddev_samp_order_by
  sum: clothing_shell_maindata_revision_changes_sum_order_by
  var_pop: clothing_shell_maindata_revision_changes_var_pop_order_by
  var_samp: clothing_shell_maindata_revision_changes_var_samp_order_by
  variance: clothing_shell_maindata_revision_changes_variance_order_by
}

# input type for inserting array relation for remote table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_arr_rel_insert_input {
  data: [clothing_shell_maindata_revision_changes_insert_input!]!
  on_conflict: clothing_shell_maindata_revision_changes_on_conflict
}

# aggregate avg on columns
type clothing_shell_maindata_revision_changes_avg_fields {
  user_id: Float
}

# order by avg() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_avg_order_by {
  user_id: order_by
}

# Boolean expression to filter rows from the table
# "clothing_shell_maindata_revision_changes". All fields are combined with a logical 'AND'.
input clothing_shell_maindata_revision_changes_bool_exp {
  _and: [clothing_shell_maindata_revision_changes_bool_exp]
  _not: clothing_shell_maindata_revision_changes_bool_exp
  _or: [clothing_shell_maindata_revision_changes_bool_exp]
  action: data_actions_enum_comparison_exp
  change_type: data_change_types_enum_comparison_exp
  clothing_shell_maindata_revision: clothing_shell_maindata_revisions_bool_exp
  clothing_shell_maindata_revision_id: uuid_comparison_exp
  date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  to_state: data_states_enum_comparison_exp
  user: staff_users_bool_exp
  user_id: Int_comparison_exp
}

# unique or primary key constraints on table "clothing_shell_maindata_revision_changes"
enum clothing_shell_maindata_revision_changes_constraint {
  # unique or primary key constraint
  clothing_shell_maindata_revision_changes_pkey
}

# input type for incrementing integer column in table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_inc_input {
  user_id: Int
}

# input type for inserting data into table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_insert_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  clothing_shell_maindata_revision: clothing_shell_maindata_revisions_obj_rel_insert_input
  clothing_shell_maindata_revision_id: uuid
  date: timestamptz
  id: uuid
  to_state: data_states_enum
  user: staff_users_obj_rel_insert_input
  user_id: Int
}

# aggregate max on columns
type clothing_shell_maindata_revision_changes_max_fields {
  clothing_shell_maindata_revision_id: uuid
  date: timestamptz
  id: uuid
  user_id: Int
}

# order by max() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_max_order_by {
  clothing_shell_maindata_revision_id: order_by
  date: order_by
  id: order_by
  user_id: order_by
}

# aggregate min on columns
type clothing_shell_maindata_revision_changes_min_fields {
  clothing_shell_maindata_revision_id: uuid
  date: timestamptz
  id: uuid
  user_id: Int
}

# order by min() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_min_order_by {
  clothing_shell_maindata_revision_id: order_by
  date: order_by
  id: order_by
  user_id: order_by
}

# response of any mutation on the table "clothing_shell_maindata_revision_changes"
type clothing_shell_maindata_revision_changes_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_shell_maindata_revision_changes!]!
}

# input type for inserting object relation for remote table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_obj_rel_insert_input {
  data: clothing_shell_maindata_revision_changes_insert_input!
  on_conflict: clothing_shell_maindata_revision_changes_on_conflict
}

# on conflict condition type for table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_on_conflict {
  constraint: clothing_shell_maindata_revision_changes_constraint!
  update_columns: [clothing_shell_maindata_revision_changes_update_column!]!
  where: clothing_shell_maindata_revision_changes_bool_exp
}

# ordering options when selecting data from "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_order_by {
  action: order_by
  change_type: order_by
  clothing_shell_maindata_revision: clothing_shell_maindata_revisions_order_by
  clothing_shell_maindata_revision_id: order_by
  date: order_by
  id: order_by
  to_state: order_by
  user: staff_users_order_by
  user_id: order_by
}

# primary key columns input for table: "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_pk_columns_input {
  id: uuid!
}

# select columns of table "clothing_shell_maindata_revision_changes"
enum clothing_shell_maindata_revision_changes_select_column {
  # column name
  action

  # column name
  change_type

  # column name
  clothing_shell_maindata_revision_id

  # column name
  date

  # column name
  id

  # column name
  to_state

  # column name
  user_id
}

# input type for updating data in table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_set_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  clothing_shell_maindata_revision_id: uuid
  date: timestamptz
  id: uuid
  to_state: data_states_enum
  user_id: Int
}

# aggregate stddev on columns
type clothing_shell_maindata_revision_changes_stddev_fields {
  user_id: Float
}

# order by stddev() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_stddev_order_by {
  user_id: order_by
}

# aggregate stddev_pop on columns
type clothing_shell_maindata_revision_changes_stddev_pop_fields {
  user_id: Float
}

# order by stddev_pop() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_stddev_pop_order_by {
  user_id: order_by
}

# aggregate stddev_samp on columns
type clothing_shell_maindata_revision_changes_stddev_samp_fields {
  user_id: Float
}

# order by stddev_samp() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_stddev_samp_order_by {
  user_id: order_by
}

# aggregate sum on columns
type clothing_shell_maindata_revision_changes_sum_fields {
  user_id: Int
}

# order by sum() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_sum_order_by {
  user_id: order_by
}

# update columns of table "clothing_shell_maindata_revision_changes"
enum clothing_shell_maindata_revision_changes_update_column {
  # column name
  action

  # column name
  change_type

  # column name
  clothing_shell_maindata_revision_id

  # column name
  date

  # column name
  id

  # column name
  to_state

  # column name
  user_id
}

# aggregate var_pop on columns
type clothing_shell_maindata_revision_changes_var_pop_fields {
  user_id: Float
}

# order by var_pop() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_var_pop_order_by {
  user_id: order_by
}

# aggregate var_samp on columns
type clothing_shell_maindata_revision_changes_var_samp_fields {
  user_id: Float
}

# order by var_samp() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_var_samp_order_by {
  user_id: order_by
}

# aggregate variance on columns
type clothing_shell_maindata_revision_changes_variance_fields {
  user_id: Float
}

# order by variance() on columns of table "clothing_shell_maindata_revision_changes"
input clothing_shell_maindata_revision_changes_variance_order_by {
  user_id: order_by
}

# A main data revision for clothing shells, containing vital control information for it's draft and release versions.
#
#
# columns and relationships of "clothing_shell_maindata_revisions"
#
type clothing_shell_maindata_revisions {
  # An object relationship
  clothing_shell: clothing_shells!

  # The associated id of the clothing shell this maindata revision is intended for.
  clothing_shell_id: Int!

  # An array relationship
  clothing_shell_maindata(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_bool_exp
  ): [clothing_shell_maindata!]!

  # An aggregated array relationship
  clothing_shell_maindata_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_bool_exp
  ): clothing_shell_maindata_aggregate!
  id: uuid!

  # The revision or version number of this maindata group (of draft and release).
  revision: Int!

  # The data state of this maindata revision (e.g. Development, Review, Production and Retired).
  state: data_states_enum!
}

# aggregated selection of "clothing_shell_maindata_revisions"
type clothing_shell_maindata_revisions_aggregate {
  aggregate: clothing_shell_maindata_revisions_aggregate_fields
  nodes: [clothing_shell_maindata_revisions!]!
}

# aggregate fields of "clothing_shell_maindata_revisions"
type clothing_shell_maindata_revisions_aggregate_fields {
  avg: clothing_shell_maindata_revisions_avg_fields
  count(columns: [clothing_shell_maindata_revisions_select_column!], distinct: Boolean): Int
  max: clothing_shell_maindata_revisions_max_fields
  min: clothing_shell_maindata_revisions_min_fields
  stddev: clothing_shell_maindata_revisions_stddev_fields
  stddev_pop: clothing_shell_maindata_revisions_stddev_pop_fields
  stddev_samp: clothing_shell_maindata_revisions_stddev_samp_fields
  sum: clothing_shell_maindata_revisions_sum_fields
  var_pop: clothing_shell_maindata_revisions_var_pop_fields
  var_samp: clothing_shell_maindata_revisions_var_samp_fields
  variance: clothing_shell_maindata_revisions_variance_fields
}

# order by aggregate values of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_aggregate_order_by {
  avg: clothing_shell_maindata_revisions_avg_order_by
  count: order_by
  max: clothing_shell_maindata_revisions_max_order_by
  min: clothing_shell_maindata_revisions_min_order_by
  stddev: clothing_shell_maindata_revisions_stddev_order_by
  stddev_pop: clothing_shell_maindata_revisions_stddev_pop_order_by
  stddev_samp: clothing_shell_maindata_revisions_stddev_samp_order_by
  sum: clothing_shell_maindata_revisions_sum_order_by
  var_pop: clothing_shell_maindata_revisions_var_pop_order_by
  var_samp: clothing_shell_maindata_revisions_var_samp_order_by
  variance: clothing_shell_maindata_revisions_variance_order_by
}

# input type for inserting array relation for remote table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_arr_rel_insert_input {
  data: [clothing_shell_maindata_revisions_insert_input!]!
  on_conflict: clothing_shell_maindata_revisions_on_conflict
}

# aggregate avg on columns
type clothing_shell_maindata_revisions_avg_fields {
  clothing_shell_id: Float
  revision: Float
}

# order by avg() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_avg_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# Boolean expression to filter rows from the table
# "clothing_shell_maindata_revisions". All fields are combined with a logical 'AND'.
input clothing_shell_maindata_revisions_bool_exp {
  _and: [clothing_shell_maindata_revisions_bool_exp]
  _not: clothing_shell_maindata_revisions_bool_exp
  _or: [clothing_shell_maindata_revisions_bool_exp]
  clothing_shell: clothing_shells_bool_exp
  clothing_shell_id: Int_comparison_exp
  clothing_shell_maindata: clothing_shell_maindata_bool_exp
  id: uuid_comparison_exp
  revision: Int_comparison_exp
  state: data_states_enum_comparison_exp
}

# unique or primary key constraints on table "clothing_shell_maindata_revisions"
enum clothing_shell_maindata_revisions_constraint {
  # unique or primary key constraint
  clothing_shell_maindata_revision_clothing_shell_id_revision_key

  # unique or primary key constraint
  clothing_shell_maindata_revisions_pkey
}

# input type for incrementing integer column in table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_inc_input {
  clothing_shell_id: Int
  revision: Int
}

# input type for inserting data into table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_insert_input {
  clothing_shell: clothing_shells_obj_rel_insert_input
  clothing_shell_id: Int
  clothing_shell_maindata: clothing_shell_maindata_arr_rel_insert_input
  id: uuid
  revision: Int
  state: data_states_enum
}

# aggregate max on columns
type clothing_shell_maindata_revisions_max_fields {
  clothing_shell_id: Int
  id: uuid
  revision: Int
}

# order by max() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_max_order_by {
  clothing_shell_id: order_by
  id: order_by
  revision: order_by
}

# aggregate min on columns
type clothing_shell_maindata_revisions_min_fields {
  clothing_shell_id: Int
  id: uuid
  revision: Int
}

# order by min() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_min_order_by {
  clothing_shell_id: order_by
  id: order_by
  revision: order_by
}

# response of any mutation on the table "clothing_shell_maindata_revisions"
type clothing_shell_maindata_revisions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_shell_maindata_revisions!]!
}

# input type for inserting object relation for remote table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_obj_rel_insert_input {
  data: clothing_shell_maindata_revisions_insert_input!
  on_conflict: clothing_shell_maindata_revisions_on_conflict
}

# on conflict condition type for table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_on_conflict {
  constraint: clothing_shell_maindata_revisions_constraint!
  update_columns: [clothing_shell_maindata_revisions_update_column!]!
  where: clothing_shell_maindata_revisions_bool_exp
}

# ordering options when selecting data from "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_order_by {
  clothing_shell: clothing_shells_order_by
  clothing_shell_id: order_by
  clothing_shell_maindata_aggregate: clothing_shell_maindata_aggregate_order_by
  id: order_by
  revision: order_by
  state: order_by
}

# primary key columns input for table: "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_pk_columns_input {
  id: uuid!
}

# select columns of table "clothing_shell_maindata_revisions"
enum clothing_shell_maindata_revisions_select_column {
  # column name
  clothing_shell_id

  # column name
  id

  # column name
  revision

  # column name
  state
}

# input type for updating data in table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_set_input {
  clothing_shell_id: Int
  id: uuid
  revision: Int
  state: data_states_enum
}

# aggregate stddev on columns
type clothing_shell_maindata_revisions_stddev_fields {
  clothing_shell_id: Float
  revision: Float
}

# order by stddev() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_stddev_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# aggregate stddev_pop on columns
type clothing_shell_maindata_revisions_stddev_pop_fields {
  clothing_shell_id: Float
  revision: Float
}

# order by stddev_pop() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_stddev_pop_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# aggregate stddev_samp on columns
type clothing_shell_maindata_revisions_stddev_samp_fields {
  clothing_shell_id: Float
  revision: Float
}

# order by stddev_samp() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_stddev_samp_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# aggregate sum on columns
type clothing_shell_maindata_revisions_sum_fields {
  clothing_shell_id: Int
  revision: Int
}

# order by sum() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_sum_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# update columns of table "clothing_shell_maindata_revisions"
enum clothing_shell_maindata_revisions_update_column {
  # column name
  clothing_shell_id

  # column name
  id

  # column name
  revision

  # column name
  state
}

# aggregate var_pop on columns
type clothing_shell_maindata_revisions_var_pop_fields {
  clothing_shell_id: Float
  revision: Float
}

# order by var_pop() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_var_pop_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# aggregate var_samp on columns
type clothing_shell_maindata_revisions_var_samp_fields {
  clothing_shell_id: Float
  revision: Float
}

# order by var_samp() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_var_samp_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# aggregate variance on columns
type clothing_shell_maindata_revisions_variance_fields {
  clothing_shell_id: Float
  revision: Float
}

# order by variance() on columns of table "clothing_shell_maindata_revisions"
input clothing_shell_maindata_revisions_variance_order_by {
  clothing_shell_id: order_by
  revision: order_by
}

# select columns of table "clothing_shell_maindata"
enum clothing_shell_maindata_select_column {
  # column name
  clothing_segment_data_id

  # column name
  default_fill_layer_id

  # column name
  default_interlining_layer_id

  # column name
  default_lining_layer_id

  # column name
  default_shell_layer_id

  # column name
  id

  # column name
  is_release

  # column name
  item_type

  # column name
  name

  # column name
  revision_id

  # column name
  uniform_thickness
}

# input type for updating data in table "clothing_shell_maindata"
input clothing_shell_maindata_set_input {
  clothing_segment_data_id: uuid
  default_fill_layer_id: Int
  default_interlining_layer_id: Int
  default_lining_layer_id: Int
  default_shell_layer_id: Int
  id: uuid
  is_release: Boolean
  item_type: item_types_enum
  name: String
  revision_id: uuid
  uniform_thickness: numeric
}

# aggregate stddev on columns
type clothing_shell_maindata_stddev_fields {
  default_fill_layer_id: Float
  default_interlining_layer_id: Float
  default_lining_layer_id: Float
  default_shell_layer_id: Float
  uniform_thickness: Float
}

# order by stddev() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_stddev_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# aggregate stddev_pop on columns
type clothing_shell_maindata_stddev_pop_fields {
  default_fill_layer_id: Float
  default_interlining_layer_id: Float
  default_lining_layer_id: Float
  default_shell_layer_id: Float
  uniform_thickness: Float
}

# order by stddev_pop() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_stddev_pop_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# aggregate stddev_samp on columns
type clothing_shell_maindata_stddev_samp_fields {
  default_fill_layer_id: Float
  default_interlining_layer_id: Float
  default_lining_layer_id: Float
  default_shell_layer_id: Float
  uniform_thickness: Float
}

# order by stddev_samp() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_stddev_samp_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# aggregate sum on columns
type clothing_shell_maindata_sum_fields {
  default_fill_layer_id: Int
  default_interlining_layer_id: Int
  default_lining_layer_id: Int
  default_shell_layer_id: Int
  uniform_thickness: numeric
}

# order by sum() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_sum_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# update columns of table "clothing_shell_maindata"
enum clothing_shell_maindata_update_column {
  # column name
  clothing_segment_data_id

  # column name
  default_fill_layer_id

  # column name
  default_interlining_layer_id

  # column name
  default_lining_layer_id

  # column name
  default_shell_layer_id

  # column name
  id

  # column name
  is_release

  # column name
  item_type

  # column name
  name

  # column name
  revision_id

  # column name
  uniform_thickness
}

# aggregate var_pop on columns
type clothing_shell_maindata_var_pop_fields {
  default_fill_layer_id: Float
  default_interlining_layer_id: Float
  default_lining_layer_id: Float
  default_shell_layer_id: Float
  uniform_thickness: Float
}

# order by var_pop() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_var_pop_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# aggregate var_samp on columns
type clothing_shell_maindata_var_samp_fields {
  default_fill_layer_id: Float
  default_interlining_layer_id: Float
  default_lining_layer_id: Float
  default_shell_layer_id: Float
  uniform_thickness: Float
}

# order by var_samp() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_var_samp_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# aggregate variance on columns
type clothing_shell_maindata_variance_fields {
  default_fill_layer_id: Float
  default_interlining_layer_id: Float
  default_lining_layer_id: Float
  default_shell_layer_id: Float
  uniform_thickness: Float
}

# order by variance() on columns of table "clothing_shell_maindata"
input clothing_shell_maindata_variance_order_by {
  default_fill_layer_id: order_by
  default_interlining_layer_id: order_by
  default_lining_layer_id: order_by
  default_shell_layer_id: order_by
  uniform_thickness: order_by
}

# A description of the physical properties (e.g. shape, colour and materials) of a clothing item
#
#
# columns and relationships of "clothing_shells"
#
type clothing_shells {
  # An array relationship
  clothing_shell_and_body_segment_masks(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): [clothing_shell_and_body_segment_mask!]!

  # An aggregated array relationship
  clothing_shell_and_body_segment_masks_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): clothing_shell_and_body_segment_mask_aggregate!

  # An array relationship
  clothing_shell_and_clothing_features(
    # distinct select on columns
    distinct_on: [clothing_shell_and_clothing_feature_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_clothing_feature_order_by!]

    # filter the rows returned
    where: clothing_shell_and_clothing_feature_bool_exp
  ): [clothing_shell_and_clothing_feature!]!

  # An aggregated array relationship
  clothing_shell_and_clothing_features_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_and_clothing_feature_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_clothing_feature_order_by!]

    # filter the rows returned
    where: clothing_shell_and_clothing_feature_bool_exp
  ): clothing_shell_and_clothing_feature_aggregate!

  # An array relationship
  clothing_shell_maindata_revisions(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revisions_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revisions_bool_exp
  ): [clothing_shell_maindata_revisions!]!

  # An aggregated array relationship
  clothing_shell_maindata_revisions_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revisions_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revisions_bool_exp
  ): clothing_shell_maindata_revisions_aggregate!

  # An object relationship
  counts: clothing_shell_counts
  created_at: timestamptz!
  id: Int!

  # An array relationship
  item_maindata(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): [item_maindata!]!

  # An aggregated array relationship
  item_maindata_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): item_maindata_aggregate!
  updated_at: timestamptz!
}

# aggregated selection of "clothing_shells"
type clothing_shells_aggregate {
  aggregate: clothing_shells_aggregate_fields
  nodes: [clothing_shells!]!
}

# aggregate fields of "clothing_shells"
type clothing_shells_aggregate_fields {
  avg: clothing_shells_avg_fields
  count(columns: [clothing_shells_select_column!], distinct: Boolean): Int
  max: clothing_shells_max_fields
  min: clothing_shells_min_fields
  stddev: clothing_shells_stddev_fields
  stddev_pop: clothing_shells_stddev_pop_fields
  stddev_samp: clothing_shells_stddev_samp_fields
  sum: clothing_shells_sum_fields
  var_pop: clothing_shells_var_pop_fields
  var_samp: clothing_shells_var_samp_fields
  variance: clothing_shells_variance_fields
}

# order by aggregate values of table "clothing_shells"
input clothing_shells_aggregate_order_by {
  avg: clothing_shells_avg_order_by
  count: order_by
  max: clothing_shells_max_order_by
  min: clothing_shells_min_order_by
  stddev: clothing_shells_stddev_order_by
  stddev_pop: clothing_shells_stddev_pop_order_by
  stddev_samp: clothing_shells_stddev_samp_order_by
  sum: clothing_shells_sum_order_by
  var_pop: clothing_shells_var_pop_order_by
  var_samp: clothing_shells_var_samp_order_by
  variance: clothing_shells_variance_order_by
}

# input type for inserting array relation for remote table "clothing_shells"
input clothing_shells_arr_rel_insert_input {
  data: [clothing_shells_insert_input!]!
  on_conflict: clothing_shells_on_conflict
}

# aggregate avg on columns
type clothing_shells_avg_fields {
  id: Float
}

# order by avg() on columns of table "clothing_shells"
input clothing_shells_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "clothing_shells". All fields are combined with a logical 'AND'.
input clothing_shells_bool_exp {
  _and: [clothing_shells_bool_exp]
  _not: clothing_shells_bool_exp
  _or: [clothing_shells_bool_exp]
  clothing_shell_and_body_segment_masks: clothing_shell_and_body_segment_mask_bool_exp
  clothing_shell_and_clothing_features: clothing_shell_and_clothing_feature_bool_exp
  clothing_shell_maindata_revisions: clothing_shell_maindata_revisions_bool_exp
  counts: clothing_shell_counts_bool_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  item_maindata: item_maindata_bool_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "clothing_shells"
enum clothing_shells_constraint {
  # unique or primary key constraint
  clothing_shells_pkey
}

# input type for incrementing integer column in table "clothing_shells"
input clothing_shells_inc_input {
  id: Int
}

# input type for inserting data into table "clothing_shells"
input clothing_shells_insert_input {
  clothing_shell_and_body_segment_masks: clothing_shell_and_body_segment_mask_arr_rel_insert_input
  clothing_shell_and_clothing_features: clothing_shell_and_clothing_feature_arr_rel_insert_input
  clothing_shell_maindata_revisions: clothing_shell_maindata_revisions_arr_rel_insert_input
  counts: clothing_shell_counts_obj_rel_insert_input
  created_at: timestamptz
  id: Int
  item_maindata: item_maindata_arr_rel_insert_input
  updated_at: timestamptz
}

# aggregate max on columns
type clothing_shells_max_fields {
  created_at: timestamptz
  id: Int
  updated_at: timestamptz
}

# order by max() on columns of table "clothing_shells"
input clothing_shells_max_order_by {
  created_at: order_by
  id: order_by
  updated_at: order_by
}

# aggregate min on columns
type clothing_shells_min_fields {
  created_at: timestamptz
  id: Int
  updated_at: timestamptz
}

# order by min() on columns of table "clothing_shells"
input clothing_shells_min_order_by {
  created_at: order_by
  id: order_by
  updated_at: order_by
}

# response of any mutation on the table "clothing_shells"
type clothing_shells_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [clothing_shells!]!
}

# input type for inserting object relation for remote table "clothing_shells"
input clothing_shells_obj_rel_insert_input {
  data: clothing_shells_insert_input!
  on_conflict: clothing_shells_on_conflict
}

# on conflict condition type for table "clothing_shells"
input clothing_shells_on_conflict {
  constraint: clothing_shells_constraint!
  update_columns: [clothing_shells_update_column!]!
  where: clothing_shells_bool_exp
}

# ordering options when selecting data from "clothing_shells"
input clothing_shells_order_by {
  clothing_shell_and_body_segment_masks_aggregate: clothing_shell_and_body_segment_mask_aggregate_order_by
  clothing_shell_and_clothing_features_aggregate: clothing_shell_and_clothing_feature_aggregate_order_by
  clothing_shell_maindata_revisions_aggregate: clothing_shell_maindata_revisions_aggregate_order_by
  counts: clothing_shell_counts_order_by
  created_at: order_by
  id: order_by
  item_maindata_aggregate: item_maindata_aggregate_order_by
  updated_at: order_by
}

# primary key columns input for table: "clothing_shells"
input clothing_shells_pk_columns_input {
  id: Int!
}

# select columns of table "clothing_shells"
enum clothing_shells_select_column {
  # column name
  created_at

  # column name
  id

  # column name
  updated_at
}

# input type for updating data in table "clothing_shells"
input clothing_shells_set_input {
  created_at: timestamptz
  id: Int
  updated_at: timestamptz
}

# aggregate stddev on columns
type clothing_shells_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "clothing_shells"
input clothing_shells_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type clothing_shells_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "clothing_shells"
input clothing_shells_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type clothing_shells_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "clothing_shells"
input clothing_shells_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type clothing_shells_sum_fields {
  id: Int
}

# order by sum() on columns of table "clothing_shells"
input clothing_shells_sum_order_by {
  id: order_by
}

# update columns of table "clothing_shells"
enum clothing_shells_update_column {
  # column name
  created_at

  # column name
  id

  # column name
  updated_at
}

# aggregate var_pop on columns
type clothing_shells_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "clothing_shells"
input clothing_shells_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type clothing_shells_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "clothing_shells"
input clothing_shells_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type clothing_shells_variance_fields {
  id: Float
}

# order by variance() on columns of table "clothing_shells"
input clothing_shells_variance_order_by {
  id: order_by
}

# A many-to-many relationship table representing a company's collaboration with
# another brand. Companies here are not the primary brand, i.e. the one who makes
# or sells the brand primarily. They take a secondary role here.
#
#
# columns and relationships of "collab_company_and_collection"
#
type collab_company_and_collection {
  # An object relationship
  collection: collections!
  collection_id: Int!

  # An object relationship
  company: companies!
  company_id: Int!
}

# aggregated selection of "collab_company_and_collection"
type collab_company_and_collection_aggregate {
  aggregate: collab_company_and_collection_aggregate_fields
  nodes: [collab_company_and_collection!]!
}

# aggregate fields of "collab_company_and_collection"
type collab_company_and_collection_aggregate_fields {
  avg: collab_company_and_collection_avg_fields
  count(columns: [collab_company_and_collection_select_column!], distinct: Boolean): Int
  max: collab_company_and_collection_max_fields
  min: collab_company_and_collection_min_fields
  stddev: collab_company_and_collection_stddev_fields
  stddev_pop: collab_company_and_collection_stddev_pop_fields
  stddev_samp: collab_company_and_collection_stddev_samp_fields
  sum: collab_company_and_collection_sum_fields
  var_pop: collab_company_and_collection_var_pop_fields
  var_samp: collab_company_and_collection_var_samp_fields
  variance: collab_company_and_collection_variance_fields
}

# order by aggregate values of table "collab_company_and_collection"
input collab_company_and_collection_aggregate_order_by {
  avg: collab_company_and_collection_avg_order_by
  count: order_by
  max: collab_company_and_collection_max_order_by
  min: collab_company_and_collection_min_order_by
  stddev: collab_company_and_collection_stddev_order_by
  stddev_pop: collab_company_and_collection_stddev_pop_order_by
  stddev_samp: collab_company_and_collection_stddev_samp_order_by
  sum: collab_company_and_collection_sum_order_by
  var_pop: collab_company_and_collection_var_pop_order_by
  var_samp: collab_company_and_collection_var_samp_order_by
  variance: collab_company_and_collection_variance_order_by
}

# input type for inserting array relation for remote table "collab_company_and_collection"
input collab_company_and_collection_arr_rel_insert_input {
  data: [collab_company_and_collection_insert_input!]!
  on_conflict: collab_company_and_collection_on_conflict
}

# aggregate avg on columns
type collab_company_and_collection_avg_fields {
  collection_id: Float
  company_id: Float
}

# order by avg() on columns of table "collab_company_and_collection"
input collab_company_and_collection_avg_order_by {
  collection_id: order_by
  company_id: order_by
}

# Boolean expression to filter rows from the table
# "collab_company_and_collection". All fields are combined with a logical 'AND'.
input collab_company_and_collection_bool_exp {
  _and: [collab_company_and_collection_bool_exp]
  _not: collab_company_and_collection_bool_exp
  _or: [collab_company_and_collection_bool_exp]
  collection: collections_bool_exp
  collection_id: Int_comparison_exp
  company: companies_bool_exp
  company_id: Int_comparison_exp
}

# unique or primary key constraints on table "collab_company_and_collection"
enum collab_company_and_collection_constraint {
  # unique or primary key constraint
  collab_company_and_collection_pkey
}

# input type for incrementing integer column in table "collab_company_and_collection"
input collab_company_and_collection_inc_input {
  collection_id: Int
  company_id: Int
}

# input type for inserting data into table "collab_company_and_collection"
input collab_company_and_collection_insert_input {
  collection: collections_obj_rel_insert_input
  collection_id: Int
  company: companies_obj_rel_insert_input
  company_id: Int
}

# aggregate max on columns
type collab_company_and_collection_max_fields {
  collection_id: Int
  company_id: Int
}

# order by max() on columns of table "collab_company_and_collection"
input collab_company_and_collection_max_order_by {
  collection_id: order_by
  company_id: order_by
}

# aggregate min on columns
type collab_company_and_collection_min_fields {
  collection_id: Int
  company_id: Int
}

# order by min() on columns of table "collab_company_and_collection"
input collab_company_and_collection_min_order_by {
  collection_id: order_by
  company_id: order_by
}

# response of any mutation on the table "collab_company_and_collection"
type collab_company_and_collection_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [collab_company_and_collection!]!
}

# input type for inserting object relation for remote table "collab_company_and_collection"
input collab_company_and_collection_obj_rel_insert_input {
  data: collab_company_and_collection_insert_input!
  on_conflict: collab_company_and_collection_on_conflict
}

# on conflict condition type for table "collab_company_and_collection"
input collab_company_and_collection_on_conflict {
  constraint: collab_company_and_collection_constraint!
  update_columns: [collab_company_and_collection_update_column!]!
  where: collab_company_and_collection_bool_exp
}

# ordering options when selecting data from "collab_company_and_collection"
input collab_company_and_collection_order_by {
  collection: collections_order_by
  collection_id: order_by
  company: companies_order_by
  company_id: order_by
}

# primary key columns input for table: "collab_company_and_collection"
input collab_company_and_collection_pk_columns_input {
  collection_id: Int!
  company_id: Int!
}

# select columns of table "collab_company_and_collection"
enum collab_company_and_collection_select_column {
  # column name
  collection_id

  # column name
  company_id
}

# input type for updating data in table "collab_company_and_collection"
input collab_company_and_collection_set_input {
  collection_id: Int
  company_id: Int
}

# aggregate stddev on columns
type collab_company_and_collection_stddev_fields {
  collection_id: Float
  company_id: Float
}

# order by stddev() on columns of table "collab_company_and_collection"
input collab_company_and_collection_stddev_order_by {
  collection_id: order_by
  company_id: order_by
}

# aggregate stddev_pop on columns
type collab_company_and_collection_stddev_pop_fields {
  collection_id: Float
  company_id: Float
}

# order by stddev_pop() on columns of table "collab_company_and_collection"
input collab_company_and_collection_stddev_pop_order_by {
  collection_id: order_by
  company_id: order_by
}

# aggregate stddev_samp on columns
type collab_company_and_collection_stddev_samp_fields {
  collection_id: Float
  company_id: Float
}

# order by stddev_samp() on columns of table "collab_company_and_collection"
input collab_company_and_collection_stddev_samp_order_by {
  collection_id: order_by
  company_id: order_by
}

# aggregate sum on columns
type collab_company_and_collection_sum_fields {
  collection_id: Int
  company_id: Int
}

# order by sum() on columns of table "collab_company_and_collection"
input collab_company_and_collection_sum_order_by {
  collection_id: order_by
  company_id: order_by
}

# update columns of table "collab_company_and_collection"
enum collab_company_and_collection_update_column {
  # column name
  collection_id

  # column name
  company_id
}

# aggregate var_pop on columns
type collab_company_and_collection_var_pop_fields {
  collection_id: Float
  company_id: Float
}

# order by var_pop() on columns of table "collab_company_and_collection"
input collab_company_and_collection_var_pop_order_by {
  collection_id: order_by
  company_id: order_by
}

# aggregate var_samp on columns
type collab_company_and_collection_var_samp_fields {
  collection_id: Float
  company_id: Float
}

# order by var_samp() on columns of table "collab_company_and_collection"
input collab_company_and_collection_var_samp_order_by {
  collection_id: order_by
  company_id: order_by
}

# aggregate variance on columns
type collab_company_and_collection_variance_fields {
  collection_id: Float
  company_id: Float
}

# order by variance() on columns of table "collab_company_and_collection"
input collab_company_and_collection_variance_order_by {
  collection_id: order_by
  company_id: order_by
}

# columns and relationships of "collections"
type collections {
  brand_id: Int

  # An array relationship
  collab_company_and_collections(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): [collab_company_and_collection!]!

  # An aggregated array relationship
  collab_company_and_collections_aggregate(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): collab_company_and_collection_aggregate!

  # An object relationship
  company: companies
  created_at: timestamptz
  date_finished: date
  date_started: date
  for_gender: genders_enum!

  # An object relationship
  gender: genders!
  id: Int!
  name: String!
  updated_at: timestamptz
  website_url: String
}

# aggregated selection of "collections"
type collections_aggregate {
  aggregate: collections_aggregate_fields
  nodes: [collections!]!
}

# aggregate fields of "collections"
type collections_aggregate_fields {
  avg: collections_avg_fields
  count(columns: [collections_select_column!], distinct: Boolean): Int
  max: collections_max_fields
  min: collections_min_fields
  stddev: collections_stddev_fields
  stddev_pop: collections_stddev_pop_fields
  stddev_samp: collections_stddev_samp_fields
  sum: collections_sum_fields
  var_pop: collections_var_pop_fields
  var_samp: collections_var_samp_fields
  variance: collections_variance_fields
}

# order by aggregate values of table "collections"
input collections_aggregate_order_by {
  avg: collections_avg_order_by
  count: order_by
  max: collections_max_order_by
  min: collections_min_order_by
  stddev: collections_stddev_order_by
  stddev_pop: collections_stddev_pop_order_by
  stddev_samp: collections_stddev_samp_order_by
  sum: collections_sum_order_by
  var_pop: collections_var_pop_order_by
  var_samp: collections_var_samp_order_by
  variance: collections_variance_order_by
}

# input type for inserting array relation for remote table "collections"
input collections_arr_rel_insert_input {
  data: [collections_insert_input!]!
  on_conflict: collections_on_conflict
}

# aggregate avg on columns
type collections_avg_fields {
  brand_id: Float
  id: Float
}

# order by avg() on columns of table "collections"
input collections_avg_order_by {
  brand_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "collections". All fields are combined with a logical 'AND'.
input collections_bool_exp {
  _and: [collections_bool_exp]
  _not: collections_bool_exp
  _or: [collections_bool_exp]
  brand_id: Int_comparison_exp
  collab_company_and_collections: collab_company_and_collection_bool_exp
  company: companies_bool_exp
  created_at: timestamptz_comparison_exp
  date_finished: date_comparison_exp
  date_started: date_comparison_exp
  for_gender: genders_enum_comparison_exp
  gender: genders_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  website_url: String_comparison_exp
}

# unique or primary key constraints on table "collections"
enum collections_constraint {
  # unique or primary key constraint
  collections_pkey
}

# input type for incrementing integer column in table "collections"
input collections_inc_input {
  brand_id: Int
  id: Int
}

# input type for inserting data into table "collections"
input collections_insert_input {
  brand_id: Int
  collab_company_and_collections: collab_company_and_collection_arr_rel_insert_input
  company: companies_obj_rel_insert_input
  created_at: timestamptz
  date_finished: date
  date_started: date
  for_gender: genders_enum
  gender: genders_obj_rel_insert_input
  id: Int
  name: String
  updated_at: timestamptz
  website_url: String
}

# aggregate max on columns
type collections_max_fields {
  brand_id: Int
  created_at: timestamptz
  date_finished: date
  date_started: date
  id: Int
  name: String
  updated_at: timestamptz
  website_url: String
}

# order by max() on columns of table "collections"
input collections_max_order_by {
  brand_id: order_by
  created_at: order_by
  date_finished: order_by
  date_started: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  website_url: order_by
}

# aggregate min on columns
type collections_min_fields {
  brand_id: Int
  created_at: timestamptz
  date_finished: date
  date_started: date
  id: Int
  name: String
  updated_at: timestamptz
  website_url: String
}

# order by min() on columns of table "collections"
input collections_min_order_by {
  brand_id: order_by
  created_at: order_by
  date_finished: order_by
  date_started: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  website_url: order_by
}

# response of any mutation on the table "collections"
type collections_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [collections!]!
}

# input type for inserting object relation for remote table "collections"
input collections_obj_rel_insert_input {
  data: collections_insert_input!
  on_conflict: collections_on_conflict
}

# on conflict condition type for table "collections"
input collections_on_conflict {
  constraint: collections_constraint!
  update_columns: [collections_update_column!]!
  where: collections_bool_exp
}

# ordering options when selecting data from "collections"
input collections_order_by {
  brand_id: order_by
  collab_company_and_collections_aggregate: collab_company_and_collection_aggregate_order_by
  company: companies_order_by
  created_at: order_by
  date_finished: order_by
  date_started: order_by
  for_gender: order_by
  gender: genders_order_by
  id: order_by
  name: order_by
  updated_at: order_by
  website_url: order_by
}

# primary key columns input for table: "collections"
input collections_pk_columns_input {
  id: Int!
}

# select columns of table "collections"
enum collections_select_column {
  # column name
  brand_id

  # column name
  created_at

  # column name
  date_finished

  # column name
  date_started

  # column name
  for_gender

  # column name
  id

  # column name
  name

  # column name
  updated_at

  # column name
  website_url
}

# input type for updating data in table "collections"
input collections_set_input {
  brand_id: Int
  created_at: timestamptz
  date_finished: date
  date_started: date
  for_gender: genders_enum
  id: Int
  name: String
  updated_at: timestamptz
  website_url: String
}

# aggregate stddev on columns
type collections_stddev_fields {
  brand_id: Float
  id: Float
}

# order by stddev() on columns of table "collections"
input collections_stddev_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type collections_stddev_pop_fields {
  brand_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "collections"
input collections_stddev_pop_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type collections_stddev_samp_fields {
  brand_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "collections"
input collections_stddev_samp_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate sum on columns
type collections_sum_fields {
  brand_id: Int
  id: Int
}

# order by sum() on columns of table "collections"
input collections_sum_order_by {
  brand_id: order_by
  id: order_by
}

# update columns of table "collections"
enum collections_update_column {
  # column name
  brand_id

  # column name
  created_at

  # column name
  date_finished

  # column name
  date_started

  # column name
  for_gender

  # column name
  id

  # column name
  name

  # column name
  updated_at

  # column name
  website_url
}

# aggregate var_pop on columns
type collections_var_pop_fields {
  brand_id: Float
  id: Float
}

# order by var_pop() on columns of table "collections"
input collections_var_pop_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type collections_var_samp_fields {
  brand_id: Float
  id: Float
}

# order by var_samp() on columns of table "collections"
input collections_var_samp_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate variance on columns
type collections_variance_fields {
  brand_id: Float
  id: Float
}

# order by variance() on columns of table "collections"
input collections_variance_order_by {
  brand_id: order_by
  id: order_by
}

# A part of a colour mix, which is a collection of at least one colour
#
#
# columns and relationships of "colour_mix_parts"
#
type colour_mix_parts {
  # An object relationship
  colour: colours!

  # The id of the colour to represent this part of the colour mix.
  colour_id: Int!

  # An array relationship
  fabric_layer_and_colour_mix_parts(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): [fabric_layer_and_colour_mix_part!]!

  # An aggregated array relationship
  fabric_layer_and_colour_mix_parts_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): fabric_layer_and_colour_mix_part_aggregate!
  id: Int!

  # The percentage the colour takes up, expressed as a decimal between 0 and 1.
  percent: numeric!
}

# aggregated selection of "colour_mix_parts"
type colour_mix_parts_aggregate {
  aggregate: colour_mix_parts_aggregate_fields
  nodes: [colour_mix_parts!]!
}

# aggregate fields of "colour_mix_parts"
type colour_mix_parts_aggregate_fields {
  avg: colour_mix_parts_avg_fields
  count(columns: [colour_mix_parts_select_column!], distinct: Boolean): Int
  max: colour_mix_parts_max_fields
  min: colour_mix_parts_min_fields
  stddev: colour_mix_parts_stddev_fields
  stddev_pop: colour_mix_parts_stddev_pop_fields
  stddev_samp: colour_mix_parts_stddev_samp_fields
  sum: colour_mix_parts_sum_fields
  var_pop: colour_mix_parts_var_pop_fields
  var_samp: colour_mix_parts_var_samp_fields
  variance: colour_mix_parts_variance_fields
}

# order by aggregate values of table "colour_mix_parts"
input colour_mix_parts_aggregate_order_by {
  avg: colour_mix_parts_avg_order_by
  count: order_by
  max: colour_mix_parts_max_order_by
  min: colour_mix_parts_min_order_by
  stddev: colour_mix_parts_stddev_order_by
  stddev_pop: colour_mix_parts_stddev_pop_order_by
  stddev_samp: colour_mix_parts_stddev_samp_order_by
  sum: colour_mix_parts_sum_order_by
  var_pop: colour_mix_parts_var_pop_order_by
  var_samp: colour_mix_parts_var_samp_order_by
  variance: colour_mix_parts_variance_order_by
}

# input type for inserting array relation for remote table "colour_mix_parts"
input colour_mix_parts_arr_rel_insert_input {
  data: [colour_mix_parts_insert_input!]!
  on_conflict: colour_mix_parts_on_conflict
}

# aggregate avg on columns
type colour_mix_parts_avg_fields {
  colour_id: Float
  id: Float
  percent: Float
}

# order by avg() on columns of table "colour_mix_parts"
input colour_mix_parts_avg_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# Boolean expression to filter rows from the table "colour_mix_parts". All fields are combined with a logical 'AND'.
input colour_mix_parts_bool_exp {
  _and: [colour_mix_parts_bool_exp]
  _not: colour_mix_parts_bool_exp
  _or: [colour_mix_parts_bool_exp]
  colour: colours_bool_exp
  colour_id: Int_comparison_exp
  fabric_layer_and_colour_mix_parts: fabric_layer_and_colour_mix_part_bool_exp
  id: Int_comparison_exp
  percent: numeric_comparison_exp
}

# unique or primary key constraints on table "colour_mix_parts"
enum colour_mix_parts_constraint {
  # unique or primary key constraint
  colour_mix_parts_percent_colour_id_key

  # unique or primary key constraint
  colour_mix_parts_pkey
}

# input type for incrementing integer column in table "colour_mix_parts"
input colour_mix_parts_inc_input {
  colour_id: Int
  id: Int
  percent: numeric
}

# input type for inserting data into table "colour_mix_parts"
input colour_mix_parts_insert_input {
  colour: colours_obj_rel_insert_input
  colour_id: Int
  fabric_layer_and_colour_mix_parts: fabric_layer_and_colour_mix_part_arr_rel_insert_input
  id: Int
  percent: numeric
}

# aggregate max on columns
type colour_mix_parts_max_fields {
  colour_id: Int
  id: Int
  percent: numeric
}

# order by max() on columns of table "colour_mix_parts"
input colour_mix_parts_max_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# aggregate min on columns
type colour_mix_parts_min_fields {
  colour_id: Int
  id: Int
  percent: numeric
}

# order by min() on columns of table "colour_mix_parts"
input colour_mix_parts_min_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# response of any mutation on the table "colour_mix_parts"
type colour_mix_parts_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [colour_mix_parts!]!
}

# input type for inserting object relation for remote table "colour_mix_parts"
input colour_mix_parts_obj_rel_insert_input {
  data: colour_mix_parts_insert_input!
  on_conflict: colour_mix_parts_on_conflict
}

# on conflict condition type for table "colour_mix_parts"
input colour_mix_parts_on_conflict {
  constraint: colour_mix_parts_constraint!
  update_columns: [colour_mix_parts_update_column!]!
  where: colour_mix_parts_bool_exp
}

# ordering options when selecting data from "colour_mix_parts"
input colour_mix_parts_order_by {
  colour: colours_order_by
  colour_id: order_by
  fabric_layer_and_colour_mix_parts_aggregate: fabric_layer_and_colour_mix_part_aggregate_order_by
  id: order_by
  percent: order_by
}

# primary key columns input for table: "colour_mix_parts"
input colour_mix_parts_pk_columns_input {
  id: Int!
}

# select columns of table "colour_mix_parts"
enum colour_mix_parts_select_column {
  # column name
  colour_id

  # column name
  id

  # column name
  percent
}

# input type for updating data in table "colour_mix_parts"
input colour_mix_parts_set_input {
  colour_id: Int
  id: Int
  percent: numeric
}

# aggregate stddev on columns
type colour_mix_parts_stddev_fields {
  colour_id: Float
  id: Float
  percent: Float
}

# order by stddev() on columns of table "colour_mix_parts"
input colour_mix_parts_stddev_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# aggregate stddev_pop on columns
type colour_mix_parts_stddev_pop_fields {
  colour_id: Float
  id: Float
  percent: Float
}

# order by stddev_pop() on columns of table "colour_mix_parts"
input colour_mix_parts_stddev_pop_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# aggregate stddev_samp on columns
type colour_mix_parts_stddev_samp_fields {
  colour_id: Float
  id: Float
  percent: Float
}

# order by stddev_samp() on columns of table "colour_mix_parts"
input colour_mix_parts_stddev_samp_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# aggregate sum on columns
type colour_mix_parts_sum_fields {
  colour_id: Int
  id: Int
  percent: numeric
}

# order by sum() on columns of table "colour_mix_parts"
input colour_mix_parts_sum_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# update columns of table "colour_mix_parts"
enum colour_mix_parts_update_column {
  # column name
  colour_id

  # column name
  id

  # column name
  percent
}

# aggregate var_pop on columns
type colour_mix_parts_var_pop_fields {
  colour_id: Float
  id: Float
  percent: Float
}

# order by var_pop() on columns of table "colour_mix_parts"
input colour_mix_parts_var_pop_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# aggregate var_samp on columns
type colour_mix_parts_var_samp_fields {
  colour_id: Float
  id: Float
  percent: Float
}

# order by var_samp() on columns of table "colour_mix_parts"
input colour_mix_parts_var_samp_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# aggregate variance on columns
type colour_mix_parts_variance_fields {
  colour_id: Float
  id: Float
  percent: Float
}

# order by variance() on columns of table "colour_mix_parts"
input colour_mix_parts_variance_order_by {
  colour_id: order_by
  id: order_by
  percent: order_by
}

# The preset colours that clothing can have
#
#
# columns and relationships of "colours"
#
type colours {
  # The colour to represent a base colour (if its a simple colour), or the "group colour" a custom colour belongs to.
  base_colour: base_colours_enum

  # The colour code to represent the custom colour, typically as a hexadecimal code (e.g. #f0f0f0).
  colour_code: String
  id: Int!

  # The name of the colour. This is unique, so ensure that names are spelt correctly starting with a capital letter.
  name: String!
}

# aggregated selection of "colours"
type colours_aggregate {
  aggregate: colours_aggregate_fields
  nodes: [colours!]!
}

# aggregate fields of "colours"
type colours_aggregate_fields {
  avg: colours_avg_fields
  count(columns: [colours_select_column!], distinct: Boolean): Int
  max: colours_max_fields
  min: colours_min_fields
  stddev: colours_stddev_fields
  stddev_pop: colours_stddev_pop_fields
  stddev_samp: colours_stddev_samp_fields
  sum: colours_sum_fields
  var_pop: colours_var_pop_fields
  var_samp: colours_var_samp_fields
  variance: colours_variance_fields
}

# order by aggregate values of table "colours"
input colours_aggregate_order_by {
  avg: colours_avg_order_by
  count: order_by
  max: colours_max_order_by
  min: colours_min_order_by
  stddev: colours_stddev_order_by
  stddev_pop: colours_stddev_pop_order_by
  stddev_samp: colours_stddev_samp_order_by
  sum: colours_sum_order_by
  var_pop: colours_var_pop_order_by
  var_samp: colours_var_samp_order_by
  variance: colours_variance_order_by
}

# input type for inserting array relation for remote table "colours"
input colours_arr_rel_insert_input {
  data: [colours_insert_input!]!
  on_conflict: colours_on_conflict
}

# aggregate avg on columns
type colours_avg_fields {
  id: Float
}

# order by avg() on columns of table "colours"
input colours_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "colours". All fields are combined with a logical 'AND'.
input colours_bool_exp {
  _and: [colours_bool_exp]
  _not: colours_bool_exp
  _or: [colours_bool_exp]
  base_colour: base_colours_enum_comparison_exp
  colour_code: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "colours"
enum colours_constraint {
  # unique or primary key constraint
  colours_name_key

  # unique or primary key constraint
  colours_pkey
}

# input type for incrementing integer column in table "colours"
input colours_inc_input {
  id: Int
}

# input type for inserting data into table "colours"
input colours_insert_input {
  base_colour: base_colours_enum
  colour_code: String
  id: Int
  name: String
}

# aggregate max on columns
type colours_max_fields {
  colour_code: String
  id: Int
  name: String
}

# order by max() on columns of table "colours"
input colours_max_order_by {
  colour_code: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type colours_min_fields {
  colour_code: String
  id: Int
  name: String
}

# order by min() on columns of table "colours"
input colours_min_order_by {
  colour_code: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "colours"
type colours_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [colours!]!
}

# input type for inserting object relation for remote table "colours"
input colours_obj_rel_insert_input {
  data: colours_insert_input!
  on_conflict: colours_on_conflict
}

# on conflict condition type for table "colours"
input colours_on_conflict {
  constraint: colours_constraint!
  update_columns: [colours_update_column!]!
  where: colours_bool_exp
}

# ordering options when selecting data from "colours"
input colours_order_by {
  base_colour: order_by
  colour_code: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "colours"
input colours_pk_columns_input {
  id: Int!
}

# select columns of table "colours"
enum colours_select_column {
  # column name
  base_colour

  # column name
  colour_code

  # column name
  id

  # column name
  name
}

# input type for updating data in table "colours"
input colours_set_input {
  base_colour: base_colours_enum
  colour_code: String
  id: Int
  name: String
}

# aggregate stddev on columns
type colours_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "colours"
input colours_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type colours_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "colours"
input colours_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type colours_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "colours"
input colours_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type colours_sum_fields {
  id: Int
}

# order by sum() on columns of table "colours"
input colours_sum_order_by {
  id: order_by
}

# update columns of table "colours"
enum colours_update_column {
  # column name
  base_colour

  # column name
  colour_code

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type colours_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "colours"
input colours_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type colours_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "colours"
input colours_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type colours_variance_fields {
  id: Float
}

# order by variance() on columns of table "colours"
input colours_variance_order_by {
  id: order_by
}

# columns and relationships of "companies"
type companies {
  # The date when the affiliate relationship first started with the company.
  affiliate_start_date: date

  # An array relationship
  collab_company_and_collections(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): [collab_company_and_collection!]!

  # An aggregated array relationship
  collab_company_and_collections_aggregate(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): collab_company_and_collection_aggregate!

  # An array relationship
  collections(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): [collections!]!

  # An aggregated array relationship
  collections_aggregate(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): collections_aggregate!

  # An array relationship
  company_translations(
    # distinct select on columns
    distinct_on: [company_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revisions_order_by!]

    # filter the rows returned
    where: company_translation_revisions_bool_exp
  ): [company_translation_revisions!]!

  # An aggregated array relationship
  company_translations_aggregate(
    # distinct select on columns
    distinct_on: [company_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revisions_order_by!]

    # filter the rows returned
    where: company_translation_revisions_bool_exp
  ): company_translation_revisions_aggregate!

  # An object relationship
  counts: company_counts
  created_at: timestamptz

  # An object relationship
  founded_in: countries

  # The country code that the company was founded in (or is currently operating in).
  founded_in_id: countries_enum
  id: Int!
  is_affiliate: Boolean!

  # Whether or not the company is a reseller or not. A reseller is a company that
  # typically does not make their own clothing, but instead mainly sells other
  # brand's clothing.
  is_reseller: Boolean!

  # An array relationship
  item_families(
    # distinct select on columns
    distinct_on: [item_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_families_order_by!]

    # filter the rows returned
    where: item_families_bool_exp
  ): [item_families!]!

  # An aggregated array relationship
  item_families_aggregate(
    # distinct select on columns
    distinct_on: [item_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_families_order_by!]

    # filter the rows returned
    where: item_families_bool_exp
  ): item_families_aggregate!

  # An array relationship
  item_maindata(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): [item_maindata!]!

  # An aggregated array relationship
  item_maindata_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): item_maindata_aggregate!

  # The url of the logo to display in the CMS (Does not appear in any end user app).
  logo_url: String
  name: String!
  short_id: Int
  updated_at: timestamptz
  website_url: String!
}

# aggregated selection of "companies"
type companies_aggregate {
  aggregate: companies_aggregate_fields
  nodes: [companies!]!
}

# aggregate fields of "companies"
type companies_aggregate_fields {
  avg: companies_avg_fields
  count(columns: [companies_select_column!], distinct: Boolean): Int
  max: companies_max_fields
  min: companies_min_fields
  stddev: companies_stddev_fields
  stddev_pop: companies_stddev_pop_fields
  stddev_samp: companies_stddev_samp_fields
  sum: companies_sum_fields
  var_pop: companies_var_pop_fields
  var_samp: companies_var_samp_fields
  variance: companies_variance_fields
}

# order by aggregate values of table "companies"
input companies_aggregate_order_by {
  avg: companies_avg_order_by
  count: order_by
  max: companies_max_order_by
  min: companies_min_order_by
  stddev: companies_stddev_order_by
  stddev_pop: companies_stddev_pop_order_by
  stddev_samp: companies_stddev_samp_order_by
  sum: companies_sum_order_by
  var_pop: companies_var_pop_order_by
  var_samp: companies_var_samp_order_by
  variance: companies_variance_order_by
}

# input type for inserting array relation for remote table "companies"
input companies_arr_rel_insert_input {
  data: [companies_insert_input!]!
  on_conflict: companies_on_conflict
}

# aggregate avg on columns
type companies_avg_fields {
  id: Float
  short_id: Float
}

# order by avg() on columns of table "companies"
input companies_avg_order_by {
  id: order_by
  short_id: order_by
}

# Boolean expression to filter rows from the table "companies". All fields are combined with a logical 'AND'.
input companies_bool_exp {
  _and: [companies_bool_exp]
  _not: companies_bool_exp
  _or: [companies_bool_exp]
  affiliate_start_date: date_comparison_exp
  collab_company_and_collections: collab_company_and_collection_bool_exp
  collections: collections_bool_exp
  company_translations: company_translation_revisions_bool_exp
  counts: company_counts_bool_exp
  created_at: timestamptz_comparison_exp
  founded_in: countries_bool_exp
  founded_in_id: countries_enum_comparison_exp
  id: Int_comparison_exp
  is_affiliate: Boolean_comparison_exp
  is_reseller: Boolean_comparison_exp
  item_families: item_families_bool_exp
  item_maindata: item_maindata_bool_exp
  logo_url: String_comparison_exp
  name: String_comparison_exp
  short_id: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  website_url: String_comparison_exp
}

# unique or primary key constraints on table "companies"
enum companies_constraint {
  # unique or primary key constraint
  companies_pkey

  # unique or primary key constraint
  companies_short_id_key
}

# input type for incrementing integer column in table "companies"
input companies_inc_input {
  id: Int
  short_id: Int
}

# input type for inserting data into table "companies"
input companies_insert_input {
  affiliate_start_date: date
  collab_company_and_collections: collab_company_and_collection_arr_rel_insert_input
  collections: collections_arr_rel_insert_input
  company_translations: company_translation_revisions_arr_rel_insert_input
  counts: company_counts_obj_rel_insert_input
  created_at: timestamptz
  founded_in: countries_obj_rel_insert_input
  founded_in_id: countries_enum
  id: Int
  is_affiliate: Boolean
  is_reseller: Boolean
  item_families: item_families_arr_rel_insert_input
  item_maindata: item_maindata_arr_rel_insert_input
  logo_url: String
  name: String
  short_id: Int
  updated_at: timestamptz
  website_url: String
}

# aggregate max on columns
type companies_max_fields {
  affiliate_start_date: date
  created_at: timestamptz
  id: Int
  logo_url: String
  name: String
  short_id: Int
  updated_at: timestamptz
  website_url: String
}

# order by max() on columns of table "companies"
input companies_max_order_by {
  affiliate_start_date: order_by
  created_at: order_by
  id: order_by
  logo_url: order_by
  name: order_by
  short_id: order_by
  updated_at: order_by
  website_url: order_by
}

# aggregate min on columns
type companies_min_fields {
  affiliate_start_date: date
  created_at: timestamptz
  id: Int
  logo_url: String
  name: String
  short_id: Int
  updated_at: timestamptz
  website_url: String
}

# order by min() on columns of table "companies"
input companies_min_order_by {
  affiliate_start_date: order_by
  created_at: order_by
  id: order_by
  logo_url: order_by
  name: order_by
  short_id: order_by
  updated_at: order_by
  website_url: order_by
}

# response of any mutation on the table "companies"
type companies_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [companies!]!
}

# input type for inserting object relation for remote table "companies"
input companies_obj_rel_insert_input {
  data: companies_insert_input!
  on_conflict: companies_on_conflict
}

# on conflict condition type for table "companies"
input companies_on_conflict {
  constraint: companies_constraint!
  update_columns: [companies_update_column!]!
  where: companies_bool_exp
}

# ordering options when selecting data from "companies"
input companies_order_by {
  affiliate_start_date: order_by
  collab_company_and_collections_aggregate: collab_company_and_collection_aggregate_order_by
  collections_aggregate: collections_aggregate_order_by
  company_translations_aggregate: company_translation_revisions_aggregate_order_by
  counts: company_counts_order_by
  created_at: order_by
  founded_in: countries_order_by
  founded_in_id: order_by
  id: order_by
  is_affiliate: order_by
  is_reseller: order_by
  item_families_aggregate: item_families_aggregate_order_by
  item_maindata_aggregate: item_maindata_aggregate_order_by
  logo_url: order_by
  name: order_by
  short_id: order_by
  updated_at: order_by
  website_url: order_by
}

# primary key columns input for table: "companies"
input companies_pk_columns_input {
  id: Int!
}

# select columns of table "companies"
enum companies_select_column {
  # column name
  affiliate_start_date

  # column name
  created_at

  # column name
  founded_in_id

  # column name
  id

  # column name
  is_affiliate

  # column name
  is_reseller

  # column name
  logo_url

  # column name
  name

  # column name
  short_id

  # column name
  updated_at

  # column name
  website_url
}

# input type for updating data in table "companies"
input companies_set_input {
  affiliate_start_date: date
  created_at: timestamptz
  founded_in_id: countries_enum
  id: Int
  is_affiliate: Boolean
  is_reseller: Boolean
  logo_url: String
  name: String
  short_id: Int
  updated_at: timestamptz
  website_url: String
}

# aggregate stddev on columns
type companies_stddev_fields {
  id: Float
  short_id: Float
}

# order by stddev() on columns of table "companies"
input companies_stddev_order_by {
  id: order_by
  short_id: order_by
}

# aggregate stddev_pop on columns
type companies_stddev_pop_fields {
  id: Float
  short_id: Float
}

# order by stddev_pop() on columns of table "companies"
input companies_stddev_pop_order_by {
  id: order_by
  short_id: order_by
}

# aggregate stddev_samp on columns
type companies_stddev_samp_fields {
  id: Float
  short_id: Float
}

# order by stddev_samp() on columns of table "companies"
input companies_stddev_samp_order_by {
  id: order_by
  short_id: order_by
}

# aggregate sum on columns
type companies_sum_fields {
  id: Int
  short_id: Int
}

# order by sum() on columns of table "companies"
input companies_sum_order_by {
  id: order_by
  short_id: order_by
}

# update columns of table "companies"
enum companies_update_column {
  # column name
  affiliate_start_date

  # column name
  created_at

  # column name
  founded_in_id

  # column name
  id

  # column name
  is_affiliate

  # column name
  is_reseller

  # column name
  logo_url

  # column name
  name

  # column name
  short_id

  # column name
  updated_at

  # column name
  website_url
}

# aggregate var_pop on columns
type companies_var_pop_fields {
  id: Float
  short_id: Float
}

# order by var_pop() on columns of table "companies"
input companies_var_pop_order_by {
  id: order_by
  short_id: order_by
}

# aggregate var_samp on columns
type companies_var_samp_fields {
  id: Float
  short_id: Float
}

# order by var_samp() on columns of table "companies"
input companies_var_samp_order_by {
  id: order_by
  short_id: order_by
}

# aggregate variance on columns
type companies_variance_fields {
  id: Float
  short_id: Float
}

# order by variance() on columns of table "companies"
input companies_variance_order_by {
  id: order_by
  short_id: order_by
}

# Data describing the various data entry aggregates (calculated) for companies.
#
#
# columns and relationships of "company_counts"
#
type company_counts {
  # An object relationship
  company: companies!
  company_id: Int!
  id: Int!
  item_count: Int!
}

# aggregated selection of "company_counts"
type company_counts_aggregate {
  aggregate: company_counts_aggregate_fields
  nodes: [company_counts!]!
}

# aggregate fields of "company_counts"
type company_counts_aggregate_fields {
  avg: company_counts_avg_fields
  count(columns: [company_counts_select_column!], distinct: Boolean): Int
  max: company_counts_max_fields
  min: company_counts_min_fields
  stddev: company_counts_stddev_fields
  stddev_pop: company_counts_stddev_pop_fields
  stddev_samp: company_counts_stddev_samp_fields
  sum: company_counts_sum_fields
  var_pop: company_counts_var_pop_fields
  var_samp: company_counts_var_samp_fields
  variance: company_counts_variance_fields
}

# order by aggregate values of table "company_counts"
input company_counts_aggregate_order_by {
  avg: company_counts_avg_order_by
  count: order_by
  max: company_counts_max_order_by
  min: company_counts_min_order_by
  stddev: company_counts_stddev_order_by
  stddev_pop: company_counts_stddev_pop_order_by
  stddev_samp: company_counts_stddev_samp_order_by
  sum: company_counts_sum_order_by
  var_pop: company_counts_var_pop_order_by
  var_samp: company_counts_var_samp_order_by
  variance: company_counts_variance_order_by
}

# input type for inserting array relation for remote table "company_counts"
input company_counts_arr_rel_insert_input {
  data: [company_counts_insert_input!]!
  on_conflict: company_counts_on_conflict
}

# aggregate avg on columns
type company_counts_avg_fields {
  company_id: Float
  id: Float
  item_count: Float
}

# order by avg() on columns of table "company_counts"
input company_counts_avg_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# Boolean expression to filter rows from the table "company_counts". All fields are combined with a logical 'AND'.
input company_counts_bool_exp {
  _and: [company_counts_bool_exp]
  _not: company_counts_bool_exp
  _or: [company_counts_bool_exp]
  company: companies_bool_exp
  company_id: Int_comparison_exp
  id: Int_comparison_exp
  item_count: Int_comparison_exp
}

# unique or primary key constraints on table "company_counts"
enum company_counts_constraint {
  # unique or primary key constraint
  company_counts_company_id_key

  # unique or primary key constraint
  company_counts_pkey
}

# input type for incrementing integer column in table "company_counts"
input company_counts_inc_input {
  company_id: Int
  id: Int
  item_count: Int
}

# input type for inserting data into table "company_counts"
input company_counts_insert_input {
  company: companies_obj_rel_insert_input
  company_id: Int
  id: Int
  item_count: Int
}

# aggregate max on columns
type company_counts_max_fields {
  company_id: Int
  id: Int
  item_count: Int
}

# order by max() on columns of table "company_counts"
input company_counts_max_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate min on columns
type company_counts_min_fields {
  company_id: Int
  id: Int
  item_count: Int
}

# order by min() on columns of table "company_counts"
input company_counts_min_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# response of any mutation on the table "company_counts"
type company_counts_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [company_counts!]!
}

# input type for inserting object relation for remote table "company_counts"
input company_counts_obj_rel_insert_input {
  data: company_counts_insert_input!
  on_conflict: company_counts_on_conflict
}

# on conflict condition type for table "company_counts"
input company_counts_on_conflict {
  constraint: company_counts_constraint!
  update_columns: [company_counts_update_column!]!
  where: company_counts_bool_exp
}

# ordering options when selecting data from "company_counts"
input company_counts_order_by {
  company: companies_order_by
  company_id: order_by
  id: order_by
  item_count: order_by
}

# primary key columns input for table: "company_counts"
input company_counts_pk_columns_input {
  id: Int!
}

# select columns of table "company_counts"
enum company_counts_select_column {
  # column name
  company_id

  # column name
  id

  # column name
  item_count
}

# input type for updating data in table "company_counts"
input company_counts_set_input {
  company_id: Int
  id: Int
  item_count: Int
}

# aggregate stddev on columns
type company_counts_stddev_fields {
  company_id: Float
  id: Float
  item_count: Float
}

# order by stddev() on columns of table "company_counts"
input company_counts_stddev_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate stddev_pop on columns
type company_counts_stddev_pop_fields {
  company_id: Float
  id: Float
  item_count: Float
}

# order by stddev_pop() on columns of table "company_counts"
input company_counts_stddev_pop_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate stddev_samp on columns
type company_counts_stddev_samp_fields {
  company_id: Float
  id: Float
  item_count: Float
}

# order by stddev_samp() on columns of table "company_counts"
input company_counts_stddev_samp_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate sum on columns
type company_counts_sum_fields {
  company_id: Int
  id: Int
  item_count: Int
}

# order by sum() on columns of table "company_counts"
input company_counts_sum_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# update columns of table "company_counts"
enum company_counts_update_column {
  # column name
  company_id

  # column name
  id

  # column name
  item_count
}

# aggregate var_pop on columns
type company_counts_var_pop_fields {
  company_id: Float
  id: Float
  item_count: Float
}

# order by var_pop() on columns of table "company_counts"
input company_counts_var_pop_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate var_samp on columns
type company_counts_var_samp_fields {
  company_id: Float
  id: Float
  item_count: Float
}

# order by var_samp() on columns of table "company_counts"
input company_counts_var_samp_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# aggregate variance on columns
type company_counts_variance_fields {
  company_id: Float
  id: Float
  item_count: Float
}

# order by variance() on columns of table "company_counts"
input company_counts_variance_order_by {
  company_id: order_by
  id: order_by
  item_count: order_by
}

# Intended for the table "company_translation_revisions". Contains information
# about changes made, such as and edits, deletes, updates and promotions.
#
#
# columns and relationships of "company_translation_revision_changes"
#
type company_translation_revision_changes {
  action: data_actions_enum
  change_type: data_change_types_enum!

  # An object relationship
  company_translation_revision: company_translation_revisions!
  company_translation_revision_id: uuid!
  date: timestamptz!
  id: uuid!
  to_state: data_states_enum

  # An object relationship
  user: staff_users!
  user_id: Int!
}

# aggregated selection of "company_translation_revision_changes"
type company_translation_revision_changes_aggregate {
  aggregate: company_translation_revision_changes_aggregate_fields
  nodes: [company_translation_revision_changes!]!
}

# aggregate fields of "company_translation_revision_changes"
type company_translation_revision_changes_aggregate_fields {
  avg: company_translation_revision_changes_avg_fields
  count(columns: [company_translation_revision_changes_select_column!], distinct: Boolean): Int
  max: company_translation_revision_changes_max_fields
  min: company_translation_revision_changes_min_fields
  stddev: company_translation_revision_changes_stddev_fields
  stddev_pop: company_translation_revision_changes_stddev_pop_fields
  stddev_samp: company_translation_revision_changes_stddev_samp_fields
  sum: company_translation_revision_changes_sum_fields
  var_pop: company_translation_revision_changes_var_pop_fields
  var_samp: company_translation_revision_changes_var_samp_fields
  variance: company_translation_revision_changes_variance_fields
}

# order by aggregate values of table "company_translation_revision_changes"
input company_translation_revision_changes_aggregate_order_by {
  avg: company_translation_revision_changes_avg_order_by
  count: order_by
  max: company_translation_revision_changes_max_order_by
  min: company_translation_revision_changes_min_order_by
  stddev: company_translation_revision_changes_stddev_order_by
  stddev_pop: company_translation_revision_changes_stddev_pop_order_by
  stddev_samp: company_translation_revision_changes_stddev_samp_order_by
  sum: company_translation_revision_changes_sum_order_by
  var_pop: company_translation_revision_changes_var_pop_order_by
  var_samp: company_translation_revision_changes_var_samp_order_by
  variance: company_translation_revision_changes_variance_order_by
}

# input type for inserting array relation for remote table "company_translation_revision_changes"
input company_translation_revision_changes_arr_rel_insert_input {
  data: [company_translation_revision_changes_insert_input!]!
  on_conflict: company_translation_revision_changes_on_conflict
}

# aggregate avg on columns
type company_translation_revision_changes_avg_fields {
  user_id: Float
}

# order by avg() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_avg_order_by {
  user_id: order_by
}

# Boolean expression to filter rows from the table
# "company_translation_revision_changes". All fields are combined with a logical 'AND'.
input company_translation_revision_changes_bool_exp {
  _and: [company_translation_revision_changes_bool_exp]
  _not: company_translation_revision_changes_bool_exp
  _or: [company_translation_revision_changes_bool_exp]
  action: data_actions_enum_comparison_exp
  change_type: data_change_types_enum_comparison_exp
  company_translation_revision: company_translation_revisions_bool_exp
  company_translation_revision_id: uuid_comparison_exp
  date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  to_state: data_states_enum_comparison_exp
  user: staff_users_bool_exp
  user_id: Int_comparison_exp
}

# unique or primary key constraints on table "company_translation_revision_changes"
enum company_translation_revision_changes_constraint {
  # unique or primary key constraint
  company_translation_revision_changes_pkey
}

# input type for incrementing integer column in table "company_translation_revision_changes"
input company_translation_revision_changes_inc_input {
  user_id: Int
}

# input type for inserting data into table "company_translation_revision_changes"
input company_translation_revision_changes_insert_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  company_translation_revision: company_translation_revisions_obj_rel_insert_input
  company_translation_revision_id: uuid
  date: timestamptz
  id: uuid
  to_state: data_states_enum
  user: staff_users_obj_rel_insert_input
  user_id: Int
}

# aggregate max on columns
type company_translation_revision_changes_max_fields {
  company_translation_revision_id: uuid
  date: timestamptz
  id: uuid
  user_id: Int
}

# order by max() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_max_order_by {
  company_translation_revision_id: order_by
  date: order_by
  id: order_by
  user_id: order_by
}

# aggregate min on columns
type company_translation_revision_changes_min_fields {
  company_translation_revision_id: uuid
  date: timestamptz
  id: uuid
  user_id: Int
}

# order by min() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_min_order_by {
  company_translation_revision_id: order_by
  date: order_by
  id: order_by
  user_id: order_by
}

# response of any mutation on the table "company_translation_revision_changes"
type company_translation_revision_changes_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [company_translation_revision_changes!]!
}

# input type for inserting object relation for remote table "company_translation_revision_changes"
input company_translation_revision_changes_obj_rel_insert_input {
  data: company_translation_revision_changes_insert_input!
  on_conflict: company_translation_revision_changes_on_conflict
}

# on conflict condition type for table "company_translation_revision_changes"
input company_translation_revision_changes_on_conflict {
  constraint: company_translation_revision_changes_constraint!
  update_columns: [company_translation_revision_changes_update_column!]!
  where: company_translation_revision_changes_bool_exp
}

# ordering options when selecting data from "company_translation_revision_changes"
input company_translation_revision_changes_order_by {
  action: order_by
  change_type: order_by
  company_translation_revision: company_translation_revisions_order_by
  company_translation_revision_id: order_by
  date: order_by
  id: order_by
  to_state: order_by
  user: staff_users_order_by
  user_id: order_by
}

# primary key columns input for table: "company_translation_revision_changes"
input company_translation_revision_changes_pk_columns_input {
  id: uuid!
}

# select columns of table "company_translation_revision_changes"
enum company_translation_revision_changes_select_column {
  # column name
  action

  # column name
  change_type

  # column name
  company_translation_revision_id

  # column name
  date

  # column name
  id

  # column name
  to_state

  # column name
  user_id
}

# input type for updating data in table "company_translation_revision_changes"
input company_translation_revision_changes_set_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  company_translation_revision_id: uuid
  date: timestamptz
  id: uuid
  to_state: data_states_enum
  user_id: Int
}

# aggregate stddev on columns
type company_translation_revision_changes_stddev_fields {
  user_id: Float
}

# order by stddev() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_stddev_order_by {
  user_id: order_by
}

# aggregate stddev_pop on columns
type company_translation_revision_changes_stddev_pop_fields {
  user_id: Float
}

# order by stddev_pop() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_stddev_pop_order_by {
  user_id: order_by
}

# aggregate stddev_samp on columns
type company_translation_revision_changes_stddev_samp_fields {
  user_id: Float
}

# order by stddev_samp() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_stddev_samp_order_by {
  user_id: order_by
}

# aggregate sum on columns
type company_translation_revision_changes_sum_fields {
  user_id: Int
}

# order by sum() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_sum_order_by {
  user_id: order_by
}

# update columns of table "company_translation_revision_changes"
enum company_translation_revision_changes_update_column {
  # column name
  action

  # column name
  change_type

  # column name
  company_translation_revision_id

  # column name
  date

  # column name
  id

  # column name
  to_state

  # column name
  user_id
}

# aggregate var_pop on columns
type company_translation_revision_changes_var_pop_fields {
  user_id: Float
}

# order by var_pop() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_var_pop_order_by {
  user_id: order_by
}

# aggregate var_samp on columns
type company_translation_revision_changes_var_samp_fields {
  user_id: Float
}

# order by var_samp() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_var_samp_order_by {
  user_id: order_by
}

# aggregate variance on columns
type company_translation_revision_changes_variance_fields {
  user_id: Float
}

# order by variance() on columns of table "company_translation_revision_changes"
input company_translation_revision_changes_variance_order_by {
  user_id: order_by
}

# A translation revision for companies, containing vital control information for it's draft and release versions.
#
#
# columns and relationships of "company_translation_revisions"
#
type company_translation_revisions {
  # An object relationship
  company: companies!

  # The associated id of the company this translation revision is intended for.
  company_id: Int!

  # An array relationship
  company_translations(
    # distinct select on columns
    distinct_on: [company_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translations_order_by!]

    # filter the rows returned
    where: company_translations_bool_exp
  ): [company_translations!]!

  # An aggregated array relationship
  company_translations_aggregate(
    # distinct select on columns
    distinct_on: [company_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translations_order_by!]

    # filter the rows returned
    where: company_translations_bool_exp
  ): company_translations_aggregate!
  id: uuid!

  # An object relationship
  locale: locales!

  # The locale code representing the locale that this translation revision is in.
  locale_code: String!

  # The revision or version number of this translation group (of draft and release).
  revision: Int!

  # The data state of this translation revision (e.g. DEVELOPMENT, REVIEW, PRODUCTION and RETIRED).
  state: data_states_enum!
}

# aggregated selection of "company_translation_revisions"
type company_translation_revisions_aggregate {
  aggregate: company_translation_revisions_aggregate_fields
  nodes: [company_translation_revisions!]!
}

# aggregate fields of "company_translation_revisions"
type company_translation_revisions_aggregate_fields {
  avg: company_translation_revisions_avg_fields
  count(columns: [company_translation_revisions_select_column!], distinct: Boolean): Int
  max: company_translation_revisions_max_fields
  min: company_translation_revisions_min_fields
  stddev: company_translation_revisions_stddev_fields
  stddev_pop: company_translation_revisions_stddev_pop_fields
  stddev_samp: company_translation_revisions_stddev_samp_fields
  sum: company_translation_revisions_sum_fields
  var_pop: company_translation_revisions_var_pop_fields
  var_samp: company_translation_revisions_var_samp_fields
  variance: company_translation_revisions_variance_fields
}

# order by aggregate values of table "company_translation_revisions"
input company_translation_revisions_aggregate_order_by {
  avg: company_translation_revisions_avg_order_by
  count: order_by
  max: company_translation_revisions_max_order_by
  min: company_translation_revisions_min_order_by
  stddev: company_translation_revisions_stddev_order_by
  stddev_pop: company_translation_revisions_stddev_pop_order_by
  stddev_samp: company_translation_revisions_stddev_samp_order_by
  sum: company_translation_revisions_sum_order_by
  var_pop: company_translation_revisions_var_pop_order_by
  var_samp: company_translation_revisions_var_samp_order_by
  variance: company_translation_revisions_variance_order_by
}

# input type for inserting array relation for remote table "company_translation_revisions"
input company_translation_revisions_arr_rel_insert_input {
  data: [company_translation_revisions_insert_input!]!
  on_conflict: company_translation_revisions_on_conflict
}

# aggregate avg on columns
type company_translation_revisions_avg_fields {
  company_id: Float
  revision: Float
}

# order by avg() on columns of table "company_translation_revisions"
input company_translation_revisions_avg_order_by {
  company_id: order_by
  revision: order_by
}

# Boolean expression to filter rows from the table
# "company_translation_revisions". All fields are combined with a logical 'AND'.
input company_translation_revisions_bool_exp {
  _and: [company_translation_revisions_bool_exp]
  _not: company_translation_revisions_bool_exp
  _or: [company_translation_revisions_bool_exp]
  company: companies_bool_exp
  company_id: Int_comparison_exp
  company_translations: company_translations_bool_exp
  id: uuid_comparison_exp
  locale: locales_bool_exp
  locale_code: String_comparison_exp
  revision: Int_comparison_exp
  state: data_states_enum_comparison_exp
}

# unique or primary key constraints on table "company_translation_revisions"
enum company_translation_revisions_constraint {
  # unique or primary key constraint
  company_translation_revisions_company_id_locale_code_revisi_key

  # unique or primary key constraint
  company_translation_revisions_pkey
}

# input type for incrementing integer column in table "company_translation_revisions"
input company_translation_revisions_inc_input {
  company_id: Int
  revision: Int
}

# input type for inserting data into table "company_translation_revisions"
input company_translation_revisions_insert_input {
  company: companies_obj_rel_insert_input
  company_id: Int
  company_translations: company_translations_arr_rel_insert_input
  id: uuid
  locale: locales_obj_rel_insert_input
  locale_code: String
  revision: Int
  state: data_states_enum
}

# aggregate max on columns
type company_translation_revisions_max_fields {
  company_id: Int
  id: uuid
  locale_code: String
  revision: Int
}

# order by max() on columns of table "company_translation_revisions"
input company_translation_revisions_max_order_by {
  company_id: order_by
  id: order_by
  locale_code: order_by
  revision: order_by
}

# aggregate min on columns
type company_translation_revisions_min_fields {
  company_id: Int
  id: uuid
  locale_code: String
  revision: Int
}

# order by min() on columns of table "company_translation_revisions"
input company_translation_revisions_min_order_by {
  company_id: order_by
  id: order_by
  locale_code: order_by
  revision: order_by
}

# response of any mutation on the table "company_translation_revisions"
type company_translation_revisions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [company_translation_revisions!]!
}

# input type for inserting object relation for remote table "company_translation_revisions"
input company_translation_revisions_obj_rel_insert_input {
  data: company_translation_revisions_insert_input!
  on_conflict: company_translation_revisions_on_conflict
}

# on conflict condition type for table "company_translation_revisions"
input company_translation_revisions_on_conflict {
  constraint: company_translation_revisions_constraint!
  update_columns: [company_translation_revisions_update_column!]!
  where: company_translation_revisions_bool_exp
}

# ordering options when selecting data from "company_translation_revisions"
input company_translation_revisions_order_by {
  company: companies_order_by
  company_id: order_by
  company_translations_aggregate: company_translations_aggregate_order_by
  id: order_by
  locale: locales_order_by
  locale_code: order_by
  revision: order_by
  state: order_by
}

# primary key columns input for table: "company_translation_revisions"
input company_translation_revisions_pk_columns_input {
  id: uuid!
}

# select columns of table "company_translation_revisions"
enum company_translation_revisions_select_column {
  # column name
  company_id

  # column name
  id

  # column name
  locale_code

  # column name
  revision

  # column name
  state
}

# input type for updating data in table "company_translation_revisions"
input company_translation_revisions_set_input {
  company_id: Int
  id: uuid
  locale_code: String
  revision: Int
  state: data_states_enum
}

# aggregate stddev on columns
type company_translation_revisions_stddev_fields {
  company_id: Float
  revision: Float
}

# order by stddev() on columns of table "company_translation_revisions"
input company_translation_revisions_stddev_order_by {
  company_id: order_by
  revision: order_by
}

# aggregate stddev_pop on columns
type company_translation_revisions_stddev_pop_fields {
  company_id: Float
  revision: Float
}

# order by stddev_pop() on columns of table "company_translation_revisions"
input company_translation_revisions_stddev_pop_order_by {
  company_id: order_by
  revision: order_by
}

# aggregate stddev_samp on columns
type company_translation_revisions_stddev_samp_fields {
  company_id: Float
  revision: Float
}

# order by stddev_samp() on columns of table "company_translation_revisions"
input company_translation_revisions_stddev_samp_order_by {
  company_id: order_by
  revision: order_by
}

# aggregate sum on columns
type company_translation_revisions_sum_fields {
  company_id: Int
  revision: Int
}

# order by sum() on columns of table "company_translation_revisions"
input company_translation_revisions_sum_order_by {
  company_id: order_by
  revision: order_by
}

# update columns of table "company_translation_revisions"
enum company_translation_revisions_update_column {
  # column name
  company_id

  # column name
  id

  # column name
  locale_code

  # column name
  revision

  # column name
  state
}

# aggregate var_pop on columns
type company_translation_revisions_var_pop_fields {
  company_id: Float
  revision: Float
}

# order by var_pop() on columns of table "company_translation_revisions"
input company_translation_revisions_var_pop_order_by {
  company_id: order_by
  revision: order_by
}

# aggregate var_samp on columns
type company_translation_revisions_var_samp_fields {
  company_id: Float
  revision: Float
}

# order by var_samp() on columns of table "company_translation_revisions"
input company_translation_revisions_var_samp_order_by {
  company_id: order_by
  revision: order_by
}

# aggregate variance on columns
type company_translation_revisions_variance_fields {
  company_id: Float
  revision: Float
}

# order by variance() on columns of table "company_translation_revisions"
input company_translation_revisions_variance_order_by {
  company_id: order_by
  revision: order_by
}

# Translated text for companies in their specific languages.
#
#
# columns and relationships of "company_translations"
#
type company_translations {
  # A description of the company.
  bio: String
  id: uuid!

  # Whether or not the translation is a release version (true), or a draft (false).
  is_release: Boolean!

  # An object relationship
  revision: company_translation_revisions!

  # The associated revision id of the company this translation is a part of.
  revision_id: uuid!

  # The short name of the company, non-stylised. This is often similar to the
  # stylised name, but abides by grammar rules. Used for practical purposes such
  # as searching. (e.g. "Adidas").
  short_name: String!

  # The short but stylised name of the company. This is how it will appear to end
  # users in any application. Stylised text = ignore punctuation and grammar and
  # make the title look nice. (e.g. BVLGARI for the brand Bulgari).
  stylised_name: String!
}

# aggregated selection of "company_translations"
type company_translations_aggregate {
  aggregate: company_translations_aggregate_fields
  nodes: [company_translations!]!
}

# aggregate fields of "company_translations"
type company_translations_aggregate_fields {
  count(columns: [company_translations_select_column!], distinct: Boolean): Int
  max: company_translations_max_fields
  min: company_translations_min_fields
}

# order by aggregate values of table "company_translations"
input company_translations_aggregate_order_by {
  count: order_by
  max: company_translations_max_order_by
  min: company_translations_min_order_by
}

# input type for inserting array relation for remote table "company_translations"
input company_translations_arr_rel_insert_input {
  data: [company_translations_insert_input!]!
  on_conflict: company_translations_on_conflict
}

# Boolean expression to filter rows from the table "company_translations". All fields are combined with a logical 'AND'.
input company_translations_bool_exp {
  _and: [company_translations_bool_exp]
  _not: company_translations_bool_exp
  _or: [company_translations_bool_exp]
  bio: String_comparison_exp
  id: uuid_comparison_exp
  is_release: Boolean_comparison_exp
  revision: company_translation_revisions_bool_exp
  revision_id: uuid_comparison_exp
  short_name: String_comparison_exp
  stylised_name: String_comparison_exp
}

# unique or primary key constraints on table "company_translations"
enum company_translations_constraint {
  # unique or primary key constraint
  company_translations_pkey

  # unique or primary key constraint
  company_translations_revision_id_is_release_key
}

# input type for inserting data into table "company_translations"
input company_translations_insert_input {
  bio: String
  id: uuid
  is_release: Boolean
  revision: company_translation_revisions_obj_rel_insert_input
  revision_id: uuid
  short_name: String
  stylised_name: String
}

# aggregate max on columns
type company_translations_max_fields {
  bio: String
  id: uuid
  revision_id: uuid
  short_name: String
  stylised_name: String
}

# order by max() on columns of table "company_translations"
input company_translations_max_order_by {
  bio: order_by
  id: order_by
  revision_id: order_by
  short_name: order_by
  stylised_name: order_by
}

# aggregate min on columns
type company_translations_min_fields {
  bio: String
  id: uuid
  revision_id: uuid
  short_name: String
  stylised_name: String
}

# order by min() on columns of table "company_translations"
input company_translations_min_order_by {
  bio: order_by
  id: order_by
  revision_id: order_by
  short_name: order_by
  stylised_name: order_by
}

# response of any mutation on the table "company_translations"
type company_translations_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [company_translations!]!
}

# input type for inserting object relation for remote table "company_translations"
input company_translations_obj_rel_insert_input {
  data: company_translations_insert_input!
  on_conflict: company_translations_on_conflict
}

# on conflict condition type for table "company_translations"
input company_translations_on_conflict {
  constraint: company_translations_constraint!
  update_columns: [company_translations_update_column!]!
  where: company_translations_bool_exp
}

# ordering options when selecting data from "company_translations"
input company_translations_order_by {
  bio: order_by
  id: order_by
  is_release: order_by
  revision: company_translation_revisions_order_by
  revision_id: order_by
  short_name: order_by
  stylised_name: order_by
}

# primary key columns input for table: "company_translations"
input company_translations_pk_columns_input {
  id: uuid!
}

# select columns of table "company_translations"
enum company_translations_select_column {
  # column name
  bio

  # column name
  id

  # column name
  is_release

  # column name
  revision_id

  # column name
  short_name

  # column name
  stylised_name
}

# input type for updating data in table "company_translations"
input company_translations_set_input {
  bio: String
  id: uuid
  is_release: Boolean
  revision_id: uuid
  short_name: String
  stylised_name: String
}

# update columns of table "company_translations"
enum company_translations_update_column {
  # column name
  bio

  # column name
  id

  # column name
  is_release

  # column name
  revision_id

  # column name
  short_name

  # column name
  stylised_name
}

# The list of all the countries of the world, according to the ISO 3166 and ISO 3166-1 standards.
#
#
# columns and relationships of "countries"
#
type countries {
  # In this enum implementation, the description is the country name (in English),
  # mostly according to ISO 3166-1 with some exceptions (some names being made short).
  description: String!

  # In this enum implementation, the value is the 2-letter Alpha-2 code of the country, according to ISO 3166-1.
  value: String!
}

# aggregated selection of "countries"
type countries_aggregate {
  aggregate: countries_aggregate_fields
  nodes: [countries!]!
}

# aggregate fields of "countries"
type countries_aggregate_fields {
  count(columns: [countries_select_column!], distinct: Boolean): Int
  max: countries_max_fields
  min: countries_min_fields
}

# order by aggregate values of table "countries"
input countries_aggregate_order_by {
  count: order_by
  max: countries_max_order_by
  min: countries_min_order_by
}

# input type for inserting array relation for remote table "countries"
input countries_arr_rel_insert_input {
  data: [countries_insert_input!]!
  on_conflict: countries_on_conflict
}

# Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'.
input countries_bool_exp {
  _and: [countries_bool_exp]
  _not: countries_bool_exp
  _or: [countries_bool_exp]
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "countries"
enum countries_constraint {
  # unique or primary key constraint
  countries_pkey
}

enum countries_enum {
  #  United Arab Emirates
  AE

  #  Austria
  AT

  #  Australia
  AU

  #  Bangladesh
  BD

  #  Belgium
  BE

  #  Brazil
  BR

  #  Canada
  CA

  #  China
  CN

  #  Germany
  DE

  #  Denmark
  DK

  #  Spain
  ES

  #  Finland
  FI

  #  France
  FR

  #  United Kingdom
  GB

  #  Greece
  GR

  #  Hong Kong
  HK

  #  Indonesia
  ID

  #  Ireland
  IE

  #  India
  IN

  #  Italy
  IT

  #  Japan
  JP

  #  Cambodia
  KH

  #  South Korea
  KR

  #  Sri Lanka
  LK

  #  Morocco
  MA

  #  Myanmar (Burma)
  MM

  #  Mexico
  MX

  #  Malaysia
  MY

  #  Netherlands
  NL

  #  Norway
  NO

  #  New Zealand
  NZ

  #  Pakistan
  PK

  #  Poland
  PL

  #  Portugal
  PT

  #  Russia
  RU

  #  Sweden
  SE

  #  Singapore
  SG

  #  Thailand
  TH

  #  Turkey
  TR

  #  Taiwan
  TW

  #  United States
  US

  #  Vietnam
  VN

  #  South Africa
  ZA
}

# expression to compare columns of type countries_enum. All fields are combined with logical 'AND'.
input countries_enum_comparison_exp {
  _eq: countries_enum
  _in: [countries_enum!]
  _is_null: Boolean
  _neq: countries_enum
  _nin: [countries_enum!]
}

# input type for inserting data into table "countries"
input countries_insert_input {
  description: String
  value: String
}

# aggregate max on columns
type countries_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "countries"
input countries_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type countries_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "countries"
input countries_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "countries"
type countries_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [countries!]!
}

# input type for inserting object relation for remote table "countries"
input countries_obj_rel_insert_input {
  data: countries_insert_input!
  on_conflict: countries_on_conflict
}

# on conflict condition type for table "countries"
input countries_on_conflict {
  constraint: countries_constraint!
  update_columns: [countries_update_column!]!
  where: countries_bool_exp
}

# ordering options when selecting data from "countries"
input countries_order_by {
  description: order_by
  value: order_by
}

# primary key columns input for table: "countries"
input countries_pk_columns_input {
  # In this enum implementation, the value is the 2-letter Alpha-2 code of the country, according to ISO 3166-1.
  value: String!
}

# select columns of table "countries"
enum countries_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "countries"
input countries_set_input {
  description: String
  value: String
}

# update columns of table "countries"
enum countries_update_column {
  # column name
  description

  # column name
  value
}

# The actions that a user can take with regards to a data entry in the CMS.
#
#
# columns and relationships of "data_actions"
#
type data_actions {
  value: String!
}

# aggregated selection of "data_actions"
type data_actions_aggregate {
  aggregate: data_actions_aggregate_fields
  nodes: [data_actions!]!
}

# aggregate fields of "data_actions"
type data_actions_aggregate_fields {
  count(columns: [data_actions_select_column!], distinct: Boolean): Int
  max: data_actions_max_fields
  min: data_actions_min_fields
}

# order by aggregate values of table "data_actions"
input data_actions_aggregate_order_by {
  count: order_by
  max: data_actions_max_order_by
  min: data_actions_min_order_by
}

# input type for inserting array relation for remote table "data_actions"
input data_actions_arr_rel_insert_input {
  data: [data_actions_insert_input!]!
  on_conflict: data_actions_on_conflict
}

# Boolean expression to filter rows from the table "data_actions". All fields are combined with a logical 'AND'.
input data_actions_bool_exp {
  _and: [data_actions_bool_exp]
  _not: data_actions_bool_exp
  _or: [data_actions_bool_exp]
  value: String_comparison_exp
}

# unique or primary key constraints on table "data_actions"
enum data_actions_constraint {
  # unique or primary key constraint
  data_actions_pkey
}

enum data_actions_enum {
  Create
  Delete
  Update
}

# expression to compare columns of type data_actions_enum. All fields are combined with logical 'AND'.
input data_actions_enum_comparison_exp {
  _eq: data_actions_enum
  _in: [data_actions_enum!]
  _is_null: Boolean
  _neq: data_actions_enum
  _nin: [data_actions_enum!]
}

# input type for inserting data into table "data_actions"
input data_actions_insert_input {
  value: String
}

# aggregate max on columns
type data_actions_max_fields {
  value: String
}

# order by max() on columns of table "data_actions"
input data_actions_max_order_by {
  value: order_by
}

# aggregate min on columns
type data_actions_min_fields {
  value: String
}

# order by min() on columns of table "data_actions"
input data_actions_min_order_by {
  value: order_by
}

# response of any mutation on the table "data_actions"
type data_actions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [data_actions!]!
}

# input type for inserting object relation for remote table "data_actions"
input data_actions_obj_rel_insert_input {
  data: data_actions_insert_input!
  on_conflict: data_actions_on_conflict
}

# on conflict condition type for table "data_actions"
input data_actions_on_conflict {
  constraint: data_actions_constraint!
  update_columns: [data_actions_update_column!]!
  where: data_actions_bool_exp
}

# ordering options when selecting data from "data_actions"
input data_actions_order_by {
  value: order_by
}

# primary key columns input for table: "data_actions"
input data_actions_pk_columns_input {
  value: String!
}

# select columns of table "data_actions"
enum data_actions_select_column {
  # column name
  value
}

# input type for updating data in table "data_actions"
input data_actions_set_input {
  value: String
}

# update columns of table "data_actions"
enum data_actions_update_column {
  # column name
  value
}

# The types of changes that can be made for data entries within the CMS.
#
#
# columns and relationships of "data_change_types"
#
type data_change_types {
  value: String!
}

# aggregated selection of "data_change_types"
type data_change_types_aggregate {
  aggregate: data_change_types_aggregate_fields
  nodes: [data_change_types!]!
}

# aggregate fields of "data_change_types"
type data_change_types_aggregate_fields {
  count(columns: [data_change_types_select_column!], distinct: Boolean): Int
  max: data_change_types_max_fields
  min: data_change_types_min_fields
}

# order by aggregate values of table "data_change_types"
input data_change_types_aggregate_order_by {
  count: order_by
  max: data_change_types_max_order_by
  min: data_change_types_min_order_by
}

# input type for inserting array relation for remote table "data_change_types"
input data_change_types_arr_rel_insert_input {
  data: [data_change_types_insert_input!]!
  on_conflict: data_change_types_on_conflict
}

# Boolean expression to filter rows from the table "data_change_types". All fields are combined with a logical 'AND'.
input data_change_types_bool_exp {
  _and: [data_change_types_bool_exp]
  _not: data_change_types_bool_exp
  _or: [data_change_types_bool_exp]
  value: String_comparison_exp
}

# unique or primary key constraints on table "data_change_types"
enum data_change_types_constraint {
  # unique or primary key constraint
  data_change_types_pkey
}

enum data_change_types_enum {
  Action
  Demotion
  Promotion
}

# expression to compare columns of type data_change_types_enum. All fields are combined with logical 'AND'.
input data_change_types_enum_comparison_exp {
  _eq: data_change_types_enum
  _in: [data_change_types_enum!]
  _is_null: Boolean
  _neq: data_change_types_enum
  _nin: [data_change_types_enum!]
}

# input type for inserting data into table "data_change_types"
input data_change_types_insert_input {
  value: String
}

# aggregate max on columns
type data_change_types_max_fields {
  value: String
}

# order by max() on columns of table "data_change_types"
input data_change_types_max_order_by {
  value: order_by
}

# aggregate min on columns
type data_change_types_min_fields {
  value: String
}

# order by min() on columns of table "data_change_types"
input data_change_types_min_order_by {
  value: order_by
}

# response of any mutation on the table "data_change_types"
type data_change_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [data_change_types!]!
}

# input type for inserting object relation for remote table "data_change_types"
input data_change_types_obj_rel_insert_input {
  data: data_change_types_insert_input!
  on_conflict: data_change_types_on_conflict
}

# on conflict condition type for table "data_change_types"
input data_change_types_on_conflict {
  constraint: data_change_types_constraint!
  update_columns: [data_change_types_update_column!]!
  where: data_change_types_bool_exp
}

# ordering options when selecting data from "data_change_types"
input data_change_types_order_by {
  value: order_by
}

# primary key columns input for table: "data_change_types"
input data_change_types_pk_columns_input {
  value: String!
}

# select columns of table "data_change_types"
enum data_change_types_select_column {
  # column name
  value
}

# input type for updating data in table "data_change_types"
input data_change_types_set_input {
  value: String
}

# update columns of table "data_change_types"
enum data_change_types_update_column {
  # column name
  value
}

# Information about data entry promotions (within the CMS), such as the target
# state, the responsible user, the date, the data type, etc.
#
#
# columns and relationships of "data_promotions"
#
type data_promotions {
  data_promotable_type: String!
  date: timestamptz!
  id: Int!
  item_translation_id: uuid
  item_translation_revision_id: uuid
  to_state: data_states_enum!
}

# aggregated selection of "data_promotions"
type data_promotions_aggregate {
  aggregate: data_promotions_aggregate_fields
  nodes: [data_promotions!]!
}

# aggregate fields of "data_promotions"
type data_promotions_aggregate_fields {
  avg: data_promotions_avg_fields
  count(columns: [data_promotions_select_column!], distinct: Boolean): Int
  max: data_promotions_max_fields
  min: data_promotions_min_fields
  stddev: data_promotions_stddev_fields
  stddev_pop: data_promotions_stddev_pop_fields
  stddev_samp: data_promotions_stddev_samp_fields
  sum: data_promotions_sum_fields
  var_pop: data_promotions_var_pop_fields
  var_samp: data_promotions_var_samp_fields
  variance: data_promotions_variance_fields
}

# order by aggregate values of table "data_promotions"
input data_promotions_aggregate_order_by {
  avg: data_promotions_avg_order_by
  count: order_by
  max: data_promotions_max_order_by
  min: data_promotions_min_order_by
  stddev: data_promotions_stddev_order_by
  stddev_pop: data_promotions_stddev_pop_order_by
  stddev_samp: data_promotions_stddev_samp_order_by
  sum: data_promotions_sum_order_by
  var_pop: data_promotions_var_pop_order_by
  var_samp: data_promotions_var_samp_order_by
  variance: data_promotions_variance_order_by
}

# input type for inserting array relation for remote table "data_promotions"
input data_promotions_arr_rel_insert_input {
  data: [data_promotions_insert_input!]!
  on_conflict: data_promotions_on_conflict
}

# aggregate avg on columns
type data_promotions_avg_fields {
  id: Float
}

# order by avg() on columns of table "data_promotions"
input data_promotions_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "data_promotions". All fields are combined with a logical 'AND'.
input data_promotions_bool_exp {
  _and: [data_promotions_bool_exp]
  _not: data_promotions_bool_exp
  _or: [data_promotions_bool_exp]
  data_promotable_type: String_comparison_exp
  date: timestamptz_comparison_exp
  id: Int_comparison_exp
  item_translation_id: uuid_comparison_exp
  item_translation_revision_id: uuid_comparison_exp
  to_state: data_states_enum_comparison_exp
}

# unique or primary key constraints on table "data_promotions"
enum data_promotions_constraint {
  # unique or primary key constraint
  data_promotions_pkey

  # unique or primary key constraint
  data_promotions_to_state_data_promotable_type_item_translation_
}

# input type for incrementing integer column in table "data_promotions"
input data_promotions_inc_input {
  id: Int
}

# input type for inserting data into table "data_promotions"
input data_promotions_insert_input {
  data_promotable_type: String
  date: timestamptz
  id: Int
  item_translation_id: uuid
  item_translation_revision_id: uuid
  to_state: data_states_enum
}

# aggregate max on columns
type data_promotions_max_fields {
  data_promotable_type: String
  date: timestamptz
  id: Int
  item_translation_id: uuid
  item_translation_revision_id: uuid
}

# order by max() on columns of table "data_promotions"
input data_promotions_max_order_by {
  data_promotable_type: order_by
  date: order_by
  id: order_by
  item_translation_id: order_by
  item_translation_revision_id: order_by
}

# aggregate min on columns
type data_promotions_min_fields {
  data_promotable_type: String
  date: timestamptz
  id: Int
  item_translation_id: uuid
  item_translation_revision_id: uuid
}

# order by min() on columns of table "data_promotions"
input data_promotions_min_order_by {
  data_promotable_type: order_by
  date: order_by
  id: order_by
  item_translation_id: order_by
  item_translation_revision_id: order_by
}

# response of any mutation on the table "data_promotions"
type data_promotions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [data_promotions!]!
}

# input type for inserting object relation for remote table "data_promotions"
input data_promotions_obj_rel_insert_input {
  data: data_promotions_insert_input!
  on_conflict: data_promotions_on_conflict
}

# on conflict condition type for table "data_promotions"
input data_promotions_on_conflict {
  constraint: data_promotions_constraint!
  update_columns: [data_promotions_update_column!]!
  where: data_promotions_bool_exp
}

# ordering options when selecting data from "data_promotions"
input data_promotions_order_by {
  data_promotable_type: order_by
  date: order_by
  id: order_by
  item_translation_id: order_by
  item_translation_revision_id: order_by
  to_state: order_by
}

# primary key columns input for table: "data_promotions"
input data_promotions_pk_columns_input {
  id: Int!
}

# select columns of table "data_promotions"
enum data_promotions_select_column {
  # column name
  data_promotable_type

  # column name
  date

  # column name
  id

  # column name
  item_translation_id

  # column name
  item_translation_revision_id

  # column name
  to_state
}

# input type for updating data in table "data_promotions"
input data_promotions_set_input {
  data_promotable_type: String
  date: timestamptz
  id: Int
  item_translation_id: uuid
  item_translation_revision_id: uuid
  to_state: data_states_enum
}

# aggregate stddev on columns
type data_promotions_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "data_promotions"
input data_promotions_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type data_promotions_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "data_promotions"
input data_promotions_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type data_promotions_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "data_promotions"
input data_promotions_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type data_promotions_sum_fields {
  id: Int
}

# order by sum() on columns of table "data_promotions"
input data_promotions_sum_order_by {
  id: order_by
}

# update columns of table "data_promotions"
enum data_promotions_update_column {
  # column name
  data_promotable_type

  # column name
  date

  # column name
  id

  # column name
  item_translation_id

  # column name
  item_translation_revision_id

  # column name
  to_state
}

# aggregate var_pop on columns
type data_promotions_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "data_promotions"
input data_promotions_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type data_promotions_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "data_promotions"
input data_promotions_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type data_promotions_variance_fields {
  id: Float
}

# order by variance() on columns of table "data_promotions"
input data_promotions_variance_order_by {
  id: order_by
}

# The type a data entry or translation can be released to end users in.
#
#
# columns and relationships of "data_release_types"
#
type data_release_types {
  value: String!
}

# aggregated selection of "data_release_types"
type data_release_types_aggregate {
  aggregate: data_release_types_aggregate_fields
  nodes: [data_release_types!]!
}

# aggregate fields of "data_release_types"
type data_release_types_aggregate_fields {
  count(columns: [data_release_types_select_column!], distinct: Boolean): Int
  max: data_release_types_max_fields
  min: data_release_types_min_fields
}

# order by aggregate values of table "data_release_types"
input data_release_types_aggregate_order_by {
  count: order_by
  max: data_release_types_max_order_by
  min: data_release_types_min_order_by
}

# input type for inserting array relation for remote table "data_release_types"
input data_release_types_arr_rel_insert_input {
  data: [data_release_types_insert_input!]!
  on_conflict: data_release_types_on_conflict
}

# Boolean expression to filter rows from the table "data_release_types". All fields are combined with a logical 'AND'.
input data_release_types_bool_exp {
  _and: [data_release_types_bool_exp]
  _not: data_release_types_bool_exp
  _or: [data_release_types_bool_exp]
  value: String_comparison_exp
}

# unique or primary key constraints on table "data_release_types"
enum data_release_types_constraint {
  # unique or primary key constraint
  release_type_pkey
}

# input type for inserting data into table "data_release_types"
input data_release_types_insert_input {
  value: String
}

# aggregate max on columns
type data_release_types_max_fields {
  value: String
}

# order by max() on columns of table "data_release_types"
input data_release_types_max_order_by {
  value: order_by
}

# aggregate min on columns
type data_release_types_min_fields {
  value: String
}

# order by min() on columns of table "data_release_types"
input data_release_types_min_order_by {
  value: order_by
}

# response of any mutation on the table "data_release_types"
type data_release_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [data_release_types!]!
}

# input type for inserting object relation for remote table "data_release_types"
input data_release_types_obj_rel_insert_input {
  data: data_release_types_insert_input!
  on_conflict: data_release_types_on_conflict
}

# on conflict condition type for table "data_release_types"
input data_release_types_on_conflict {
  constraint: data_release_types_constraint!
  update_columns: [data_release_types_update_column!]!
  where: data_release_types_bool_exp
}

# ordering options when selecting data from "data_release_types"
input data_release_types_order_by {
  value: order_by
}

# primary key columns input for table: "data_release_types"
input data_release_types_pk_columns_input {
  value: String!
}

# select columns of table "data_release_types"
enum data_release_types_select_column {
  # column name
  value
}

# input type for updating data in table "data_release_types"
input data_release_types_set_input {
  value: String
}

# update columns of table "data_release_types"
enum data_release_types_update_column {
  # column name
  value
}

# columns and relationships of "data_states"
type data_states {
  value: String!
}

# aggregated selection of "data_states"
type data_states_aggregate {
  aggregate: data_states_aggregate_fields
  nodes: [data_states!]!
}

# aggregate fields of "data_states"
type data_states_aggregate_fields {
  count(columns: [data_states_select_column!], distinct: Boolean): Int
  max: data_states_max_fields
  min: data_states_min_fields
}

# order by aggregate values of table "data_states"
input data_states_aggregate_order_by {
  count: order_by
  max: data_states_max_order_by
  min: data_states_min_order_by
}

# input type for inserting array relation for remote table "data_states"
input data_states_arr_rel_insert_input {
  data: [data_states_insert_input!]!
  on_conflict: data_states_on_conflict
}

# Boolean expression to filter rows from the table "data_states". All fields are combined with a logical 'AND'.
input data_states_bool_exp {
  _and: [data_states_bool_exp]
  _not: data_states_bool_exp
  _or: [data_states_bool_exp]
  value: String_comparison_exp
}

# unique or primary key constraints on table "data_states"
enum data_states_constraint {
  # unique or primary key constraint
  data_states_pkey
}

enum data_states_enum {
  Development
  Production
  Retired
  Review
}

# expression to compare columns of type data_states_enum. All fields are combined with logical 'AND'.
input data_states_enum_comparison_exp {
  _eq: data_states_enum
  _in: [data_states_enum!]
  _is_null: Boolean
  _neq: data_states_enum
  _nin: [data_states_enum!]
}

# input type for inserting data into table "data_states"
input data_states_insert_input {
  value: String
}

# aggregate max on columns
type data_states_max_fields {
  value: String
}

# order by max() on columns of table "data_states"
input data_states_max_order_by {
  value: order_by
}

# aggregate min on columns
type data_states_min_fields {
  value: String
}

# order by min() on columns of table "data_states"
input data_states_min_order_by {
  value: order_by
}

# response of any mutation on the table "data_states"
type data_states_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [data_states!]!
}

# input type for inserting object relation for remote table "data_states"
input data_states_obj_rel_insert_input {
  data: data_states_insert_input!
  on_conflict: data_states_on_conflict
}

# on conflict condition type for table "data_states"
input data_states_on_conflict {
  constraint: data_states_constraint!
  update_columns: [data_states_update_column!]!
  where: data_states_bool_exp
}

# ordering options when selecting data from "data_states"
input data_states_order_by {
  value: order_by
}

# primary key columns input for table: "data_states"
input data_states_pk_columns_input {
  value: String!
}

# select columns of table "data_states"
enum data_states_select_column {
  # column name
  value
}

# input type for updating data in table "data_states"
input data_states_set_input {
  value: String
}

# update columns of table "data_states"
enum data_states_update_column {
  # column name
  value
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

# columns and relationships of "fabric_layer_and_colour_mix_part"
type fabric_layer_and_colour_mix_part {
  # An object relationship
  colour_mix_part: colour_mix_parts!
  colour_mix_part_id: Int!

  # An object relationship
  fabric_layer: fabric_layers!
  fabric_layer_id: Int!
}

# aggregated selection of "fabric_layer_and_colour_mix_part"
type fabric_layer_and_colour_mix_part_aggregate {
  aggregate: fabric_layer_and_colour_mix_part_aggregate_fields
  nodes: [fabric_layer_and_colour_mix_part!]!
}

# aggregate fields of "fabric_layer_and_colour_mix_part"
type fabric_layer_and_colour_mix_part_aggregate_fields {
  avg: fabric_layer_and_colour_mix_part_avg_fields
  count(columns: [fabric_layer_and_colour_mix_part_select_column!], distinct: Boolean): Int
  max: fabric_layer_and_colour_mix_part_max_fields
  min: fabric_layer_and_colour_mix_part_min_fields
  stddev: fabric_layer_and_colour_mix_part_stddev_fields
  stddev_pop: fabric_layer_and_colour_mix_part_stddev_pop_fields
  stddev_samp: fabric_layer_and_colour_mix_part_stddev_samp_fields
  sum: fabric_layer_and_colour_mix_part_sum_fields
  var_pop: fabric_layer_and_colour_mix_part_var_pop_fields
  var_samp: fabric_layer_and_colour_mix_part_var_samp_fields
  variance: fabric_layer_and_colour_mix_part_variance_fields
}

# order by aggregate values of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_aggregate_order_by {
  avg: fabric_layer_and_colour_mix_part_avg_order_by
  count: order_by
  max: fabric_layer_and_colour_mix_part_max_order_by
  min: fabric_layer_and_colour_mix_part_min_order_by
  stddev: fabric_layer_and_colour_mix_part_stddev_order_by
  stddev_pop: fabric_layer_and_colour_mix_part_stddev_pop_order_by
  stddev_samp: fabric_layer_and_colour_mix_part_stddev_samp_order_by
  sum: fabric_layer_and_colour_mix_part_sum_order_by
  var_pop: fabric_layer_and_colour_mix_part_var_pop_order_by
  var_samp: fabric_layer_and_colour_mix_part_var_samp_order_by
  variance: fabric_layer_and_colour_mix_part_variance_order_by
}

# input type for inserting array relation for remote table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_arr_rel_insert_input {
  data: [fabric_layer_and_colour_mix_part_insert_input!]!
  on_conflict: fabric_layer_and_colour_mix_part_on_conflict
}

# aggregate avg on columns
type fabric_layer_and_colour_mix_part_avg_fields {
  colour_mix_part_id: Float
  fabric_layer_id: Float
}

# order by avg() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_avg_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# Boolean expression to filter rows from the table
# "fabric_layer_and_colour_mix_part". All fields are combined with a logical 'AND'.
input fabric_layer_and_colour_mix_part_bool_exp {
  _and: [fabric_layer_and_colour_mix_part_bool_exp]
  _not: fabric_layer_and_colour_mix_part_bool_exp
  _or: [fabric_layer_and_colour_mix_part_bool_exp]
  colour_mix_part: colour_mix_parts_bool_exp
  colour_mix_part_id: Int_comparison_exp
  fabric_layer: fabric_layers_bool_exp
  fabric_layer_id: Int_comparison_exp
}

# unique or primary key constraints on table "fabric_layer_and_colour_mix_part"
enum fabric_layer_and_colour_mix_part_constraint {
  # unique or primary key constraint
  fabric_layer_and_colour_mix_part_pkey
}

# input type for incrementing integer column in table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_inc_input {
  colour_mix_part_id: Int
  fabric_layer_id: Int
}

# input type for inserting data into table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_insert_input {
  colour_mix_part: colour_mix_parts_obj_rel_insert_input
  colour_mix_part_id: Int
  fabric_layer: fabric_layers_obj_rel_insert_input
  fabric_layer_id: Int
}

# aggregate max on columns
type fabric_layer_and_colour_mix_part_max_fields {
  colour_mix_part_id: Int
  fabric_layer_id: Int
}

# order by max() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_max_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# aggregate min on columns
type fabric_layer_and_colour_mix_part_min_fields {
  colour_mix_part_id: Int
  fabric_layer_id: Int
}

# order by min() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_min_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# response of any mutation on the table "fabric_layer_and_colour_mix_part"
type fabric_layer_and_colour_mix_part_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [fabric_layer_and_colour_mix_part!]!
}

# input type for inserting object relation for remote table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_obj_rel_insert_input {
  data: fabric_layer_and_colour_mix_part_insert_input!
  on_conflict: fabric_layer_and_colour_mix_part_on_conflict
}

# on conflict condition type for table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_on_conflict {
  constraint: fabric_layer_and_colour_mix_part_constraint!
  update_columns: [fabric_layer_and_colour_mix_part_update_column!]!
  where: fabric_layer_and_colour_mix_part_bool_exp
}

# ordering options when selecting data from "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_order_by {
  colour_mix_part: colour_mix_parts_order_by
  colour_mix_part_id: order_by
  fabric_layer: fabric_layers_order_by
  fabric_layer_id: order_by
}

# primary key columns input for table: "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_pk_columns_input {
  colour_mix_part_id: Int!
  fabric_layer_id: Int!
}

# select columns of table "fabric_layer_and_colour_mix_part"
enum fabric_layer_and_colour_mix_part_select_column {
  # column name
  colour_mix_part_id

  # column name
  fabric_layer_id
}

# input type for updating data in table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_set_input {
  colour_mix_part_id: Int
  fabric_layer_id: Int
}

# aggregate stddev on columns
type fabric_layer_and_colour_mix_part_stddev_fields {
  colour_mix_part_id: Float
  fabric_layer_id: Float
}

# order by stddev() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_stddev_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# aggregate stddev_pop on columns
type fabric_layer_and_colour_mix_part_stddev_pop_fields {
  colour_mix_part_id: Float
  fabric_layer_id: Float
}

# order by stddev_pop() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_stddev_pop_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# aggregate stddev_samp on columns
type fabric_layer_and_colour_mix_part_stddev_samp_fields {
  colour_mix_part_id: Float
  fabric_layer_id: Float
}

# order by stddev_samp() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_stddev_samp_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# aggregate sum on columns
type fabric_layer_and_colour_mix_part_sum_fields {
  colour_mix_part_id: Int
  fabric_layer_id: Int
}

# order by sum() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_sum_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# update columns of table "fabric_layer_and_colour_mix_part"
enum fabric_layer_and_colour_mix_part_update_column {
  # column name
  colour_mix_part_id

  # column name
  fabric_layer_id
}

# aggregate var_pop on columns
type fabric_layer_and_colour_mix_part_var_pop_fields {
  colour_mix_part_id: Float
  fabric_layer_id: Float
}

# order by var_pop() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_var_pop_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# aggregate var_samp on columns
type fabric_layer_and_colour_mix_part_var_samp_fields {
  colour_mix_part_id: Float
  fabric_layer_id: Float
}

# order by var_samp() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_var_samp_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# aggregate variance on columns
type fabric_layer_and_colour_mix_part_variance_fields {
  colour_mix_part_id: Float
  fabric_layer_id: Float
}

# order by variance() on columns of table "fabric_layer_and_colour_mix_part"
input fabric_layer_and_colour_mix_part_variance_order_by {
  colour_mix_part_id: order_by
  fabric_layer_id: order_by
}

# columns and relationships of "fabric_layer_types"
type fabric_layer_types {
  description: String

  # An array relationship
  fabric_layers(
    # distinct select on columns
    distinct_on: [fabric_layers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layers_order_by!]

    # filter the rows returned
    where: fabric_layers_bool_exp
  ): [fabric_layers!]!

  # An aggregated array relationship
  fabric_layers_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layers_order_by!]

    # filter the rows returned
    where: fabric_layers_bool_exp
  ): fabric_layers_aggregate!
  value: String!
}

# aggregated selection of "fabric_layer_types"
type fabric_layer_types_aggregate {
  aggregate: fabric_layer_types_aggregate_fields
  nodes: [fabric_layer_types!]!
}

# aggregate fields of "fabric_layer_types"
type fabric_layer_types_aggregate_fields {
  count(columns: [fabric_layer_types_select_column!], distinct: Boolean): Int
  max: fabric_layer_types_max_fields
  min: fabric_layer_types_min_fields
}

# order by aggregate values of table "fabric_layer_types"
input fabric_layer_types_aggregate_order_by {
  count: order_by
  max: fabric_layer_types_max_order_by
  min: fabric_layer_types_min_order_by
}

# input type for inserting array relation for remote table "fabric_layer_types"
input fabric_layer_types_arr_rel_insert_input {
  data: [fabric_layer_types_insert_input!]!
  on_conflict: fabric_layer_types_on_conflict
}

# Boolean expression to filter rows from the table "fabric_layer_types". All fields are combined with a logical 'AND'.
input fabric_layer_types_bool_exp {
  _and: [fabric_layer_types_bool_exp]
  _not: fabric_layer_types_bool_exp
  _or: [fabric_layer_types_bool_exp]
  description: String_comparison_exp
  fabric_layers: fabric_layers_bool_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "fabric_layer_types"
enum fabric_layer_types_constraint {
  # unique or primary key constraint
  fabric_layer_types_pkey
}

enum fabric_layer_types_enum {
  Fill
  Interlining
  Lining
  Shell
}

# expression to compare columns of type fabric_layer_types_enum. All fields are combined with logical 'AND'.
input fabric_layer_types_enum_comparison_exp {
  _eq: fabric_layer_types_enum
  _in: [fabric_layer_types_enum!]
  _is_null: Boolean
  _neq: fabric_layer_types_enum
  _nin: [fabric_layer_types_enum!]
}

# input type for inserting data into table "fabric_layer_types"
input fabric_layer_types_insert_input {
  description: String
  fabric_layers: fabric_layers_arr_rel_insert_input
  value: String
}

# aggregate max on columns
type fabric_layer_types_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "fabric_layer_types"
input fabric_layer_types_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type fabric_layer_types_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "fabric_layer_types"
input fabric_layer_types_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "fabric_layer_types"
type fabric_layer_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [fabric_layer_types!]!
}

# input type for inserting object relation for remote table "fabric_layer_types"
input fabric_layer_types_obj_rel_insert_input {
  data: fabric_layer_types_insert_input!
  on_conflict: fabric_layer_types_on_conflict
}

# on conflict condition type for table "fabric_layer_types"
input fabric_layer_types_on_conflict {
  constraint: fabric_layer_types_constraint!
  update_columns: [fabric_layer_types_update_column!]!
  where: fabric_layer_types_bool_exp
}

# ordering options when selecting data from "fabric_layer_types"
input fabric_layer_types_order_by {
  description: order_by
  fabric_layers_aggregate: fabric_layers_aggregate_order_by
  value: order_by
}

# primary key columns input for table: "fabric_layer_types"
input fabric_layer_types_pk_columns_input {
  value: String!
}

# select columns of table "fabric_layer_types"
enum fabric_layer_types_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "fabric_layer_types"
input fabric_layer_types_set_input {
  description: String
  value: String
}

# update columns of table "fabric_layer_types"
enum fabric_layer_types_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "fabric_layers"
type fabric_layers {
  created_at: timestamptz
  density: Int

  # An array relationship
  fabric_layer_and_colour_mix_parts(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): [fabric_layer_and_colour_mix_part!]!

  # An aggregated array relationship
  fabric_layer_and_colour_mix_parts_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): fabric_layer_and_colour_mix_part_aggregate!
  fabric_layer_type: fabric_layer_types_enum
  id: Int!
  insulation: numeric
  permeability: Int
  thickness: numeric
  type: String
  updated_at: timestamptz
}

# aggregated selection of "fabric_layers"
type fabric_layers_aggregate {
  aggregate: fabric_layers_aggregate_fields
  nodes: [fabric_layers!]!
}

# aggregate fields of "fabric_layers"
type fabric_layers_aggregate_fields {
  avg: fabric_layers_avg_fields
  count(columns: [fabric_layers_select_column!], distinct: Boolean): Int
  max: fabric_layers_max_fields
  min: fabric_layers_min_fields
  stddev: fabric_layers_stddev_fields
  stddev_pop: fabric_layers_stddev_pop_fields
  stddev_samp: fabric_layers_stddev_samp_fields
  sum: fabric_layers_sum_fields
  var_pop: fabric_layers_var_pop_fields
  var_samp: fabric_layers_var_samp_fields
  variance: fabric_layers_variance_fields
}

# order by aggregate values of table "fabric_layers"
input fabric_layers_aggregate_order_by {
  avg: fabric_layers_avg_order_by
  count: order_by
  max: fabric_layers_max_order_by
  min: fabric_layers_min_order_by
  stddev: fabric_layers_stddev_order_by
  stddev_pop: fabric_layers_stddev_pop_order_by
  stddev_samp: fabric_layers_stddev_samp_order_by
  sum: fabric_layers_sum_order_by
  var_pop: fabric_layers_var_pop_order_by
  var_samp: fabric_layers_var_samp_order_by
  variance: fabric_layers_variance_order_by
}

# input type for inserting array relation for remote table "fabric_layers"
input fabric_layers_arr_rel_insert_input {
  data: [fabric_layers_insert_input!]!
  on_conflict: fabric_layers_on_conflict
}

# aggregate avg on columns
type fabric_layers_avg_fields {
  density: Float
  id: Float
  insulation: Float
  permeability: Float
  thickness: Float
}

# order by avg() on columns of table "fabric_layers"
input fabric_layers_avg_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# Boolean expression to filter rows from the table "fabric_layers". All fields are combined with a logical 'AND'.
input fabric_layers_bool_exp {
  _and: [fabric_layers_bool_exp]
  _not: fabric_layers_bool_exp
  _or: [fabric_layers_bool_exp]
  created_at: timestamptz_comparison_exp
  density: Int_comparison_exp
  fabric_layer_and_colour_mix_parts: fabric_layer_and_colour_mix_part_bool_exp
  fabric_layer_type: fabric_layer_types_enum_comparison_exp
  id: Int_comparison_exp
  insulation: numeric_comparison_exp
  permeability: Int_comparison_exp
  thickness: numeric_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "fabric_layers"
enum fabric_layers_constraint {
  # unique or primary key constraint
  fabric_layers_pkey
}

# input type for incrementing integer column in table "fabric_layers"
input fabric_layers_inc_input {
  density: Int
  id: Int
  insulation: numeric
  permeability: Int
  thickness: numeric
}

# input type for inserting data into table "fabric_layers"
input fabric_layers_insert_input {
  created_at: timestamptz
  density: Int
  fabric_layer_and_colour_mix_parts: fabric_layer_and_colour_mix_part_arr_rel_insert_input
  fabric_layer_type: fabric_layer_types_enum
  id: Int
  insulation: numeric
  permeability: Int
  thickness: numeric
  type: String
  updated_at: timestamptz
}

# aggregate max on columns
type fabric_layers_max_fields {
  created_at: timestamptz
  density: Int
  id: Int
  insulation: numeric
  permeability: Int
  thickness: numeric
  type: String
  updated_at: timestamptz
}

# order by max() on columns of table "fabric_layers"
input fabric_layers_max_order_by {
  created_at: order_by
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
  type: order_by
  updated_at: order_by
}

# aggregate min on columns
type fabric_layers_min_fields {
  created_at: timestamptz
  density: Int
  id: Int
  insulation: numeric
  permeability: Int
  thickness: numeric
  type: String
  updated_at: timestamptz
}

# order by min() on columns of table "fabric_layers"
input fabric_layers_min_order_by {
  created_at: order_by
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
  type: order_by
  updated_at: order_by
}

# response of any mutation on the table "fabric_layers"
type fabric_layers_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [fabric_layers!]!
}

# input type for inserting object relation for remote table "fabric_layers"
input fabric_layers_obj_rel_insert_input {
  data: fabric_layers_insert_input!
  on_conflict: fabric_layers_on_conflict
}

# on conflict condition type for table "fabric_layers"
input fabric_layers_on_conflict {
  constraint: fabric_layers_constraint!
  update_columns: [fabric_layers_update_column!]!
  where: fabric_layers_bool_exp
}

# ordering options when selecting data from "fabric_layers"
input fabric_layers_order_by {
  created_at: order_by
  density: order_by
  fabric_layer_and_colour_mix_parts_aggregate: fabric_layer_and_colour_mix_part_aggregate_order_by
  fabric_layer_type: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
  type: order_by
  updated_at: order_by
}

# primary key columns input for table: "fabric_layers"
input fabric_layers_pk_columns_input {
  id: Int!
}

# select columns of table "fabric_layers"
enum fabric_layers_select_column {
  # column name
  created_at

  # column name
  density

  # column name
  fabric_layer_type

  # column name
  id

  # column name
  insulation

  # column name
  permeability

  # column name
  thickness

  # column name
  type

  # column name
  updated_at
}

# input type for updating data in table "fabric_layers"
input fabric_layers_set_input {
  created_at: timestamptz
  density: Int
  fabric_layer_type: fabric_layer_types_enum
  id: Int
  insulation: numeric
  permeability: Int
  thickness: numeric
  type: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type fabric_layers_stddev_fields {
  density: Float
  id: Float
  insulation: Float
  permeability: Float
  thickness: Float
}

# order by stddev() on columns of table "fabric_layers"
input fabric_layers_stddev_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# aggregate stddev_pop on columns
type fabric_layers_stddev_pop_fields {
  density: Float
  id: Float
  insulation: Float
  permeability: Float
  thickness: Float
}

# order by stddev_pop() on columns of table "fabric_layers"
input fabric_layers_stddev_pop_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# aggregate stddev_samp on columns
type fabric_layers_stddev_samp_fields {
  density: Float
  id: Float
  insulation: Float
  permeability: Float
  thickness: Float
}

# order by stddev_samp() on columns of table "fabric_layers"
input fabric_layers_stddev_samp_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# aggregate sum on columns
type fabric_layers_sum_fields {
  density: Int
  id: Int
  insulation: numeric
  permeability: Int
  thickness: numeric
}

# order by sum() on columns of table "fabric_layers"
input fabric_layers_sum_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# update columns of table "fabric_layers"
enum fabric_layers_update_column {
  # column name
  created_at

  # column name
  density

  # column name
  fabric_layer_type

  # column name
  id

  # column name
  insulation

  # column name
  permeability

  # column name
  thickness

  # column name
  type

  # column name
  updated_at
}

# aggregate var_pop on columns
type fabric_layers_var_pop_fields {
  density: Float
  id: Float
  insulation: Float
  permeability: Float
  thickness: Float
}

# order by var_pop() on columns of table "fabric_layers"
input fabric_layers_var_pop_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# aggregate var_samp on columns
type fabric_layers_var_samp_fields {
  density: Float
  id: Float
  insulation: Float
  permeability: Float
  thickness: Float
}

# order by var_samp() on columns of table "fabric_layers"
input fabric_layers_var_samp_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# aggregate variance on columns
type fabric_layers_variance_fields {
  density: Float
  id: Float
  insulation: Float
  permeability: Float
  thickness: Float
}

# order by variance() on columns of table "fabric_layers"
input fabric_layers_variance_order_by {
  density: order_by
  id: order_by
  insulation: order_by
  permeability: order_by
  thickness: order_by
}

# The different types/ways in which a fabric can be constructed in.
#
#
# columns and relationships of "fabric_types"
#
type fabric_types {
  id: smallint!
  name: String!
}

# aggregated selection of "fabric_types"
type fabric_types_aggregate {
  aggregate: fabric_types_aggregate_fields
  nodes: [fabric_types!]!
}

# aggregate fields of "fabric_types"
type fabric_types_aggregate_fields {
  avg: fabric_types_avg_fields
  count(columns: [fabric_types_select_column!], distinct: Boolean): Int
  max: fabric_types_max_fields
  min: fabric_types_min_fields
  stddev: fabric_types_stddev_fields
  stddev_pop: fabric_types_stddev_pop_fields
  stddev_samp: fabric_types_stddev_samp_fields
  sum: fabric_types_sum_fields
  var_pop: fabric_types_var_pop_fields
  var_samp: fabric_types_var_samp_fields
  variance: fabric_types_variance_fields
}

# order by aggregate values of table "fabric_types"
input fabric_types_aggregate_order_by {
  avg: fabric_types_avg_order_by
  count: order_by
  max: fabric_types_max_order_by
  min: fabric_types_min_order_by
  stddev: fabric_types_stddev_order_by
  stddev_pop: fabric_types_stddev_pop_order_by
  stddev_samp: fabric_types_stddev_samp_order_by
  sum: fabric_types_sum_order_by
  var_pop: fabric_types_var_pop_order_by
  var_samp: fabric_types_var_samp_order_by
  variance: fabric_types_variance_order_by
}

# input type for inserting array relation for remote table "fabric_types"
input fabric_types_arr_rel_insert_input {
  data: [fabric_types_insert_input!]!
  on_conflict: fabric_types_on_conflict
}

# aggregate avg on columns
type fabric_types_avg_fields {
  id: Float
}

# order by avg() on columns of table "fabric_types"
input fabric_types_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "fabric_types". All fields are combined with a logical 'AND'.
input fabric_types_bool_exp {
  _and: [fabric_types_bool_exp]
  _not: fabric_types_bool_exp
  _or: [fabric_types_bool_exp]
  id: smallint_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "fabric_types"
enum fabric_types_constraint {
  # unique or primary key constraint
  fabric_types_name_key

  # unique or primary key constraint
  fabric_types_pkey
}

# input type for incrementing integer column in table "fabric_types"
input fabric_types_inc_input {
  id: smallint
}

# input type for inserting data into table "fabric_types"
input fabric_types_insert_input {
  id: smallint
  name: String
}

# aggregate max on columns
type fabric_types_max_fields {
  id: smallint
  name: String
}

# order by max() on columns of table "fabric_types"
input fabric_types_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type fabric_types_min_fields {
  id: smallint
  name: String
}

# order by min() on columns of table "fabric_types"
input fabric_types_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "fabric_types"
type fabric_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [fabric_types!]!
}

# input type for inserting object relation for remote table "fabric_types"
input fabric_types_obj_rel_insert_input {
  data: fabric_types_insert_input!
  on_conflict: fabric_types_on_conflict
}

# on conflict condition type for table "fabric_types"
input fabric_types_on_conflict {
  constraint: fabric_types_constraint!
  update_columns: [fabric_types_update_column!]!
  where: fabric_types_bool_exp
}

# ordering options when selecting data from "fabric_types"
input fabric_types_order_by {
  id: order_by
  name: order_by
}

# primary key columns input for table: "fabric_types"
input fabric_types_pk_columns_input {
  id: smallint!
}

# select columns of table "fabric_types"
enum fabric_types_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "fabric_types"
input fabric_types_set_input {
  id: smallint
  name: String
}

# aggregate stddev on columns
type fabric_types_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "fabric_types"
input fabric_types_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type fabric_types_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "fabric_types"
input fabric_types_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type fabric_types_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "fabric_types"
input fabric_types_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type fabric_types_sum_fields {
  id: smallint
}

# order by sum() on columns of table "fabric_types"
input fabric_types_sum_order_by {
  id: order_by
}

# update columns of table "fabric_types"
enum fabric_types_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type fabric_types_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "fabric_types"
input fabric_types_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type fabric_types_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "fabric_types"
input fabric_types_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type fabric_types_variance_fields {
  id: Float
}

# order by variance() on columns of table "fabric_types"
input fabric_types_variance_order_by {
  id: order_by
}

# The genders intended for items. This will not only include individual genders on
# their own, but also sets and combinations of multiple genders.
#
#
# columns and relationships of "genders"
#
type genders {
  # An array relationship
  collections(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): [collections!]!

  # An aggregated array relationship
  collections_aggregate(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): collections_aggregate!
  description: String

  # An array relationship
  item_maindata(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): [item_maindata!]!

  # An aggregated array relationship
  item_maindata_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): item_maindata_aggregate!
  value: String!
}

# aggregated selection of "genders"
type genders_aggregate {
  aggregate: genders_aggregate_fields
  nodes: [genders!]!
}

# aggregate fields of "genders"
type genders_aggregate_fields {
  count(columns: [genders_select_column!], distinct: Boolean): Int
  max: genders_max_fields
  min: genders_min_fields
}

# order by aggregate values of table "genders"
input genders_aggregate_order_by {
  count: order_by
  max: genders_max_order_by
  min: genders_min_order_by
}

# input type for inserting array relation for remote table "genders"
input genders_arr_rel_insert_input {
  data: [genders_insert_input!]!
  on_conflict: genders_on_conflict
}

# Boolean expression to filter rows from the table "genders". All fields are combined with a logical 'AND'.
input genders_bool_exp {
  _and: [genders_bool_exp]
  _not: genders_bool_exp
  _or: [genders_bool_exp]
  collections: collections_bool_exp
  description: String_comparison_exp
  item_maindata: item_maindata_bool_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "genders"
enum genders_constraint {
  # unique or primary key constraint
  gender_pkey
}

enum genders_enum {
  All
  Female
  Male
  Other
}

# expression to compare columns of type genders_enum. All fields are combined with logical 'AND'.
input genders_enum_comparison_exp {
  _eq: genders_enum
  _in: [genders_enum!]
  _is_null: Boolean
  _neq: genders_enum
  _nin: [genders_enum!]
}

# input type for inserting data into table "genders"
input genders_insert_input {
  collections: collections_arr_rel_insert_input
  description: String
  item_maindata: item_maindata_arr_rel_insert_input
  value: String
}

# aggregate max on columns
type genders_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "genders"
input genders_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type genders_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "genders"
input genders_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "genders"
type genders_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [genders!]!
}

# input type for inserting object relation for remote table "genders"
input genders_obj_rel_insert_input {
  data: genders_insert_input!
  on_conflict: genders_on_conflict
}

# on conflict condition type for table "genders"
input genders_on_conflict {
  constraint: genders_constraint!
  update_columns: [genders_update_column!]!
  where: genders_bool_exp
}

# ordering options when selecting data from "genders"
input genders_order_by {
  collections_aggregate: collections_aggregate_order_by
  description: order_by
  item_maindata_aggregate: item_maindata_aggregate_order_by
  value: order_by
}

# primary key columns input for table: "genders"
input genders_pk_columns_input {
  value: String!
}

# select columns of table "genders"
enum genders_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "genders"
input genders_set_input {
  description: String
  value: String
}

# update columns of table "genders"
enum genders_update_column {
  # column name
  description

  # column name
  value
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# (OBSOLETE - DO NOT USE) A many to many relationship table between items and clothing_shells
#
#
# columns and relationships of "item_and_clothing_shell"
#
type item_and_clothing_shell {
  # An object relationship
  clothing_shell: clothing_shells!
  clothing_shell_id: Int!

  # An object relationship
  item: items!
  item_id: Int!
}

# aggregated selection of "item_and_clothing_shell"
type item_and_clothing_shell_aggregate {
  aggregate: item_and_clothing_shell_aggregate_fields
  nodes: [item_and_clothing_shell!]!
}

# aggregate fields of "item_and_clothing_shell"
type item_and_clothing_shell_aggregate_fields {
  avg: item_and_clothing_shell_avg_fields
  count(columns: [item_and_clothing_shell_select_column!], distinct: Boolean): Int
  max: item_and_clothing_shell_max_fields
  min: item_and_clothing_shell_min_fields
  stddev: item_and_clothing_shell_stddev_fields
  stddev_pop: item_and_clothing_shell_stddev_pop_fields
  stddev_samp: item_and_clothing_shell_stddev_samp_fields
  sum: item_and_clothing_shell_sum_fields
  var_pop: item_and_clothing_shell_var_pop_fields
  var_samp: item_and_clothing_shell_var_samp_fields
  variance: item_and_clothing_shell_variance_fields
}

# order by aggregate values of table "item_and_clothing_shell"
input item_and_clothing_shell_aggregate_order_by {
  avg: item_and_clothing_shell_avg_order_by
  count: order_by
  max: item_and_clothing_shell_max_order_by
  min: item_and_clothing_shell_min_order_by
  stddev: item_and_clothing_shell_stddev_order_by
  stddev_pop: item_and_clothing_shell_stddev_pop_order_by
  stddev_samp: item_and_clothing_shell_stddev_samp_order_by
  sum: item_and_clothing_shell_sum_order_by
  var_pop: item_and_clothing_shell_var_pop_order_by
  var_samp: item_and_clothing_shell_var_samp_order_by
  variance: item_and_clothing_shell_variance_order_by
}

# input type for inserting array relation for remote table "item_and_clothing_shell"
input item_and_clothing_shell_arr_rel_insert_input {
  data: [item_and_clothing_shell_insert_input!]!
  on_conflict: item_and_clothing_shell_on_conflict
}

# aggregate avg on columns
type item_and_clothing_shell_avg_fields {
  clothing_shell_id: Float
  item_id: Float
}

# order by avg() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_avg_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# Boolean expression to filter rows from the table "item_and_clothing_shell". All fields are combined with a logical 'AND'.
input item_and_clothing_shell_bool_exp {
  _and: [item_and_clothing_shell_bool_exp]
  _not: item_and_clothing_shell_bool_exp
  _or: [item_and_clothing_shell_bool_exp]
  clothing_shell: clothing_shells_bool_exp
  clothing_shell_id: Int_comparison_exp
  item: items_bool_exp
  item_id: Int_comparison_exp
}

# unique or primary key constraints on table "item_and_clothing_shell"
enum item_and_clothing_shell_constraint {
  # unique or primary key constraint
  item_and_clothing_shells_pkey
}

# input type for incrementing integer column in table "item_and_clothing_shell"
input item_and_clothing_shell_inc_input {
  clothing_shell_id: Int
  item_id: Int
}

# input type for inserting data into table "item_and_clothing_shell"
input item_and_clothing_shell_insert_input {
  clothing_shell: clothing_shells_obj_rel_insert_input
  clothing_shell_id: Int
  item: items_obj_rel_insert_input
  item_id: Int
}

# aggregate max on columns
type item_and_clothing_shell_max_fields {
  clothing_shell_id: Int
  item_id: Int
}

# order by max() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_max_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# aggregate min on columns
type item_and_clothing_shell_min_fields {
  clothing_shell_id: Int
  item_id: Int
}

# order by min() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_min_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# response of any mutation on the table "item_and_clothing_shell"
type item_and_clothing_shell_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_and_clothing_shell!]!
}

# input type for inserting object relation for remote table "item_and_clothing_shell"
input item_and_clothing_shell_obj_rel_insert_input {
  data: item_and_clothing_shell_insert_input!
  on_conflict: item_and_clothing_shell_on_conflict
}

# on conflict condition type for table "item_and_clothing_shell"
input item_and_clothing_shell_on_conflict {
  constraint: item_and_clothing_shell_constraint!
  update_columns: [item_and_clothing_shell_update_column!]!
  where: item_and_clothing_shell_bool_exp
}

# ordering options when selecting data from "item_and_clothing_shell"
input item_and_clothing_shell_order_by {
  clothing_shell: clothing_shells_order_by
  clothing_shell_id: order_by
  item: items_order_by
  item_id: order_by
}

# primary key columns input for table: "item_and_clothing_shell"
input item_and_clothing_shell_pk_columns_input {
  clothing_shell_id: Int!
  item_id: Int!
}

# select columns of table "item_and_clothing_shell"
enum item_and_clothing_shell_select_column {
  # column name
  clothing_shell_id

  # column name
  item_id
}

# input type for updating data in table "item_and_clothing_shell"
input item_and_clothing_shell_set_input {
  clothing_shell_id: Int
  item_id: Int
}

# aggregate stddev on columns
type item_and_clothing_shell_stddev_fields {
  clothing_shell_id: Float
  item_id: Float
}

# order by stddev() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_stddev_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# aggregate stddev_pop on columns
type item_and_clothing_shell_stddev_pop_fields {
  clothing_shell_id: Float
  item_id: Float
}

# order by stddev_pop() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_stddev_pop_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# aggregate stddev_samp on columns
type item_and_clothing_shell_stddev_samp_fields {
  clothing_shell_id: Float
  item_id: Float
}

# order by stddev_samp() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_stddev_samp_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# aggregate sum on columns
type item_and_clothing_shell_sum_fields {
  clothing_shell_id: Int
  item_id: Int
}

# order by sum() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_sum_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# update columns of table "item_and_clothing_shell"
enum item_and_clothing_shell_update_column {
  # column name
  clothing_shell_id

  # column name
  item_id
}

# aggregate var_pop on columns
type item_and_clothing_shell_var_pop_fields {
  clothing_shell_id: Float
  item_id: Float
}

# order by var_pop() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_var_pop_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# aggregate var_samp on columns
type item_and_clothing_shell_var_samp_fields {
  clothing_shell_id: Float
  item_id: Float
}

# order by var_samp() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_var_samp_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# aggregate variance on columns
type item_and_clothing_shell_variance_fields {
  clothing_shell_id: Float
  item_id: Float
}

# order by variance() on columns of table "item_and_clothing_shell"
input item_and_clothing_shell_variance_order_by {
  clothing_shell_id: order_by
  item_id: order_by
}

# columns and relationships of "item_families"
type item_families {
  brand_id: Int!

  # An object relationship
  company: companies!
  created_at: timestamptz!
  id: Int!

  # An array relationship
  items(
    # distinct select on columns
    distinct_on: [items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [items_order_by!]

    # filter the rows returned
    where: items_bool_exp
  ): [items!]!

  # An aggregated array relationship
  items_aggregate(
    # distinct select on columns
    distinct_on: [items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [items_order_by!]

    # filter the rows returned
    where: items_bool_exp
  ): items_aggregate!
  name: String!
  updated_at: timestamptz!
}

# aggregated selection of "item_families"
type item_families_aggregate {
  aggregate: item_families_aggregate_fields
  nodes: [item_families!]!
}

# aggregate fields of "item_families"
type item_families_aggregate_fields {
  avg: item_families_avg_fields
  count(columns: [item_families_select_column!], distinct: Boolean): Int
  max: item_families_max_fields
  min: item_families_min_fields
  stddev: item_families_stddev_fields
  stddev_pop: item_families_stddev_pop_fields
  stddev_samp: item_families_stddev_samp_fields
  sum: item_families_sum_fields
  var_pop: item_families_var_pop_fields
  var_samp: item_families_var_samp_fields
  variance: item_families_variance_fields
}

# order by aggregate values of table "item_families"
input item_families_aggregate_order_by {
  avg: item_families_avg_order_by
  count: order_by
  max: item_families_max_order_by
  min: item_families_min_order_by
  stddev: item_families_stddev_order_by
  stddev_pop: item_families_stddev_pop_order_by
  stddev_samp: item_families_stddev_samp_order_by
  sum: item_families_sum_order_by
  var_pop: item_families_var_pop_order_by
  var_samp: item_families_var_samp_order_by
  variance: item_families_variance_order_by
}

# input type for inserting array relation for remote table "item_families"
input item_families_arr_rel_insert_input {
  data: [item_families_insert_input!]!
  on_conflict: item_families_on_conflict
}

# aggregate avg on columns
type item_families_avg_fields {
  brand_id: Float
  id: Float
}

# order by avg() on columns of table "item_families"
input item_families_avg_order_by {
  brand_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "item_families". All fields are combined with a logical 'AND'.
input item_families_bool_exp {
  _and: [item_families_bool_exp]
  _not: item_families_bool_exp
  _or: [item_families_bool_exp]
  brand_id: Int_comparison_exp
  company: companies_bool_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  items: items_bool_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "item_families"
enum item_families_constraint {
  # unique or primary key constraint
  item_families_pkey
}

# input type for incrementing integer column in table "item_families"
input item_families_inc_input {
  brand_id: Int
  id: Int
}

# input type for inserting data into table "item_families"
input item_families_insert_input {
  brand_id: Int
  company: companies_obj_rel_insert_input
  created_at: timestamptz
  id: Int
  items: items_arr_rel_insert_input
  name: String
  updated_at: timestamptz
}

# aggregate max on columns
type item_families_max_fields {
  brand_id: Int
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

# order by max() on columns of table "item_families"
input item_families_max_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# aggregate min on columns
type item_families_min_fields {
  brand_id: Int
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

# order by min() on columns of table "item_families"
input item_families_min_order_by {
  brand_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# response of any mutation on the table "item_families"
type item_families_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_families!]!
}

# input type for inserting object relation for remote table "item_families"
input item_families_obj_rel_insert_input {
  data: item_families_insert_input!
  on_conflict: item_families_on_conflict
}

# on conflict condition type for table "item_families"
input item_families_on_conflict {
  constraint: item_families_constraint!
  update_columns: [item_families_update_column!]!
  where: item_families_bool_exp
}

# ordering options when selecting data from "item_families"
input item_families_order_by {
  brand_id: order_by
  company: companies_order_by
  created_at: order_by
  id: order_by
  items_aggregate: items_aggregate_order_by
  name: order_by
  updated_at: order_by
}

# primary key columns input for table: "item_families"
input item_families_pk_columns_input {
  id: Int!
}

# select columns of table "item_families"
enum item_families_select_column {
  # column name
  brand_id

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# input type for updating data in table "item_families"
input item_families_set_input {
  brand_id: Int
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type item_families_stddev_fields {
  brand_id: Float
  id: Float
}

# order by stddev() on columns of table "item_families"
input item_families_stddev_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type item_families_stddev_pop_fields {
  brand_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "item_families"
input item_families_stddev_pop_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type item_families_stddev_samp_fields {
  brand_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "item_families"
input item_families_stddev_samp_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate sum on columns
type item_families_sum_fields {
  brand_id: Int
  id: Int
}

# order by sum() on columns of table "item_families"
input item_families_sum_order_by {
  brand_id: order_by
  id: order_by
}

# update columns of table "item_families"
enum item_families_update_column {
  # column name
  brand_id

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# aggregate var_pop on columns
type item_families_var_pop_fields {
  brand_id: Float
  id: Float
}

# order by var_pop() on columns of table "item_families"
input item_families_var_pop_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type item_families_var_samp_fields {
  brand_id: Float
  id: Float
}

# order by var_samp() on columns of table "item_families"
input item_families_var_samp_order_by {
  brand_id: order_by
  id: order_by
}

# aggregate variance on columns
type item_families_variance_fields {
  brand_id: Float
  id: Float
}

# order by variance() on columns of table "item_families"
input item_families_variance_order_by {
  brand_id: order_by
  id: order_by
}

# Main data about items (clothing and accessories).
#
#
# columns and relationships of "item_maindata"
#
type item_maindata {
  # An object relationship
  brand: companies
  brand_id: Int

  # An object relationship
  clothing_shell: clothing_shells
  clothing_shell_id: Int
  for_gender: genders_enum!
  id: uuid!
  is_release: Boolean!

  # An object relationship
  item_family: item_families
  item_family_id: Int

  # An object relationship
  made_in: countries

  # The country code that the item is made in.
  made_in_id: countries_enum
  name: String

  # An object relationship
  revision: item_maindata_revisions!
  revision_id: uuid!
  short_id: Int
  type: item_types_enum!
}

# aggregated selection of "item_maindata"
type item_maindata_aggregate {
  aggregate: item_maindata_aggregate_fields
  nodes: [item_maindata!]!
}

# aggregate fields of "item_maindata"
type item_maindata_aggregate_fields {
  avg: item_maindata_avg_fields
  count(columns: [item_maindata_select_column!], distinct: Boolean): Int
  max: item_maindata_max_fields
  min: item_maindata_min_fields
  stddev: item_maindata_stddev_fields
  stddev_pop: item_maindata_stddev_pop_fields
  stddev_samp: item_maindata_stddev_samp_fields
  sum: item_maindata_sum_fields
  var_pop: item_maindata_var_pop_fields
  var_samp: item_maindata_var_samp_fields
  variance: item_maindata_variance_fields
}

# order by aggregate values of table "item_maindata"
input item_maindata_aggregate_order_by {
  avg: item_maindata_avg_order_by
  count: order_by
  max: item_maindata_max_order_by
  min: item_maindata_min_order_by
  stddev: item_maindata_stddev_order_by
  stddev_pop: item_maindata_stddev_pop_order_by
  stddev_samp: item_maindata_stddev_samp_order_by
  sum: item_maindata_sum_order_by
  var_pop: item_maindata_var_pop_order_by
  var_samp: item_maindata_var_samp_order_by
  variance: item_maindata_variance_order_by
}

# input type for inserting array relation for remote table "item_maindata"
input item_maindata_arr_rel_insert_input {
  data: [item_maindata_insert_input!]!
  on_conflict: item_maindata_on_conflict
}

# aggregate avg on columns
type item_maindata_avg_fields {
  brand_id: Float
  clothing_shell_id: Float
  item_family_id: Float
  short_id: Float
}

# order by avg() on columns of table "item_maindata"
input item_maindata_avg_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# Boolean expression to filter rows from the table "item_maindata". All fields are combined with a logical 'AND'.
input item_maindata_bool_exp {
  _and: [item_maindata_bool_exp]
  _not: item_maindata_bool_exp
  _or: [item_maindata_bool_exp]
  brand: companies_bool_exp
  brand_id: Int_comparison_exp
  clothing_shell: clothing_shells_bool_exp
  clothing_shell_id: Int_comparison_exp
  for_gender: genders_enum_comparison_exp
  id: uuid_comparison_exp
  is_release: Boolean_comparison_exp
  item_family: item_families_bool_exp
  item_family_id: Int_comparison_exp
  made_in: countries_bool_exp
  made_in_id: countries_enum_comparison_exp
  name: String_comparison_exp
  revision: item_maindata_revisions_bool_exp
  revision_id: uuid_comparison_exp
  short_id: Int_comparison_exp
  type: item_types_enum_comparison_exp
}

# unique or primary key constraints on table "item_maindata"
enum item_maindata_constraint {
  # unique or primary key constraint
  item_maindata_pkey

  # unique or primary key constraint
  item_maindata_revision_id_is_release_short_id_key
}

# input type for incrementing integer column in table "item_maindata"
input item_maindata_inc_input {
  brand_id: Int
  clothing_shell_id: Int
  item_family_id: Int
  short_id: Int
}

# input type for inserting data into table "item_maindata"
input item_maindata_insert_input {
  brand: companies_obj_rel_insert_input
  brand_id: Int
  clothing_shell: clothing_shells_obj_rel_insert_input
  clothing_shell_id: Int
  for_gender: genders_enum
  id: uuid
  is_release: Boolean
  item_family: item_families_obj_rel_insert_input
  item_family_id: Int
  made_in: countries_obj_rel_insert_input
  made_in_id: countries_enum
  name: String
  revision: item_maindata_revisions_obj_rel_insert_input
  revision_id: uuid
  short_id: Int
  type: item_types_enum
}

# aggregate max on columns
type item_maindata_max_fields {
  brand_id: Int
  clothing_shell_id: Int
  id: uuid
  item_family_id: Int
  name: String
  revision_id: uuid
  short_id: Int
}

# order by max() on columns of table "item_maindata"
input item_maindata_max_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  id: order_by
  item_family_id: order_by
  name: order_by
  revision_id: order_by
  short_id: order_by
}

# aggregate min on columns
type item_maindata_min_fields {
  brand_id: Int
  clothing_shell_id: Int
  id: uuid
  item_family_id: Int
  name: String
  revision_id: uuid
  short_id: Int
}

# order by min() on columns of table "item_maindata"
input item_maindata_min_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  id: order_by
  item_family_id: order_by
  name: order_by
  revision_id: order_by
  short_id: order_by
}

# response of any mutation on the table "item_maindata"
type item_maindata_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_maindata!]!
}

# input type for inserting object relation for remote table "item_maindata"
input item_maindata_obj_rel_insert_input {
  data: item_maindata_insert_input!
  on_conflict: item_maindata_on_conflict
}

# on conflict condition type for table "item_maindata"
input item_maindata_on_conflict {
  constraint: item_maindata_constraint!
  update_columns: [item_maindata_update_column!]!
  where: item_maindata_bool_exp
}

# ordering options when selecting data from "item_maindata"
input item_maindata_order_by {
  brand: companies_order_by
  brand_id: order_by
  clothing_shell: clothing_shells_order_by
  clothing_shell_id: order_by
  for_gender: order_by
  id: order_by
  is_release: order_by
  item_family: item_families_order_by
  item_family_id: order_by
  made_in: countries_order_by
  made_in_id: order_by
  name: order_by
  revision: item_maindata_revisions_order_by
  revision_id: order_by
  short_id: order_by
  type: order_by
}

# primary key columns input for table: "item_maindata"
input item_maindata_pk_columns_input {
  id: uuid!
}

# Intended for the table "item_maindata_revisions". Contains information about
# changes made, such as and edits, deletes, updates and promotions.
#
#
# columns and relationships of "item_maindata_revision_changes"
#
type item_maindata_revision_changes {
  action: data_actions_enum
  change_type: data_change_types_enum!
  date: timestamptz!
  id: uuid!

  # An object relationship
  item_maindata_revision: item_maindata_revisions!
  item_maindata_revision_id: uuid!
  to_state: data_states_enum

  # An object relationship
  user: staff_users!
  user_id: Int!
}

# aggregated selection of "item_maindata_revision_changes"
type item_maindata_revision_changes_aggregate {
  aggregate: item_maindata_revision_changes_aggregate_fields
  nodes: [item_maindata_revision_changes!]!
}

# aggregate fields of "item_maindata_revision_changes"
type item_maindata_revision_changes_aggregate_fields {
  avg: item_maindata_revision_changes_avg_fields
  count(columns: [item_maindata_revision_changes_select_column!], distinct: Boolean): Int
  max: item_maindata_revision_changes_max_fields
  min: item_maindata_revision_changes_min_fields
  stddev: item_maindata_revision_changes_stddev_fields
  stddev_pop: item_maindata_revision_changes_stddev_pop_fields
  stddev_samp: item_maindata_revision_changes_stddev_samp_fields
  sum: item_maindata_revision_changes_sum_fields
  var_pop: item_maindata_revision_changes_var_pop_fields
  var_samp: item_maindata_revision_changes_var_samp_fields
  variance: item_maindata_revision_changes_variance_fields
}

# order by aggregate values of table "item_maindata_revision_changes"
input item_maindata_revision_changes_aggregate_order_by {
  avg: item_maindata_revision_changes_avg_order_by
  count: order_by
  max: item_maindata_revision_changes_max_order_by
  min: item_maindata_revision_changes_min_order_by
  stddev: item_maindata_revision_changes_stddev_order_by
  stddev_pop: item_maindata_revision_changes_stddev_pop_order_by
  stddev_samp: item_maindata_revision_changes_stddev_samp_order_by
  sum: item_maindata_revision_changes_sum_order_by
  var_pop: item_maindata_revision_changes_var_pop_order_by
  var_samp: item_maindata_revision_changes_var_samp_order_by
  variance: item_maindata_revision_changes_variance_order_by
}

# input type for inserting array relation for remote table "item_maindata_revision_changes"
input item_maindata_revision_changes_arr_rel_insert_input {
  data: [item_maindata_revision_changes_insert_input!]!
  on_conflict: item_maindata_revision_changes_on_conflict
}

# aggregate avg on columns
type item_maindata_revision_changes_avg_fields {
  user_id: Float
}

# order by avg() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_avg_order_by {
  user_id: order_by
}

# Boolean expression to filter rows from the table
# "item_maindata_revision_changes". All fields are combined with a logical 'AND'.
input item_maindata_revision_changes_bool_exp {
  _and: [item_maindata_revision_changes_bool_exp]
  _not: item_maindata_revision_changes_bool_exp
  _or: [item_maindata_revision_changes_bool_exp]
  action: data_actions_enum_comparison_exp
  change_type: data_change_types_enum_comparison_exp
  date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  item_maindata_revision: item_maindata_revisions_bool_exp
  item_maindata_revision_id: uuid_comparison_exp
  to_state: data_states_enum_comparison_exp
  user: staff_users_bool_exp
  user_id: Int_comparison_exp
}

# unique or primary key constraints on table "item_maindata_revision_changes"
enum item_maindata_revision_changes_constraint {
  # unique or primary key constraint
  item_maindata_revision_changes_pkey
}

# input type for incrementing integer column in table "item_maindata_revision_changes"
input item_maindata_revision_changes_inc_input {
  user_id: Int
}

# input type for inserting data into table "item_maindata_revision_changes"
input item_maindata_revision_changes_insert_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  date: timestamptz
  id: uuid
  item_maindata_revision: item_maindata_revisions_obj_rel_insert_input
  item_maindata_revision_id: uuid
  to_state: data_states_enum
  user: staff_users_obj_rel_insert_input
  user_id: Int
}

# aggregate max on columns
type item_maindata_revision_changes_max_fields {
  date: timestamptz
  id: uuid
  item_maindata_revision_id: uuid
  user_id: Int
}

# order by max() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_max_order_by {
  date: order_by
  id: order_by
  item_maindata_revision_id: order_by
  user_id: order_by
}

# aggregate min on columns
type item_maindata_revision_changes_min_fields {
  date: timestamptz
  id: uuid
  item_maindata_revision_id: uuid
  user_id: Int
}

# order by min() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_min_order_by {
  date: order_by
  id: order_by
  item_maindata_revision_id: order_by
  user_id: order_by
}

# response of any mutation on the table "item_maindata_revision_changes"
type item_maindata_revision_changes_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_maindata_revision_changes!]!
}

# input type for inserting object relation for remote table "item_maindata_revision_changes"
input item_maindata_revision_changes_obj_rel_insert_input {
  data: item_maindata_revision_changes_insert_input!
  on_conflict: item_maindata_revision_changes_on_conflict
}

# on conflict condition type for table "item_maindata_revision_changes"
input item_maindata_revision_changes_on_conflict {
  constraint: item_maindata_revision_changes_constraint!
  update_columns: [item_maindata_revision_changes_update_column!]!
  where: item_maindata_revision_changes_bool_exp
}

# ordering options when selecting data from "item_maindata_revision_changes"
input item_maindata_revision_changes_order_by {
  action: order_by
  change_type: order_by
  date: order_by
  id: order_by
  item_maindata_revision: item_maindata_revisions_order_by
  item_maindata_revision_id: order_by
  to_state: order_by
  user: staff_users_order_by
  user_id: order_by
}

# primary key columns input for table: "item_maindata_revision_changes"
input item_maindata_revision_changes_pk_columns_input {
  id: uuid!
}

# select columns of table "item_maindata_revision_changes"
enum item_maindata_revision_changes_select_column {
  # column name
  action

  # column name
  change_type

  # column name
  date

  # column name
  id

  # column name
  item_maindata_revision_id

  # column name
  to_state

  # column name
  user_id
}

# input type for updating data in table "item_maindata_revision_changes"
input item_maindata_revision_changes_set_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  date: timestamptz
  id: uuid
  item_maindata_revision_id: uuid
  to_state: data_states_enum
  user_id: Int
}

# aggregate stddev on columns
type item_maindata_revision_changes_stddev_fields {
  user_id: Float
}

# order by stddev() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_stddev_order_by {
  user_id: order_by
}

# aggregate stddev_pop on columns
type item_maindata_revision_changes_stddev_pop_fields {
  user_id: Float
}

# order by stddev_pop() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_stddev_pop_order_by {
  user_id: order_by
}

# aggregate stddev_samp on columns
type item_maindata_revision_changes_stddev_samp_fields {
  user_id: Float
}

# order by stddev_samp() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_stddev_samp_order_by {
  user_id: order_by
}

# aggregate sum on columns
type item_maindata_revision_changes_sum_fields {
  user_id: Int
}

# order by sum() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_sum_order_by {
  user_id: order_by
}

# update columns of table "item_maindata_revision_changes"
enum item_maindata_revision_changes_update_column {
  # column name
  action

  # column name
  change_type

  # column name
  date

  # column name
  id

  # column name
  item_maindata_revision_id

  # column name
  to_state

  # column name
  user_id
}

# aggregate var_pop on columns
type item_maindata_revision_changes_var_pop_fields {
  user_id: Float
}

# order by var_pop() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_var_pop_order_by {
  user_id: order_by
}

# aggregate var_samp on columns
type item_maindata_revision_changes_var_samp_fields {
  user_id: Float
}

# order by var_samp() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_var_samp_order_by {
  user_id: order_by
}

# aggregate variance on columns
type item_maindata_revision_changes_variance_fields {
  user_id: Float
}

# order by variance() on columns of table "item_maindata_revision_changes"
input item_maindata_revision_changes_variance_order_by {
  user_id: order_by
}

# A main data revision for items, containing vital control information for it's draft and release versions.
#
#
# columns and relationships of "item_maindata_revisions"
#
type item_maindata_revisions {
  id: uuid!

  # An object relationship
  item: items!

  # The associated id of the item this maindata revision is intended for.
  item_id: Int!

  # An array relationship
  item_maindata(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): [item_maindata!]!

  # An aggregated array relationship
  item_maindata_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): item_maindata_aggregate!

  # The revision or version number of this maindata group (of draft and release).
  revision: Int!

  # The data state of this maindata revision (e.g. Development, Review, Production and Retired).
  state: data_states_enum!
}

# aggregated selection of "item_maindata_revisions"
type item_maindata_revisions_aggregate {
  aggregate: item_maindata_revisions_aggregate_fields
  nodes: [item_maindata_revisions!]!
}

# aggregate fields of "item_maindata_revisions"
type item_maindata_revisions_aggregate_fields {
  avg: item_maindata_revisions_avg_fields
  count(columns: [item_maindata_revisions_select_column!], distinct: Boolean): Int
  max: item_maindata_revisions_max_fields
  min: item_maindata_revisions_min_fields
  stddev: item_maindata_revisions_stddev_fields
  stddev_pop: item_maindata_revisions_stddev_pop_fields
  stddev_samp: item_maindata_revisions_stddev_samp_fields
  sum: item_maindata_revisions_sum_fields
  var_pop: item_maindata_revisions_var_pop_fields
  var_samp: item_maindata_revisions_var_samp_fields
  variance: item_maindata_revisions_variance_fields
}

# order by aggregate values of table "item_maindata_revisions"
input item_maindata_revisions_aggregate_order_by {
  avg: item_maindata_revisions_avg_order_by
  count: order_by
  max: item_maindata_revisions_max_order_by
  min: item_maindata_revisions_min_order_by
  stddev: item_maindata_revisions_stddev_order_by
  stddev_pop: item_maindata_revisions_stddev_pop_order_by
  stddev_samp: item_maindata_revisions_stddev_samp_order_by
  sum: item_maindata_revisions_sum_order_by
  var_pop: item_maindata_revisions_var_pop_order_by
  var_samp: item_maindata_revisions_var_samp_order_by
  variance: item_maindata_revisions_variance_order_by
}

# input type for inserting array relation for remote table "item_maindata_revisions"
input item_maindata_revisions_arr_rel_insert_input {
  data: [item_maindata_revisions_insert_input!]!
  on_conflict: item_maindata_revisions_on_conflict
}

# aggregate avg on columns
type item_maindata_revisions_avg_fields {
  item_id: Float
  revision: Float
}

# order by avg() on columns of table "item_maindata_revisions"
input item_maindata_revisions_avg_order_by {
  item_id: order_by
  revision: order_by
}

# Boolean expression to filter rows from the table "item_maindata_revisions". All fields are combined with a logical 'AND'.
input item_maindata_revisions_bool_exp {
  _and: [item_maindata_revisions_bool_exp]
  _not: item_maindata_revisions_bool_exp
  _or: [item_maindata_revisions_bool_exp]
  id: uuid_comparison_exp
  item: items_bool_exp
  item_id: Int_comparison_exp
  item_maindata: item_maindata_bool_exp
  revision: Int_comparison_exp
  state: data_states_enum_comparison_exp
}

# unique or primary key constraints on table "item_maindata_revisions"
enum item_maindata_revisions_constraint {
  # unique or primary key constraint
  item_maindata_revisions_item_id_revision_key

  # unique or primary key constraint
  item_maindata_revisions_pkey
}

# input type for incrementing integer column in table "item_maindata_revisions"
input item_maindata_revisions_inc_input {
  item_id: Int
  revision: Int
}

# input type for inserting data into table "item_maindata_revisions"
input item_maindata_revisions_insert_input {
  id: uuid
  item: items_obj_rel_insert_input
  item_id: Int
  item_maindata: item_maindata_arr_rel_insert_input
  revision: Int
  state: data_states_enum
}

# aggregate max on columns
type item_maindata_revisions_max_fields {
  id: uuid
  item_id: Int
  revision: Int
}

# order by max() on columns of table "item_maindata_revisions"
input item_maindata_revisions_max_order_by {
  id: order_by
  item_id: order_by
  revision: order_by
}

# aggregate min on columns
type item_maindata_revisions_min_fields {
  id: uuid
  item_id: Int
  revision: Int
}

# order by min() on columns of table "item_maindata_revisions"
input item_maindata_revisions_min_order_by {
  id: order_by
  item_id: order_by
  revision: order_by
}

# response of any mutation on the table "item_maindata_revisions"
type item_maindata_revisions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_maindata_revisions!]!
}

# input type for inserting object relation for remote table "item_maindata_revisions"
input item_maindata_revisions_obj_rel_insert_input {
  data: item_maindata_revisions_insert_input!
  on_conflict: item_maindata_revisions_on_conflict
}

# on conflict condition type for table "item_maindata_revisions"
input item_maindata_revisions_on_conflict {
  constraint: item_maindata_revisions_constraint!
  update_columns: [item_maindata_revisions_update_column!]!
  where: item_maindata_revisions_bool_exp
}

# ordering options when selecting data from "item_maindata_revisions"
input item_maindata_revisions_order_by {
  id: order_by
  item: items_order_by
  item_id: order_by
  item_maindata_aggregate: item_maindata_aggregate_order_by
  revision: order_by
  state: order_by
}

# primary key columns input for table: "item_maindata_revisions"
input item_maindata_revisions_pk_columns_input {
  id: uuid!
}

# select columns of table "item_maindata_revisions"
enum item_maindata_revisions_select_column {
  # column name
  id

  # column name
  item_id

  # column name
  revision

  # column name
  state
}

# input type for updating data in table "item_maindata_revisions"
input item_maindata_revisions_set_input {
  id: uuid
  item_id: Int
  revision: Int
  state: data_states_enum
}

# aggregate stddev on columns
type item_maindata_revisions_stddev_fields {
  item_id: Float
  revision: Float
}

# order by stddev() on columns of table "item_maindata_revisions"
input item_maindata_revisions_stddev_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate stddev_pop on columns
type item_maindata_revisions_stddev_pop_fields {
  item_id: Float
  revision: Float
}

# order by stddev_pop() on columns of table "item_maindata_revisions"
input item_maindata_revisions_stddev_pop_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate stddev_samp on columns
type item_maindata_revisions_stddev_samp_fields {
  item_id: Float
  revision: Float
}

# order by stddev_samp() on columns of table "item_maindata_revisions"
input item_maindata_revisions_stddev_samp_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate sum on columns
type item_maindata_revisions_sum_fields {
  item_id: Int
  revision: Int
}

# order by sum() on columns of table "item_maindata_revisions"
input item_maindata_revisions_sum_order_by {
  item_id: order_by
  revision: order_by
}

# update columns of table "item_maindata_revisions"
enum item_maindata_revisions_update_column {
  # column name
  id

  # column name
  item_id

  # column name
  revision

  # column name
  state
}

# aggregate var_pop on columns
type item_maindata_revisions_var_pop_fields {
  item_id: Float
  revision: Float
}

# order by var_pop() on columns of table "item_maindata_revisions"
input item_maindata_revisions_var_pop_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate var_samp on columns
type item_maindata_revisions_var_samp_fields {
  item_id: Float
  revision: Float
}

# order by var_samp() on columns of table "item_maindata_revisions"
input item_maindata_revisions_var_samp_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate variance on columns
type item_maindata_revisions_variance_fields {
  item_id: Float
  revision: Float
}

# order by variance() on columns of table "item_maindata_revisions"
input item_maindata_revisions_variance_order_by {
  item_id: order_by
  revision: order_by
}

# select columns of table "item_maindata"
enum item_maindata_select_column {
  # column name
  brand_id

  # column name
  clothing_shell_id

  # column name
  for_gender

  # column name
  id

  # column name
  is_release

  # column name
  item_family_id

  # column name
  made_in_id

  # column name
  name

  # column name
  revision_id

  # column name
  short_id

  # column name
  type
}

# input type for updating data in table "item_maindata"
input item_maindata_set_input {
  brand_id: Int
  clothing_shell_id: Int
  for_gender: genders_enum
  id: uuid
  is_release: Boolean
  item_family_id: Int
  made_in_id: countries_enum
  name: String
  revision_id: uuid
  short_id: Int
  type: item_types_enum
}

# aggregate stddev on columns
type item_maindata_stddev_fields {
  brand_id: Float
  clothing_shell_id: Float
  item_family_id: Float
  short_id: Float
}

# order by stddev() on columns of table "item_maindata"
input item_maindata_stddev_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate stddev_pop on columns
type item_maindata_stddev_pop_fields {
  brand_id: Float
  clothing_shell_id: Float
  item_family_id: Float
  short_id: Float
}

# order by stddev_pop() on columns of table "item_maindata"
input item_maindata_stddev_pop_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate stddev_samp on columns
type item_maindata_stddev_samp_fields {
  brand_id: Float
  clothing_shell_id: Float
  item_family_id: Float
  short_id: Float
}

# order by stddev_samp() on columns of table "item_maindata"
input item_maindata_stddev_samp_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate sum on columns
type item_maindata_sum_fields {
  brand_id: Int
  clothing_shell_id: Int
  item_family_id: Int
  short_id: Int
}

# order by sum() on columns of table "item_maindata"
input item_maindata_sum_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# update columns of table "item_maindata"
enum item_maindata_update_column {
  # column name
  brand_id

  # column name
  clothing_shell_id

  # column name
  for_gender

  # column name
  id

  # column name
  is_release

  # column name
  item_family_id

  # column name
  made_in_id

  # column name
  name

  # column name
  revision_id

  # column name
  short_id

  # column name
  type
}

# aggregate var_pop on columns
type item_maindata_var_pop_fields {
  brand_id: Float
  clothing_shell_id: Float
  item_family_id: Float
  short_id: Float
}

# order by var_pop() on columns of table "item_maindata"
input item_maindata_var_pop_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate var_samp on columns
type item_maindata_var_samp_fields {
  brand_id: Float
  clothing_shell_id: Float
  item_family_id: Float
  short_id: Float
}

# order by var_samp() on columns of table "item_maindata"
input item_maindata_var_samp_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate variance on columns
type item_maindata_variance_fields {
  brand_id: Float
  clothing_shell_id: Float
  item_family_id: Float
  short_id: Float
}

# order by variance() on columns of table "item_maindata"
input item_maindata_variance_order_by {
  brand_id: order_by
  clothing_shell_id: order_by
  item_family_id: order_by
  short_id: order_by
}

# Intended for the table "item_translation_revisions". Contains information about
# changes made, such as and edits, deletes, updates and promotions.
#
#
# columns and relationships of "item_translation_revision_changes"
#
type item_translation_revision_changes {
  action: data_actions_enum
  change_type: data_change_types_enum!
  date: timestamptz!
  id: uuid!

  # An object relationship
  item_translation_revision: item_translation_revisions!
  item_translation_revision_id: uuid!
  to_state: data_states_enum

  # An object relationship
  user: staff_users!
  user_id: Int!
}

# aggregated selection of "item_translation_revision_changes"
type item_translation_revision_changes_aggregate {
  aggregate: item_translation_revision_changes_aggregate_fields
  nodes: [item_translation_revision_changes!]!
}

# aggregate fields of "item_translation_revision_changes"
type item_translation_revision_changes_aggregate_fields {
  avg: item_translation_revision_changes_avg_fields
  count(columns: [item_translation_revision_changes_select_column!], distinct: Boolean): Int
  max: item_translation_revision_changes_max_fields
  min: item_translation_revision_changes_min_fields
  stddev: item_translation_revision_changes_stddev_fields
  stddev_pop: item_translation_revision_changes_stddev_pop_fields
  stddev_samp: item_translation_revision_changes_stddev_samp_fields
  sum: item_translation_revision_changes_sum_fields
  var_pop: item_translation_revision_changes_var_pop_fields
  var_samp: item_translation_revision_changes_var_samp_fields
  variance: item_translation_revision_changes_variance_fields
}

# order by aggregate values of table "item_translation_revision_changes"
input item_translation_revision_changes_aggregate_order_by {
  avg: item_translation_revision_changes_avg_order_by
  count: order_by
  max: item_translation_revision_changes_max_order_by
  min: item_translation_revision_changes_min_order_by
  stddev: item_translation_revision_changes_stddev_order_by
  stddev_pop: item_translation_revision_changes_stddev_pop_order_by
  stddev_samp: item_translation_revision_changes_stddev_samp_order_by
  sum: item_translation_revision_changes_sum_order_by
  var_pop: item_translation_revision_changes_var_pop_order_by
  var_samp: item_translation_revision_changes_var_samp_order_by
  variance: item_translation_revision_changes_variance_order_by
}

# input type for inserting array relation for remote table "item_translation_revision_changes"
input item_translation_revision_changes_arr_rel_insert_input {
  data: [item_translation_revision_changes_insert_input!]!
  on_conflict: item_translation_revision_changes_on_conflict
}

# aggregate avg on columns
type item_translation_revision_changes_avg_fields {
  user_id: Float
}

# order by avg() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_avg_order_by {
  user_id: order_by
}

# Boolean expression to filter rows from the table
# "item_translation_revision_changes". All fields are combined with a logical 'AND'.
input item_translation_revision_changes_bool_exp {
  _and: [item_translation_revision_changes_bool_exp]
  _not: item_translation_revision_changes_bool_exp
  _or: [item_translation_revision_changes_bool_exp]
  action: data_actions_enum_comparison_exp
  change_type: data_change_types_enum_comparison_exp
  date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  item_translation_revision: item_translation_revisions_bool_exp
  item_translation_revision_id: uuid_comparison_exp
  to_state: data_states_enum_comparison_exp
  user: staff_users_bool_exp
  user_id: Int_comparison_exp
}

# unique or primary key constraints on table "item_translation_revision_changes"
enum item_translation_revision_changes_constraint {
  # unique or primary key constraint
  item_translation_revision_changes_pkey
}

# input type for incrementing integer column in table "item_translation_revision_changes"
input item_translation_revision_changes_inc_input {
  user_id: Int
}

# input type for inserting data into table "item_translation_revision_changes"
input item_translation_revision_changes_insert_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  date: timestamptz
  id: uuid
  item_translation_revision: item_translation_revisions_obj_rel_insert_input
  item_translation_revision_id: uuid
  to_state: data_states_enum
  user: staff_users_obj_rel_insert_input
  user_id: Int
}

# aggregate max on columns
type item_translation_revision_changes_max_fields {
  date: timestamptz
  id: uuid
  item_translation_revision_id: uuid
  user_id: Int
}

# order by max() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_max_order_by {
  date: order_by
  id: order_by
  item_translation_revision_id: order_by
  user_id: order_by
}

# aggregate min on columns
type item_translation_revision_changes_min_fields {
  date: timestamptz
  id: uuid
  item_translation_revision_id: uuid
  user_id: Int
}

# order by min() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_min_order_by {
  date: order_by
  id: order_by
  item_translation_revision_id: order_by
  user_id: order_by
}

# response of any mutation on the table "item_translation_revision_changes"
type item_translation_revision_changes_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_translation_revision_changes!]!
}

# input type for inserting object relation for remote table "item_translation_revision_changes"
input item_translation_revision_changes_obj_rel_insert_input {
  data: item_translation_revision_changes_insert_input!
  on_conflict: item_translation_revision_changes_on_conflict
}

# on conflict condition type for table "item_translation_revision_changes"
input item_translation_revision_changes_on_conflict {
  constraint: item_translation_revision_changes_constraint!
  update_columns: [item_translation_revision_changes_update_column!]!
  where: item_translation_revision_changes_bool_exp
}

# ordering options when selecting data from "item_translation_revision_changes"
input item_translation_revision_changes_order_by {
  action: order_by
  change_type: order_by
  date: order_by
  id: order_by
  item_translation_revision: item_translation_revisions_order_by
  item_translation_revision_id: order_by
  to_state: order_by
  user: staff_users_order_by
  user_id: order_by
}

# primary key columns input for table: "item_translation_revision_changes"
input item_translation_revision_changes_pk_columns_input {
  id: uuid!
}

# select columns of table "item_translation_revision_changes"
enum item_translation_revision_changes_select_column {
  # column name
  action

  # column name
  change_type

  # column name
  date

  # column name
  id

  # column name
  item_translation_revision_id

  # column name
  to_state

  # column name
  user_id
}

# input type for updating data in table "item_translation_revision_changes"
input item_translation_revision_changes_set_input {
  action: data_actions_enum
  change_type: data_change_types_enum
  date: timestamptz
  id: uuid
  item_translation_revision_id: uuid
  to_state: data_states_enum
  user_id: Int
}

# aggregate stddev on columns
type item_translation_revision_changes_stddev_fields {
  user_id: Float
}

# order by stddev() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_stddev_order_by {
  user_id: order_by
}

# aggregate stddev_pop on columns
type item_translation_revision_changes_stddev_pop_fields {
  user_id: Float
}

# order by stddev_pop() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_stddev_pop_order_by {
  user_id: order_by
}

# aggregate stddev_samp on columns
type item_translation_revision_changes_stddev_samp_fields {
  user_id: Float
}

# order by stddev_samp() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_stddev_samp_order_by {
  user_id: order_by
}

# aggregate sum on columns
type item_translation_revision_changes_sum_fields {
  user_id: Int
}

# order by sum() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_sum_order_by {
  user_id: order_by
}

# update columns of table "item_translation_revision_changes"
enum item_translation_revision_changes_update_column {
  # column name
  action

  # column name
  change_type

  # column name
  date

  # column name
  id

  # column name
  item_translation_revision_id

  # column name
  to_state

  # column name
  user_id
}

# aggregate var_pop on columns
type item_translation_revision_changes_var_pop_fields {
  user_id: Float
}

# order by var_pop() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_var_pop_order_by {
  user_id: order_by
}

# aggregate var_samp on columns
type item_translation_revision_changes_var_samp_fields {
  user_id: Float
}

# order by var_samp() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_var_samp_order_by {
  user_id: order_by
}

# aggregate variance on columns
type item_translation_revision_changes_variance_fields {
  user_id: Float
}

# order by variance() on columns of table "item_translation_revision_changes"
input item_translation_revision_changes_variance_order_by {
  user_id: order_by
}

# A translation revision for items, containing vital control information for it's draft and release versions.
#
#
# columns and relationships of "item_translation_revisions"
#
type item_translation_revisions {
  id: uuid!

  # An object relationship
  item: items!

  # The associated id of the item this translation revision is intended for.
  item_id: Int!

  # An array relationship
  item_translations(
    # distinct select on columns
    distinct_on: [item_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translations_order_by!]

    # filter the rows returned
    where: item_translations_bool_exp
  ): [item_translations!]!

  # An aggregated array relationship
  item_translations_aggregate(
    # distinct select on columns
    distinct_on: [item_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translations_order_by!]

    # filter the rows returned
    where: item_translations_bool_exp
  ): item_translations_aggregate!

  # An object relationship
  locale: locales!

  # The locale code representing the locale that this translation revision is in.
  locale_code: String!

  # The revision or version number of this translation group (of draft and release).
  revision: Int!

  # The data state of this translation revision (e.g. DEVELOPMENT, REVIEW, PRODUCTION and RETIRED).
  state: data_states_enum!
}

# aggregated selection of "item_translation_revisions"
type item_translation_revisions_aggregate {
  aggregate: item_translation_revisions_aggregate_fields
  nodes: [item_translation_revisions!]!
}

# aggregate fields of "item_translation_revisions"
type item_translation_revisions_aggregate_fields {
  avg: item_translation_revisions_avg_fields
  count(columns: [item_translation_revisions_select_column!], distinct: Boolean): Int
  max: item_translation_revisions_max_fields
  min: item_translation_revisions_min_fields
  stddev: item_translation_revisions_stddev_fields
  stddev_pop: item_translation_revisions_stddev_pop_fields
  stddev_samp: item_translation_revisions_stddev_samp_fields
  sum: item_translation_revisions_sum_fields
  var_pop: item_translation_revisions_var_pop_fields
  var_samp: item_translation_revisions_var_samp_fields
  variance: item_translation_revisions_variance_fields
}

# order by aggregate values of table "item_translation_revisions"
input item_translation_revisions_aggregate_order_by {
  avg: item_translation_revisions_avg_order_by
  count: order_by
  max: item_translation_revisions_max_order_by
  min: item_translation_revisions_min_order_by
  stddev: item_translation_revisions_stddev_order_by
  stddev_pop: item_translation_revisions_stddev_pop_order_by
  stddev_samp: item_translation_revisions_stddev_samp_order_by
  sum: item_translation_revisions_sum_order_by
  var_pop: item_translation_revisions_var_pop_order_by
  var_samp: item_translation_revisions_var_samp_order_by
  variance: item_translation_revisions_variance_order_by
}

# input type for inserting array relation for remote table "item_translation_revisions"
input item_translation_revisions_arr_rel_insert_input {
  data: [item_translation_revisions_insert_input!]!
  on_conflict: item_translation_revisions_on_conflict
}

# aggregate avg on columns
type item_translation_revisions_avg_fields {
  item_id: Float
  revision: Float
}

# order by avg() on columns of table "item_translation_revisions"
input item_translation_revisions_avg_order_by {
  item_id: order_by
  revision: order_by
}

# Boolean expression to filter rows from the table "item_translation_revisions". All fields are combined with a logical 'AND'.
input item_translation_revisions_bool_exp {
  _and: [item_translation_revisions_bool_exp]
  _not: item_translation_revisions_bool_exp
  _or: [item_translation_revisions_bool_exp]
  id: uuid_comparison_exp
  item: items_bool_exp
  item_id: Int_comparison_exp
  item_translations: item_translations_bool_exp
  locale: locales_bool_exp
  locale_code: String_comparison_exp
  revision: Int_comparison_exp
  state: data_states_enum_comparison_exp
}

# unique or primary key constraints on table "item_translation_revisions"
enum item_translation_revisions_constraint {
  # unique or primary key constraint
  item_translation_revisions_item_id_locale_code_revision_key1

  # unique or primary key constraint
  item_translation_revisions_pkey
}

# input type for incrementing integer column in table "item_translation_revisions"
input item_translation_revisions_inc_input {
  item_id: Int
  revision: Int
}

# input type for inserting data into table "item_translation_revisions"
input item_translation_revisions_insert_input {
  id: uuid
  item: items_obj_rel_insert_input
  item_id: Int
  item_translations: item_translations_arr_rel_insert_input
  locale: locales_obj_rel_insert_input
  locale_code: String
  revision: Int
  state: data_states_enum
}

# aggregate max on columns
type item_translation_revisions_max_fields {
  id: uuid
  item_id: Int
  locale_code: String
  revision: Int
}

# order by max() on columns of table "item_translation_revisions"
input item_translation_revisions_max_order_by {
  id: order_by
  item_id: order_by
  locale_code: order_by
  revision: order_by
}

# aggregate min on columns
type item_translation_revisions_min_fields {
  id: uuid
  item_id: Int
  locale_code: String
  revision: Int
}

# order by min() on columns of table "item_translation_revisions"
input item_translation_revisions_min_order_by {
  id: order_by
  item_id: order_by
  locale_code: order_by
  revision: order_by
}

# response of any mutation on the table "item_translation_revisions"
type item_translation_revisions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_translation_revisions!]!
}

# input type for inserting object relation for remote table "item_translation_revisions"
input item_translation_revisions_obj_rel_insert_input {
  data: item_translation_revisions_insert_input!
  on_conflict: item_translation_revisions_on_conflict
}

# on conflict condition type for table "item_translation_revisions"
input item_translation_revisions_on_conflict {
  constraint: item_translation_revisions_constraint!
  update_columns: [item_translation_revisions_update_column!]!
  where: item_translation_revisions_bool_exp
}

# ordering options when selecting data from "item_translation_revisions"
input item_translation_revisions_order_by {
  id: order_by
  item: items_order_by
  item_id: order_by
  item_translations_aggregate: item_translations_aggregate_order_by
  locale: locales_order_by
  locale_code: order_by
  revision: order_by
  state: order_by
}

# primary key columns input for table: "item_translation_revisions"
input item_translation_revisions_pk_columns_input {
  id: uuid!
}

# select columns of table "item_translation_revisions"
enum item_translation_revisions_select_column {
  # column name
  id

  # column name
  item_id

  # column name
  locale_code

  # column name
  revision

  # column name
  state
}

# input type for updating data in table "item_translation_revisions"
input item_translation_revisions_set_input {
  id: uuid
  item_id: Int
  locale_code: String
  revision: Int
  state: data_states_enum
}

# aggregate stddev on columns
type item_translation_revisions_stddev_fields {
  item_id: Float
  revision: Float
}

# order by stddev() on columns of table "item_translation_revisions"
input item_translation_revisions_stddev_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate stddev_pop on columns
type item_translation_revisions_stddev_pop_fields {
  item_id: Float
  revision: Float
}

# order by stddev_pop() on columns of table "item_translation_revisions"
input item_translation_revisions_stddev_pop_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate stddev_samp on columns
type item_translation_revisions_stddev_samp_fields {
  item_id: Float
  revision: Float
}

# order by stddev_samp() on columns of table "item_translation_revisions"
input item_translation_revisions_stddev_samp_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate sum on columns
type item_translation_revisions_sum_fields {
  item_id: Int
  revision: Int
}

# order by sum() on columns of table "item_translation_revisions"
input item_translation_revisions_sum_order_by {
  item_id: order_by
  revision: order_by
}

# update columns of table "item_translation_revisions"
enum item_translation_revisions_update_column {
  # column name
  id

  # column name
  item_id

  # column name
  locale_code

  # column name
  revision

  # column name
  state
}

# aggregate var_pop on columns
type item_translation_revisions_var_pop_fields {
  item_id: Float
  revision: Float
}

# order by var_pop() on columns of table "item_translation_revisions"
input item_translation_revisions_var_pop_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate var_samp on columns
type item_translation_revisions_var_samp_fields {
  item_id: Float
  revision: Float
}

# order by var_samp() on columns of table "item_translation_revisions"
input item_translation_revisions_var_samp_order_by {
  item_id: order_by
  revision: order_by
}

# aggregate variance on columns
type item_translation_revisions_variance_fields {
  item_id: Float
  revision: Float
}

# order by variance() on columns of table "item_translation_revisions"
input item_translation_revisions_variance_order_by {
  item_id: order_by
  revision: order_by
}

# Translated text for items in their specific languages.
#
#
# columns and relationships of "item_translations"
#
type item_translations {
  # The stylised description of the item. This is also determined by us so that it
  # appears nicely in the user's mobile app. Redundant information represented by
  # graphs and other page elements should be omitted.
  description: String

  # The full length name of the item. This is the official full name as given by the designer.
  full_name: String!
  id: uuid!

  # Whether or not the translation is a release version (true), or a draft (false).
  is_release: Boolean!

  # An object relationship
  revision: item_translation_revisions!

  # The associated revision id of the item this translation is a part of.
  revision_id: uuid!

  # The short and stylised name of the item. This is determined by us so that the
  # item name may appear nicely in the user's mobile app. It should fit no more
  # than 2 lines (half screen, portrait) and should be shorter than the official name.
  short_name: String
}

# aggregated selection of "item_translations"
type item_translations_aggregate {
  aggregate: item_translations_aggregate_fields
  nodes: [item_translations!]!
}

# aggregate fields of "item_translations"
type item_translations_aggregate_fields {
  count(columns: [item_translations_select_column!], distinct: Boolean): Int
  max: item_translations_max_fields
  min: item_translations_min_fields
}

# order by aggregate values of table "item_translations"
input item_translations_aggregate_order_by {
  count: order_by
  max: item_translations_max_order_by
  min: item_translations_min_order_by
}

# input type for inserting array relation for remote table "item_translations"
input item_translations_arr_rel_insert_input {
  data: [item_translations_insert_input!]!
  on_conflict: item_translations_on_conflict
}

# Boolean expression to filter rows from the table "item_translations". All fields are combined with a logical 'AND'.
input item_translations_bool_exp {
  _and: [item_translations_bool_exp]
  _not: item_translations_bool_exp
  _or: [item_translations_bool_exp]
  description: String_comparison_exp
  full_name: String_comparison_exp
  id: uuid_comparison_exp
  is_release: Boolean_comparison_exp
  revision: item_translation_revisions_bool_exp
  revision_id: uuid_comparison_exp
  short_name: String_comparison_exp
}

# unique or primary key constraints on table "item_translations"
enum item_translations_constraint {
  # unique or primary key constraint
  item_translations_pkey

  # unique or primary key constraint
  item_translations_revision_id_is_release_key
}

# input type for inserting data into table "item_translations"
input item_translations_insert_input {
  description: String
  full_name: String
  id: uuid
  is_release: Boolean
  revision: item_translation_revisions_obj_rel_insert_input
  revision_id: uuid
  short_name: String
}

# aggregate max on columns
type item_translations_max_fields {
  description: String
  full_name: String
  id: uuid
  revision_id: uuid
  short_name: String
}

# order by max() on columns of table "item_translations"
input item_translations_max_order_by {
  description: order_by
  full_name: order_by
  id: order_by
  revision_id: order_by
  short_name: order_by
}

# aggregate min on columns
type item_translations_min_fields {
  description: String
  full_name: String
  id: uuid
  revision_id: uuid
  short_name: String
}

# order by min() on columns of table "item_translations"
input item_translations_min_order_by {
  description: order_by
  full_name: order_by
  id: order_by
  revision_id: order_by
  short_name: order_by
}

# response of any mutation on the table "item_translations"
type item_translations_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_translations!]!
}

# input type for inserting object relation for remote table "item_translations"
input item_translations_obj_rel_insert_input {
  data: item_translations_insert_input!
  on_conflict: item_translations_on_conflict
}

# on conflict condition type for table "item_translations"
input item_translations_on_conflict {
  constraint: item_translations_constraint!
  update_columns: [item_translations_update_column!]!
  where: item_translations_bool_exp
}

# ordering options when selecting data from "item_translations"
input item_translations_order_by {
  description: order_by
  full_name: order_by
  id: order_by
  is_release: order_by
  revision: item_translation_revisions_order_by
  revision_id: order_by
  short_name: order_by
}

# primary key columns input for table: "item_translations"
input item_translations_pk_columns_input {
  id: uuid!
}

# select columns of table "item_translations"
enum item_translations_select_column {
  # column name
  description

  # column name
  full_name

  # column name
  id

  # column name
  is_release

  # column name
  revision_id

  # column name
  short_name
}

# input type for updating data in table "item_translations"
input item_translations_set_input {
  description: String
  full_name: String
  id: uuid
  is_release: Boolean
  revision_id: uuid
  short_name: String
}

# update columns of table "item_translations"
enum item_translations_update_column {
  # column name
  description

  # column name
  full_name

  # column name
  id

  # column name
  is_release

  # column name
  revision_id

  # column name
  short_name
}

# The types a clothing item can be in.
#
#
# columns and relationships of "item_types"
#
type item_types {
  description: String
  value: String!
}

# aggregated selection of "item_types"
type item_types_aggregate {
  aggregate: item_types_aggregate_fields
  nodes: [item_types!]!
}

# aggregate fields of "item_types"
type item_types_aggregate_fields {
  count(columns: [item_types_select_column!], distinct: Boolean): Int
  max: item_types_max_fields
  min: item_types_min_fields
}

# order by aggregate values of table "item_types"
input item_types_aggregate_order_by {
  count: order_by
  max: item_types_max_order_by
  min: item_types_min_order_by
}

# input type for inserting array relation for remote table "item_types"
input item_types_arr_rel_insert_input {
  data: [item_types_insert_input!]!
  on_conflict: item_types_on_conflict
}

# Boolean expression to filter rows from the table "item_types". All fields are combined with a logical 'AND'.
input item_types_bool_exp {
  _and: [item_types_bool_exp]
  _not: item_types_bool_exp
  _or: [item_types_bool_exp]
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "item_types"
enum item_types_constraint {
  # unique or primary key constraint
  item_type_pkey
}

enum item_types_enum {
  Accessory
  Clothing
}

# expression to compare columns of type item_types_enum. All fields are combined with logical 'AND'.
input item_types_enum_comparison_exp {
  _eq: item_types_enum
  _in: [item_types_enum!]
  _is_null: Boolean
  _neq: item_types_enum
  _nin: [item_types_enum!]
}

# input type for inserting data into table "item_types"
input item_types_insert_input {
  description: String
  value: String
}

# aggregate max on columns
type item_types_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "item_types"
input item_types_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type item_types_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "item_types"
input item_types_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "item_types"
type item_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_types!]!
}

# input type for inserting object relation for remote table "item_types"
input item_types_obj_rel_insert_input {
  data: item_types_insert_input!
  on_conflict: item_types_on_conflict
}

# on conflict condition type for table "item_types"
input item_types_on_conflict {
  constraint: item_types_constraint!
  update_columns: [item_types_update_column!]!
  where: item_types_bool_exp
}

# ordering options when selecting data from "item_types"
input item_types_order_by {
  description: order_by
  value: order_by
}

# primary key columns input for table: "item_types"
input item_types_pk_columns_input {
  value: String!
}

# select columns of table "item_types"
enum item_types_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "item_types"
input item_types_set_input {
  description: String
  value: String
}

# update columns of table "item_types"
enum item_types_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "items"
type items {
  created_at: timestamptz
  id: Int!
  item_family_id: Int

  # An array relationship
  item_maindata_revisions(
    # distinct select on columns
    distinct_on: [item_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revisions_order_by!]

    # filter the rows returned
    where: item_maindata_revisions_bool_exp
  ): [item_maindata_revisions!]!

  # An aggregated array relationship
  item_maindata_revisions_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revisions_order_by!]

    # filter the rows returned
    where: item_maindata_revisions_bool_exp
  ): item_maindata_revisions_aggregate!

  # An array relationship
  item_translation_revisions(
    # distinct select on columns
    distinct_on: [item_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revisions_order_by!]

    # filter the rows returned
    where: item_translation_revisions_bool_exp
  ): [item_translation_revisions!]!

  # An aggregated array relationship
  item_translation_revisions_aggregate(
    # distinct select on columns
    distinct_on: [item_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revisions_order_by!]

    # filter the rows returned
    where: item_translation_revisions_bool_exp
  ): item_translation_revisions_aggregate!
  short_id: numeric
  updated_at: timestamptz
}

# aggregated selection of "items"
type items_aggregate {
  aggregate: items_aggregate_fields
  nodes: [items!]!
}

# aggregate fields of "items"
type items_aggregate_fields {
  avg: items_avg_fields
  count(columns: [items_select_column!], distinct: Boolean): Int
  max: items_max_fields
  min: items_min_fields
  stddev: items_stddev_fields
  stddev_pop: items_stddev_pop_fields
  stddev_samp: items_stddev_samp_fields
  sum: items_sum_fields
  var_pop: items_var_pop_fields
  var_samp: items_var_samp_fields
  variance: items_variance_fields
}

# order by aggregate values of table "items"
input items_aggregate_order_by {
  avg: items_avg_order_by
  count: order_by
  max: items_max_order_by
  min: items_min_order_by
  stddev: items_stddev_order_by
  stddev_pop: items_stddev_pop_order_by
  stddev_samp: items_stddev_samp_order_by
  sum: items_sum_order_by
  var_pop: items_var_pop_order_by
  var_samp: items_var_samp_order_by
  variance: items_variance_order_by
}

# input type for inserting array relation for remote table "items"
input items_arr_rel_insert_input {
  data: [items_insert_input!]!
  on_conflict: items_on_conflict
}

# aggregate avg on columns
type items_avg_fields {
  id: Float
  item_family_id: Float
  short_id: Float
}

# order by avg() on columns of table "items"
input items_avg_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# Boolean expression to filter rows from the table "items". All fields are combined with a logical 'AND'.
input items_bool_exp {
  _and: [items_bool_exp]
  _not: items_bool_exp
  _or: [items_bool_exp]
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  item_family_id: Int_comparison_exp
  item_maindata_revisions: item_maindata_revisions_bool_exp
  item_translation_revisions: item_translation_revisions_bool_exp
  short_id: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "items"
enum items_constraint {
  # unique or primary key constraint
  item_pkey

  # unique or primary key constraint
  items_short_id_key
}

# input type for incrementing integer column in table "items"
input items_inc_input {
  id: Int
  item_family_id: Int
  short_id: numeric
}

# input type for inserting data into table "items"
input items_insert_input {
  created_at: timestamptz
  id: Int
  item_family_id: Int
  item_maindata_revisions: item_maindata_revisions_arr_rel_insert_input
  item_translation_revisions: item_translation_revisions_arr_rel_insert_input
  short_id: numeric
  updated_at: timestamptz
}

# aggregate max on columns
type items_max_fields {
  created_at: timestamptz
  id: Int
  item_family_id: Int
  short_id: numeric
  updated_at: timestamptz
}

# order by max() on columns of table "items"
input items_max_order_by {
  created_at: order_by
  id: order_by
  item_family_id: order_by
  short_id: order_by
  updated_at: order_by
}

# aggregate min on columns
type items_min_fields {
  created_at: timestamptz
  id: Int
  item_family_id: Int
  short_id: numeric
  updated_at: timestamptz
}

# order by min() on columns of table "items"
input items_min_order_by {
  created_at: order_by
  id: order_by
  item_family_id: order_by
  short_id: order_by
  updated_at: order_by
}

# response of any mutation on the table "items"
type items_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [items!]!
}

# input type for inserting object relation for remote table "items"
input items_obj_rel_insert_input {
  data: items_insert_input!
  on_conflict: items_on_conflict
}

# on conflict condition type for table "items"
input items_on_conflict {
  constraint: items_constraint!
  update_columns: [items_update_column!]!
  where: items_bool_exp
}

# ordering options when selecting data from "items"
input items_order_by {
  created_at: order_by
  id: order_by
  item_family_id: order_by
  item_maindata_revisions_aggregate: item_maindata_revisions_aggregate_order_by
  item_translation_revisions_aggregate: item_translation_revisions_aggregate_order_by
  short_id: order_by
  updated_at: order_by
}

# primary key columns input for table: "items"
input items_pk_columns_input {
  id: Int!
}

# select columns of table "items"
enum items_select_column {
  # column name
  created_at

  # column name
  id

  # column name
  item_family_id

  # column name
  short_id

  # column name
  updated_at
}

# input type for updating data in table "items"
input items_set_input {
  created_at: timestamptz
  id: Int
  item_family_id: Int
  short_id: numeric
  updated_at: timestamptz
}

# aggregate stddev on columns
type items_stddev_fields {
  id: Float
  item_family_id: Float
  short_id: Float
}

# order by stddev() on columns of table "items"
input items_stddev_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate stddev_pop on columns
type items_stddev_pop_fields {
  id: Float
  item_family_id: Float
  short_id: Float
}

# order by stddev_pop() on columns of table "items"
input items_stddev_pop_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate stddev_samp on columns
type items_stddev_samp_fields {
  id: Float
  item_family_id: Float
  short_id: Float
}

# order by stddev_samp() on columns of table "items"
input items_stddev_samp_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate sum on columns
type items_sum_fields {
  id: Int
  item_family_id: Int
  short_id: numeric
}

# order by sum() on columns of table "items"
input items_sum_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# update columns of table "items"
enum items_update_column {
  # column name
  created_at

  # column name
  id

  # column name
  item_family_id

  # column name
  short_id

  # column name
  updated_at
}

# aggregate var_pop on columns
type items_var_pop_fields {
  id: Float
  item_family_id: Float
  short_id: Float
}

# order by var_pop() on columns of table "items"
input items_var_pop_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate var_samp on columns
type items_var_samp_fields {
  id: Float
  item_family_id: Float
  short_id: Float
}

# order by var_samp() on columns of table "items"
input items_var_samp_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# aggregate variance on columns
type items_variance_fields {
  id: Float
  item_family_id: Float
  short_id: Float
}

# order by variance() on columns of table "items"
input items_variance_order_by {
  id: order_by
  item_family_id: order_by
  short_id: order_by
}

# All the main languages in the world, according to the ISO 639-1 standard. This
# does not encompass regional variants, dialects, etc. but rather only encompasses
# the group that a specific language can be in.
#
#
# columns and relationships of "language_families"
#
type language_families {
  # In this enum implementation, the description is the language name (in English), according to ISO 639-1.
  description: String!

  # In this enum implementation, the value is the 2-letter code of the language, according to ISO 639-1.
  value: String!
}

# aggregated selection of "language_families"
type language_families_aggregate {
  aggregate: language_families_aggregate_fields
  nodes: [language_families!]!
}

# aggregate fields of "language_families"
type language_families_aggregate_fields {
  count(columns: [language_families_select_column!], distinct: Boolean): Int
  max: language_families_max_fields
  min: language_families_min_fields
}

# order by aggregate values of table "language_families"
input language_families_aggregate_order_by {
  count: order_by
  max: language_families_max_order_by
  min: language_families_min_order_by
}

# input type for inserting array relation for remote table "language_families"
input language_families_arr_rel_insert_input {
  data: [language_families_insert_input!]!
  on_conflict: language_families_on_conflict
}

# Boolean expression to filter rows from the table "language_families". All fields are combined with a logical 'AND'.
input language_families_bool_exp {
  _and: [language_families_bool_exp]
  _not: language_families_bool_exp
  _or: [language_families_bool_exp]
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "language_families"
enum language_families_constraint {
  # unique or primary key constraint
  language_families_pkey
}

enum language_families_enum {
  #  German
  de

  #  English
  en

  #  Spanish
  es

  #  French
  fr

  #  Italian
  it

  #  Japanese
  ja

  #  Korean
  ko

  #  Portuguese
  pt

  #  Chinese
  zh
}

# expression to compare columns of type language_families_enum. All fields are combined with logical 'AND'.
input language_families_enum_comparison_exp {
  _eq: language_families_enum
  _in: [language_families_enum!]
  _is_null: Boolean
  _neq: language_families_enum
  _nin: [language_families_enum!]
}

# input type for inserting data into table "language_families"
input language_families_insert_input {
  description: String
  value: String
}

# aggregate max on columns
type language_families_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "language_families"
input language_families_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type language_families_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "language_families"
input language_families_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "language_families"
type language_families_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [language_families!]!
}

# input type for inserting object relation for remote table "language_families"
input language_families_obj_rel_insert_input {
  data: language_families_insert_input!
  on_conflict: language_families_on_conflict
}

# on conflict condition type for table "language_families"
input language_families_on_conflict {
  constraint: language_families_constraint!
  update_columns: [language_families_update_column!]!
  where: language_families_bool_exp
}

# ordering options when selecting data from "language_families"
input language_families_order_by {
  description: order_by
  value: order_by
}

# primary key columns input for table: "language_families"
input language_families_pk_columns_input {
  # In this enum implementation, the value is the 2-letter code of the language, according to ISO 639-1.
  value: String!
}

# select columns of table "language_families"
enum language_families_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "language_families"
input language_families_set_input {
  description: String
  value: String
}

# update columns of table "language_families"
enum language_families_update_column {
  # column name
  description

  # column name
  value
}

# The list of all the unique language and country combinations.
#
#
# columns and relationships of "locales"
#
type locales {
  # The unique code of the locale, expressed in a format "xx-YY", where "xx" is
  # the language family code (ISO 639-1) and "YY" is the country code (ISO 3166-1).
  code: String!

  # An object relationship
  country: countries!

  # The 2 letter country code representing the country of the locale, according to the ISO 3166-1 standard.
  country_code: countries_enum!

  # An object relationship
  language: language_families!

  # The 2 letter language family code representing the language of the locale, according to the ISO 639-1 standard.
  language_code: language_families_enum!

  # A human readable name of the locale, in English.
  name: String!
}

# aggregated selection of "locales"
type locales_aggregate {
  aggregate: locales_aggregate_fields
  nodes: [locales!]!
}

# aggregate fields of "locales"
type locales_aggregate_fields {
  count(columns: [locales_select_column!], distinct: Boolean): Int
  max: locales_max_fields
  min: locales_min_fields
}

# order by aggregate values of table "locales"
input locales_aggregate_order_by {
  count: order_by
  max: locales_max_order_by
  min: locales_min_order_by
}

# input type for inserting array relation for remote table "locales"
input locales_arr_rel_insert_input {
  data: [locales_insert_input!]!
  on_conflict: locales_on_conflict
}

# Boolean expression to filter rows from the table "locales". All fields are combined with a logical 'AND'.
input locales_bool_exp {
  _and: [locales_bool_exp]
  _not: locales_bool_exp
  _or: [locales_bool_exp]
  code: String_comparison_exp
  country: countries_bool_exp
  country_code: countries_enum_comparison_exp
  language: language_families_bool_exp
  language_code: language_families_enum_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "locales"
enum locales_constraint {
  # unique or primary key constraint
  locales_language_country_key

  # unique or primary key constraint
  locales_pkey
}

# input type for inserting data into table "locales"
input locales_insert_input {
  code: String
  country: countries_obj_rel_insert_input
  country_code: countries_enum
  language: language_families_obj_rel_insert_input
  language_code: language_families_enum
  name: String
}

# aggregate max on columns
type locales_max_fields {
  code: String
  name: String
}

# order by max() on columns of table "locales"
input locales_max_order_by {
  code: order_by
  name: order_by
}

# aggregate min on columns
type locales_min_fields {
  code: String
  name: String
}

# order by min() on columns of table "locales"
input locales_min_order_by {
  code: order_by
  name: order_by
}

# response of any mutation on the table "locales"
type locales_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [locales!]!
}

# input type for inserting object relation for remote table "locales"
input locales_obj_rel_insert_input {
  data: locales_insert_input!
  on_conflict: locales_on_conflict
}

# on conflict condition type for table "locales"
input locales_on_conflict {
  constraint: locales_constraint!
  update_columns: [locales_update_column!]!
  where: locales_bool_exp
}

# ordering options when selecting data from "locales"
input locales_order_by {
  code: order_by
  country: countries_order_by
  country_code: order_by
  language: language_families_order_by
  language_code: order_by
  name: order_by
}

# primary key columns input for table: "locales"
input locales_pk_columns_input {
  # The unique code of the locale, expressed in a format "xx-YY", where "xx" is
  # the language family code (ISO 639-1) and "YY" is the country code (ISO 3166-1).
  code: String!
}

# select columns of table "locales"
enum locales_select_column {
  # column name
  code

  # column name
  country_code

  # column name
  language_code

  # column name
  name
}

# input type for updating data in table "locales"
input locales_set_input {
  code: String
  country_code: countries_enum
  language_code: language_families_enum
  name: String
}

# update columns of table "locales"
enum locales_update_column {
  # column name
  code

  # column name
  country_code

  # column name
  language_code

  # column name
  name
}

# columns and relationships of "materials"
type materials {
  fabric_id: Int
  id: smallint!

  # An array relationship
  materials_mix_parts(
    # distinct select on columns
    distinct_on: [materials_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_mix_parts_order_by!]

    # filter the rows returned
    where: materials_mix_parts_bool_exp
  ): [materials_mix_parts!]!

  # An aggregated array relationship
  materials_mix_parts_aggregate(
    # distinct select on columns
    distinct_on: [materials_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_mix_parts_order_by!]

    # filter the rows returned
    where: materials_mix_parts_bool_exp
  ): materials_mix_parts_aggregate!
  name: String!
  non_fabric_id: Int
}

# aggregated selection of "materials"
type materials_aggregate {
  aggregate: materials_aggregate_fields
  nodes: [materials!]!
}

# aggregate fields of "materials"
type materials_aggregate_fields {
  avg: materials_avg_fields
  count(columns: [materials_select_column!], distinct: Boolean): Int
  max: materials_max_fields
  min: materials_min_fields
  stddev: materials_stddev_fields
  stddev_pop: materials_stddev_pop_fields
  stddev_samp: materials_stddev_samp_fields
  sum: materials_sum_fields
  var_pop: materials_var_pop_fields
  var_samp: materials_var_samp_fields
  variance: materials_variance_fields
}

# order by aggregate values of table "materials"
input materials_aggregate_order_by {
  avg: materials_avg_order_by
  count: order_by
  max: materials_max_order_by
  min: materials_min_order_by
  stddev: materials_stddev_order_by
  stddev_pop: materials_stddev_pop_order_by
  stddev_samp: materials_stddev_samp_order_by
  sum: materials_sum_order_by
  var_pop: materials_var_pop_order_by
  var_samp: materials_var_samp_order_by
  variance: materials_variance_order_by
}

# input type for inserting array relation for remote table "materials"
input materials_arr_rel_insert_input {
  data: [materials_insert_input!]!
  on_conflict: materials_on_conflict
}

# aggregate avg on columns
type materials_avg_fields {
  fabric_id: Float
  id: Float
  non_fabric_id: Float
}

# order by avg() on columns of table "materials"
input materials_avg_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# Boolean expression to filter rows from the table "materials". All fields are combined with a logical 'AND'.
input materials_bool_exp {
  _and: [materials_bool_exp]
  _not: materials_bool_exp
  _or: [materials_bool_exp]
  fabric_id: Int_comparison_exp
  id: smallint_comparison_exp
  materials_mix_parts: materials_mix_parts_bool_exp
  name: String_comparison_exp
  non_fabric_id: Int_comparison_exp
}

# unique or primary key constraints on table "materials"
enum materials_constraint {
  # unique or primary key constraint
  materials_name_key

  # unique or primary key constraint
  materials_pkey
}

# input type for incrementing integer column in table "materials"
input materials_inc_input {
  fabric_id: Int
  id: smallint
  non_fabric_id: Int
}

# input type for inserting data into table "materials"
input materials_insert_input {
  fabric_id: Int
  id: smallint
  materials_mix_parts: materials_mix_parts_arr_rel_insert_input
  name: String
  non_fabric_id: Int
}

# aggregate max on columns
type materials_max_fields {
  fabric_id: Int
  id: smallint
  name: String
  non_fabric_id: Int
}

# order by max() on columns of table "materials"
input materials_max_order_by {
  fabric_id: order_by
  id: order_by
  name: order_by
  non_fabric_id: order_by
}

# aggregate min on columns
type materials_min_fields {
  fabric_id: Int
  id: smallint
  name: String
  non_fabric_id: Int
}

# order by min() on columns of table "materials"
input materials_min_order_by {
  fabric_id: order_by
  id: order_by
  name: order_by
  non_fabric_id: order_by
}

# columns and relationships of "materials_mix_parts"
type materials_mix_parts {
  id: Int!

  # An object relationship
  material: materials!
  material_id: Int!
  percent: numeric!
}

# aggregated selection of "materials_mix_parts"
type materials_mix_parts_aggregate {
  aggregate: materials_mix_parts_aggregate_fields
  nodes: [materials_mix_parts!]!
}

# aggregate fields of "materials_mix_parts"
type materials_mix_parts_aggregate_fields {
  avg: materials_mix_parts_avg_fields
  count(columns: [materials_mix_parts_select_column!], distinct: Boolean): Int
  max: materials_mix_parts_max_fields
  min: materials_mix_parts_min_fields
  stddev: materials_mix_parts_stddev_fields
  stddev_pop: materials_mix_parts_stddev_pop_fields
  stddev_samp: materials_mix_parts_stddev_samp_fields
  sum: materials_mix_parts_sum_fields
  var_pop: materials_mix_parts_var_pop_fields
  var_samp: materials_mix_parts_var_samp_fields
  variance: materials_mix_parts_variance_fields
}

# order by aggregate values of table "materials_mix_parts"
input materials_mix_parts_aggregate_order_by {
  avg: materials_mix_parts_avg_order_by
  count: order_by
  max: materials_mix_parts_max_order_by
  min: materials_mix_parts_min_order_by
  stddev: materials_mix_parts_stddev_order_by
  stddev_pop: materials_mix_parts_stddev_pop_order_by
  stddev_samp: materials_mix_parts_stddev_samp_order_by
  sum: materials_mix_parts_sum_order_by
  var_pop: materials_mix_parts_var_pop_order_by
  var_samp: materials_mix_parts_var_samp_order_by
  variance: materials_mix_parts_variance_order_by
}

# input type for inserting array relation for remote table "materials_mix_parts"
input materials_mix_parts_arr_rel_insert_input {
  data: [materials_mix_parts_insert_input!]!
  on_conflict: materials_mix_parts_on_conflict
}

# aggregate avg on columns
type materials_mix_parts_avg_fields {
  id: Float
  material_id: Float
  percent: Float
}

# order by avg() on columns of table "materials_mix_parts"
input materials_mix_parts_avg_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# Boolean expression to filter rows from the table "materials_mix_parts". All fields are combined with a logical 'AND'.
input materials_mix_parts_bool_exp {
  _and: [materials_mix_parts_bool_exp]
  _not: materials_mix_parts_bool_exp
  _or: [materials_mix_parts_bool_exp]
  id: Int_comparison_exp
  material: materials_bool_exp
  material_id: Int_comparison_exp
  percent: numeric_comparison_exp
}

# unique or primary key constraints on table "materials_mix_parts"
enum materials_mix_parts_constraint {
  # unique or primary key constraint
  materials_mix_parts_pkey
}

# input type for incrementing integer column in table "materials_mix_parts"
input materials_mix_parts_inc_input {
  id: Int
  material_id: Int
  percent: numeric
}

# input type for inserting data into table "materials_mix_parts"
input materials_mix_parts_insert_input {
  id: Int
  material: materials_obj_rel_insert_input
  material_id: Int
  percent: numeric
}

# aggregate max on columns
type materials_mix_parts_max_fields {
  id: Int
  material_id: Int
  percent: numeric
}

# order by max() on columns of table "materials_mix_parts"
input materials_mix_parts_max_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# aggregate min on columns
type materials_mix_parts_min_fields {
  id: Int
  material_id: Int
  percent: numeric
}

# order by min() on columns of table "materials_mix_parts"
input materials_mix_parts_min_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# response of any mutation on the table "materials_mix_parts"
type materials_mix_parts_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [materials_mix_parts!]!
}

# input type for inserting object relation for remote table "materials_mix_parts"
input materials_mix_parts_obj_rel_insert_input {
  data: materials_mix_parts_insert_input!
  on_conflict: materials_mix_parts_on_conflict
}

# on conflict condition type for table "materials_mix_parts"
input materials_mix_parts_on_conflict {
  constraint: materials_mix_parts_constraint!
  update_columns: [materials_mix_parts_update_column!]!
  where: materials_mix_parts_bool_exp
}

# ordering options when selecting data from "materials_mix_parts"
input materials_mix_parts_order_by {
  id: order_by
  material: materials_order_by
  material_id: order_by
  percent: order_by
}

# primary key columns input for table: "materials_mix_parts"
input materials_mix_parts_pk_columns_input {
  id: Int!
}

# select columns of table "materials_mix_parts"
enum materials_mix_parts_select_column {
  # column name
  id

  # column name
  material_id

  # column name
  percent
}

# input type for updating data in table "materials_mix_parts"
input materials_mix_parts_set_input {
  id: Int
  material_id: Int
  percent: numeric
}

# aggregate stddev on columns
type materials_mix_parts_stddev_fields {
  id: Float
  material_id: Float
  percent: Float
}

# order by stddev() on columns of table "materials_mix_parts"
input materials_mix_parts_stddev_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# aggregate stddev_pop on columns
type materials_mix_parts_stddev_pop_fields {
  id: Float
  material_id: Float
  percent: Float
}

# order by stddev_pop() on columns of table "materials_mix_parts"
input materials_mix_parts_stddev_pop_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# aggregate stddev_samp on columns
type materials_mix_parts_stddev_samp_fields {
  id: Float
  material_id: Float
  percent: Float
}

# order by stddev_samp() on columns of table "materials_mix_parts"
input materials_mix_parts_stddev_samp_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# aggregate sum on columns
type materials_mix_parts_sum_fields {
  id: Int
  material_id: Int
  percent: numeric
}

# order by sum() on columns of table "materials_mix_parts"
input materials_mix_parts_sum_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# update columns of table "materials_mix_parts"
enum materials_mix_parts_update_column {
  # column name
  id

  # column name
  material_id

  # column name
  percent
}

# aggregate var_pop on columns
type materials_mix_parts_var_pop_fields {
  id: Float
  material_id: Float
  percent: Float
}

# order by var_pop() on columns of table "materials_mix_parts"
input materials_mix_parts_var_pop_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# aggregate var_samp on columns
type materials_mix_parts_var_samp_fields {
  id: Float
  material_id: Float
  percent: Float
}

# order by var_samp() on columns of table "materials_mix_parts"
input materials_mix_parts_var_samp_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# aggregate variance on columns
type materials_mix_parts_variance_fields {
  id: Float
  material_id: Float
  percent: Float
}

# order by variance() on columns of table "materials_mix_parts"
input materials_mix_parts_variance_order_by {
  id: order_by
  material_id: order_by
  percent: order_by
}

# response of any mutation on the table "materials"
type materials_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [materials!]!
}

# input type for inserting object relation for remote table "materials"
input materials_obj_rel_insert_input {
  data: materials_insert_input!
  on_conflict: materials_on_conflict
}

# on conflict condition type for table "materials"
input materials_on_conflict {
  constraint: materials_constraint!
  update_columns: [materials_update_column!]!
  where: materials_bool_exp
}

# ordering options when selecting data from "materials"
input materials_order_by {
  fabric_id: order_by
  id: order_by
  materials_mix_parts_aggregate: materials_mix_parts_aggregate_order_by
  name: order_by
  non_fabric_id: order_by
}

# primary key columns input for table: "materials"
input materials_pk_columns_input {
  id: smallint!
}

# select columns of table "materials"
enum materials_select_column {
  # column name
  fabric_id

  # column name
  id

  # column name
  name

  # column name
  non_fabric_id
}

# input type for updating data in table "materials"
input materials_set_input {
  fabric_id: Int
  id: smallint
  name: String
  non_fabric_id: Int
}

# aggregate stddev on columns
type materials_stddev_fields {
  fabric_id: Float
  id: Float
  non_fabric_id: Float
}

# order by stddev() on columns of table "materials"
input materials_stddev_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# aggregate stddev_pop on columns
type materials_stddev_pop_fields {
  fabric_id: Float
  id: Float
  non_fabric_id: Float
}

# order by stddev_pop() on columns of table "materials"
input materials_stddev_pop_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# aggregate stddev_samp on columns
type materials_stddev_samp_fields {
  fabric_id: Float
  id: Float
  non_fabric_id: Float
}

# order by stddev_samp() on columns of table "materials"
input materials_stddev_samp_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# aggregate sum on columns
type materials_sum_fields {
  fabric_id: Int
  id: smallint
  non_fabric_id: Int
}

# order by sum() on columns of table "materials"
input materials_sum_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# update columns of table "materials"
enum materials_update_column {
  # column name
  fabric_id

  # column name
  id

  # column name
  name

  # column name
  non_fabric_id
}

# aggregate var_pop on columns
type materials_var_pop_fields {
  fabric_id: Float
  id: Float
  non_fabric_id: Float
}

# order by var_pop() on columns of table "materials"
input materials_var_pop_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# aggregate var_samp on columns
type materials_var_samp_fields {
  fabric_id: Float
  id: Float
  non_fabric_id: Float
}

# order by var_samp() on columns of table "materials"
input materials_var_samp_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# aggregate variance on columns
type materials_variance_fields {
  fabric_id: Float
  id: Float
  non_fabric_id: Float
}

# order by variance() on columns of table "materials"
input materials_variance_order_by {
  fabric_id: order_by
  id: order_by
  non_fabric_id: order_by
}

# mutation root
type mutation_root {
  # delete data from the table: "base_colours"
  delete_base_colours(
    # filter the rows which have to be deleted
    where: base_colours_bool_exp!
  ): base_colours_mutation_response

  # delete single row from the table: "base_colours"
  delete_base_colours_by_pk(value: String!): base_colours

  # delete data from the table: "body_groups"
  delete_body_groups(
    # filter the rows which have to be deleted
    where: body_groups_bool_exp!
  ): body_groups_mutation_response

  # delete single row from the table: "body_groups"
  delete_body_groups_by_pk(value: String!): body_groups

  # delete data from the table: "body_segment_mask_shapes"
  delete_body_segment_mask_shapes(
    # filter the rows which have to be deleted
    where: body_segment_mask_shapes_bool_exp!
  ): body_segment_mask_shapes_mutation_response

  # delete single row from the table: "body_segment_mask_shapes"
  delete_body_segment_mask_shapes_by_pk(value: String!): body_segment_mask_shapes

  # delete data from the table: "body_segment_masks"
  delete_body_segment_masks(
    # filter the rows which have to be deleted
    where: body_segment_masks_bool_exp!
  ): body_segment_masks_mutation_response

  # delete single row from the table: "body_segment_masks"
  delete_body_segment_masks_by_pk(id: Int!): body_segment_masks

  # delete data from the table: "body_segments"
  delete_body_segments(
    # filter the rows which have to be deleted
    where: body_segments_bool_exp!
  ): body_segments_mutation_response

  # delete single row from the table: "body_segments"
  delete_body_segments_by_pk(id: Int!): body_segments

  # delete data from the table: "clothing_features"
  delete_clothing_features(
    # filter the rows which have to be deleted
    where: clothing_features_bool_exp!
  ): clothing_features_mutation_response

  # delete single row from the table: "clothing_features"
  delete_clothing_features_by_pk(value: String!): clothing_features

  # delete data from the table: "clothing_masks"
  delete_clothing_masks(
    # filter the rows which have to be deleted
    where: clothing_masks_bool_exp!
  ): clothing_masks_mutation_response

  # delete single row from the table: "clothing_masks"
  delete_clothing_masks_by_pk(id: Int!): clothing_masks

  # delete data from the table: "clothing_segment_bounds"
  delete_clothing_segment_bounds(
    # filter the rows which have to be deleted
    where: clothing_segment_bounds_bool_exp!
  ): clothing_segment_bounds_mutation_response

  # delete single row from the table: "clothing_segment_bounds"
  delete_clothing_segment_bounds_by_pk(value: smallint!): clothing_segment_bounds

  # delete data from the table: "clothing_segment_data"
  delete_clothing_segment_data(
    # filter the rows which have to be deleted
    where: clothing_segment_data_bool_exp!
  ): clothing_segment_data_mutation_response

  # delete single row from the table: "clothing_segment_data"
  delete_clothing_segment_data_by_pk(id: uuid!): clothing_segment_data

  # delete data from the table: "clothing_shell_and_body_segment_mask"
  delete_clothing_shell_and_body_segment_mask(
    # filter the rows which have to be deleted
    where: clothing_shell_and_body_segment_mask_bool_exp!
  ): clothing_shell_and_body_segment_mask_mutation_response

  # delete single row from the table: "clothing_shell_and_body_segment_mask"
  delete_clothing_shell_and_body_segment_mask_by_pk(body_segment_mask_id: Int!, clothing_shell_id: Int!): clothing_shell_and_body_segment_mask

  # delete data from the table: "clothing_shell_and_clothing_feature"
  delete_clothing_shell_and_clothing_feature(
    # filter the rows which have to be deleted
    where: clothing_shell_and_clothing_feature_bool_exp!
  ): clothing_shell_and_clothing_feature_mutation_response

  # delete single row from the table: "clothing_shell_and_clothing_feature"
  delete_clothing_shell_and_clothing_feature_by_pk(clothing_feature: String!, clothing_shell_id: Int!): clothing_shell_and_clothing_feature

  # delete data from the table: "clothing_shell_counts"
  delete_clothing_shell_counts(
    # filter the rows which have to be deleted
    where: clothing_shell_counts_bool_exp!
  ): clothing_shell_counts_mutation_response

  # delete single row from the table: "clothing_shell_counts"
  delete_clothing_shell_counts_by_pk(id: Int!): clothing_shell_counts

  # delete data from the table: "clothing_shell_maindata"
  delete_clothing_shell_maindata(
    # filter the rows which have to be deleted
    where: clothing_shell_maindata_bool_exp!
  ): clothing_shell_maindata_mutation_response

  # delete single row from the table: "clothing_shell_maindata"
  delete_clothing_shell_maindata_by_pk(id: uuid!): clothing_shell_maindata

  # delete data from the table: "clothing_shell_maindata_revision_changes"
  delete_clothing_shell_maindata_revision_changes(
    # filter the rows which have to be deleted
    where: clothing_shell_maindata_revision_changes_bool_exp!
  ): clothing_shell_maindata_revision_changes_mutation_response

  # delete single row from the table: "clothing_shell_maindata_revision_changes"
  delete_clothing_shell_maindata_revision_changes_by_pk(id: uuid!): clothing_shell_maindata_revision_changes

  # delete data from the table: "clothing_shell_maindata_revisions"
  delete_clothing_shell_maindata_revisions(
    # filter the rows which have to be deleted
    where: clothing_shell_maindata_revisions_bool_exp!
  ): clothing_shell_maindata_revisions_mutation_response

  # delete single row from the table: "clothing_shell_maindata_revisions"
  delete_clothing_shell_maindata_revisions_by_pk(id: uuid!): clothing_shell_maindata_revisions

  # delete data from the table: "clothing_shells"
  delete_clothing_shells(
    # filter the rows which have to be deleted
    where: clothing_shells_bool_exp!
  ): clothing_shells_mutation_response

  # delete single row from the table: "clothing_shells"
  delete_clothing_shells_by_pk(id: Int!): clothing_shells

  # delete data from the table: "collab_company_and_collection"
  delete_collab_company_and_collection(
    # filter the rows which have to be deleted
    where: collab_company_and_collection_bool_exp!
  ): collab_company_and_collection_mutation_response

  # delete single row from the table: "collab_company_and_collection"
  delete_collab_company_and_collection_by_pk(collection_id: Int!, company_id: Int!): collab_company_and_collection

  # delete data from the table: "collections"
  delete_collections(
    # filter the rows which have to be deleted
    where: collections_bool_exp!
  ): collections_mutation_response

  # delete single row from the table: "collections"
  delete_collections_by_pk(id: Int!): collections

  # delete data from the table: "colour_mix_parts"
  delete_colour_mix_parts(
    # filter the rows which have to be deleted
    where: colour_mix_parts_bool_exp!
  ): colour_mix_parts_mutation_response

  # delete single row from the table: "colour_mix_parts"
  delete_colour_mix_parts_by_pk(id: Int!): colour_mix_parts

  # delete data from the table: "colours"
  delete_colours(
    # filter the rows which have to be deleted
    where: colours_bool_exp!
  ): colours_mutation_response

  # delete single row from the table: "colours"
  delete_colours_by_pk(id: Int!): colours

  # delete data from the table: "companies"
  delete_companies(
    # filter the rows which have to be deleted
    where: companies_bool_exp!
  ): companies_mutation_response

  # delete single row from the table: "companies"
  delete_companies_by_pk(id: Int!): companies

  # delete data from the table: "company_counts"
  delete_company_counts(
    # filter the rows which have to be deleted
    where: company_counts_bool_exp!
  ): company_counts_mutation_response

  # delete single row from the table: "company_counts"
  delete_company_counts_by_pk(id: Int!): company_counts

  # delete data from the table: "company_translation_revision_changes"
  delete_company_translation_revision_changes(
    # filter the rows which have to be deleted
    where: company_translation_revision_changes_bool_exp!
  ): company_translation_revision_changes_mutation_response

  # delete single row from the table: "company_translation_revision_changes"
  delete_company_translation_revision_changes_by_pk(id: uuid!): company_translation_revision_changes

  # delete data from the table: "company_translation_revisions"
  delete_company_translation_revisions(
    # filter the rows which have to be deleted
    where: company_translation_revisions_bool_exp!
  ): company_translation_revisions_mutation_response

  # delete single row from the table: "company_translation_revisions"
  delete_company_translation_revisions_by_pk(id: uuid!): company_translation_revisions

  # delete data from the table: "company_translations"
  delete_company_translations(
    # filter the rows which have to be deleted
    where: company_translations_bool_exp!
  ): company_translations_mutation_response

  # delete single row from the table: "company_translations"
  delete_company_translations_by_pk(id: uuid!): company_translations

  # delete data from the table: "countries"
  delete_countries(
    # filter the rows which have to be deleted
    where: countries_bool_exp!
  ): countries_mutation_response

  # delete single row from the table: "countries"
  delete_countries_by_pk(
    # In this enum implementation, the value is the 2-letter Alpha-2 code of the country, according to ISO 3166-1.
    value: String!
  ): countries

  # delete data from the table: "data_actions"
  delete_data_actions(
    # filter the rows which have to be deleted
    where: data_actions_bool_exp!
  ): data_actions_mutation_response

  # delete single row from the table: "data_actions"
  delete_data_actions_by_pk(value: String!): data_actions

  # delete data from the table: "data_change_types"
  delete_data_change_types(
    # filter the rows which have to be deleted
    where: data_change_types_bool_exp!
  ): data_change_types_mutation_response

  # delete single row from the table: "data_change_types"
  delete_data_change_types_by_pk(value: String!): data_change_types

  # delete data from the table: "data_promotions"
  delete_data_promotions(
    # filter the rows which have to be deleted
    where: data_promotions_bool_exp!
  ): data_promotions_mutation_response

  # delete single row from the table: "data_promotions"
  delete_data_promotions_by_pk(id: Int!): data_promotions

  # delete data from the table: "data_release_types"
  delete_data_release_types(
    # filter the rows which have to be deleted
    where: data_release_types_bool_exp!
  ): data_release_types_mutation_response

  # delete single row from the table: "data_release_types"
  delete_data_release_types_by_pk(value: String!): data_release_types

  # delete data from the table: "data_states"
  delete_data_states(
    # filter the rows which have to be deleted
    where: data_states_bool_exp!
  ): data_states_mutation_response

  # delete single row from the table: "data_states"
  delete_data_states_by_pk(value: String!): data_states

  # delete data from the table: "fabric_layer_and_colour_mix_part"
  delete_fabric_layer_and_colour_mix_part(
    # filter the rows which have to be deleted
    where: fabric_layer_and_colour_mix_part_bool_exp!
  ): fabric_layer_and_colour_mix_part_mutation_response

  # delete single row from the table: "fabric_layer_and_colour_mix_part"
  delete_fabric_layer_and_colour_mix_part_by_pk(colour_mix_part_id: Int!, fabric_layer_id: Int!): fabric_layer_and_colour_mix_part

  # delete data from the table: "fabric_layer_types"
  delete_fabric_layer_types(
    # filter the rows which have to be deleted
    where: fabric_layer_types_bool_exp!
  ): fabric_layer_types_mutation_response

  # delete single row from the table: "fabric_layer_types"
  delete_fabric_layer_types_by_pk(value: String!): fabric_layer_types

  # delete data from the table: "fabric_layers"
  delete_fabric_layers(
    # filter the rows which have to be deleted
    where: fabric_layers_bool_exp!
  ): fabric_layers_mutation_response

  # delete single row from the table: "fabric_layers"
  delete_fabric_layers_by_pk(id: Int!): fabric_layers

  # delete data from the table: "fabric_types"
  delete_fabric_types(
    # filter the rows which have to be deleted
    where: fabric_types_bool_exp!
  ): fabric_types_mutation_response

  # delete single row from the table: "fabric_types"
  delete_fabric_types_by_pk(id: smallint!): fabric_types

  # delete data from the table: "genders"
  delete_genders(
    # filter the rows which have to be deleted
    where: genders_bool_exp!
  ): genders_mutation_response

  # delete single row from the table: "genders"
  delete_genders_by_pk(value: String!): genders

  # delete data from the table: "item_and_clothing_shell"
  delete_item_and_clothing_shell(
    # filter the rows which have to be deleted
    where: item_and_clothing_shell_bool_exp!
  ): item_and_clothing_shell_mutation_response

  # delete single row from the table: "item_and_clothing_shell"
  delete_item_and_clothing_shell_by_pk(clothing_shell_id: Int!, item_id: Int!): item_and_clothing_shell

  # delete data from the table: "item_families"
  delete_item_families(
    # filter the rows which have to be deleted
    where: item_families_bool_exp!
  ): item_families_mutation_response

  # delete single row from the table: "item_families"
  delete_item_families_by_pk(id: Int!): item_families

  # delete data from the table: "item_maindata"
  delete_item_maindata(
    # filter the rows which have to be deleted
    where: item_maindata_bool_exp!
  ): item_maindata_mutation_response

  # delete single row from the table: "item_maindata"
  delete_item_maindata_by_pk(id: uuid!): item_maindata

  # delete data from the table: "item_maindata_revision_changes"
  delete_item_maindata_revision_changes(
    # filter the rows which have to be deleted
    where: item_maindata_revision_changes_bool_exp!
  ): item_maindata_revision_changes_mutation_response

  # delete single row from the table: "item_maindata_revision_changes"
  delete_item_maindata_revision_changes_by_pk(id: uuid!): item_maindata_revision_changes

  # delete data from the table: "item_maindata_revisions"
  delete_item_maindata_revisions(
    # filter the rows which have to be deleted
    where: item_maindata_revisions_bool_exp!
  ): item_maindata_revisions_mutation_response

  # delete single row from the table: "item_maindata_revisions"
  delete_item_maindata_revisions_by_pk(id: uuid!): item_maindata_revisions

  # delete data from the table: "item_translation_revision_changes"
  delete_item_translation_revision_changes(
    # filter the rows which have to be deleted
    where: item_translation_revision_changes_bool_exp!
  ): item_translation_revision_changes_mutation_response

  # delete single row from the table: "item_translation_revision_changes"
  delete_item_translation_revision_changes_by_pk(id: uuid!): item_translation_revision_changes

  # delete data from the table: "item_translation_revisions"
  delete_item_translation_revisions(
    # filter the rows which have to be deleted
    where: item_translation_revisions_bool_exp!
  ): item_translation_revisions_mutation_response

  # delete single row from the table: "item_translation_revisions"
  delete_item_translation_revisions_by_pk(id: uuid!): item_translation_revisions

  # delete data from the table: "item_translations"
  delete_item_translations(
    # filter the rows which have to be deleted
    where: item_translations_bool_exp!
  ): item_translations_mutation_response

  # delete single row from the table: "item_translations"
  delete_item_translations_by_pk(id: uuid!): item_translations

  # delete data from the table: "item_types"
  delete_item_types(
    # filter the rows which have to be deleted
    where: item_types_bool_exp!
  ): item_types_mutation_response

  # delete single row from the table: "item_types"
  delete_item_types_by_pk(value: String!): item_types

  # delete data from the table: "items"
  delete_items(
    # filter the rows which have to be deleted
    where: items_bool_exp!
  ): items_mutation_response

  # delete single row from the table: "items"
  delete_items_by_pk(id: Int!): items

  # delete data from the table: "language_families"
  delete_language_families(
    # filter the rows which have to be deleted
    where: language_families_bool_exp!
  ): language_families_mutation_response

  # delete single row from the table: "language_families"
  delete_language_families_by_pk(
    # In this enum implementation, the value is the 2-letter code of the language, according to ISO 639-1.
    value: String!
  ): language_families

  # delete data from the table: "locales"
  delete_locales(
    # filter the rows which have to be deleted
    where: locales_bool_exp!
  ): locales_mutation_response

  # delete single row from the table: "locales"
  delete_locales_by_pk(
    # The unique code of the locale, expressed in a format "xx-YY", where "xx" is
    # the language family code (ISO 639-1) and "YY" is the country code (ISO 3166-1).
    code: String!
  ): locales

  # delete data from the table: "materials"
  delete_materials(
    # filter the rows which have to be deleted
    where: materials_bool_exp!
  ): materials_mutation_response

  # delete single row from the table: "materials"
  delete_materials_by_pk(id: smallint!): materials

  # delete data from the table: "materials_mix_parts"
  delete_materials_mix_parts(
    # filter the rows which have to be deleted
    where: materials_mix_parts_bool_exp!
  ): materials_mix_parts_mutation_response

  # delete single row from the table: "materials_mix_parts"
  delete_materials_mix_parts_by_pk(id: Int!): materials_mix_parts

  # delete data from the table: "staff_users"
  delete_staff_users(
    # filter the rows which have to be deleted
    where: staff_users_bool_exp!
  ): staff_users_mutation_response

  # delete single row from the table: "staff_users"
  delete_staff_users_by_pk(id: Int!): staff_users

  # delete data from the table: "version_cms_items_db"
  delete_version_cms_items_db(
    # filter the rows which have to be deleted
    where: version_cms_items_db_bool_exp!
  ): version_cms_items_db_mutation_response

  # delete single row from the table: "version_cms_items_db"
  delete_version_cms_items_db_by_pk(id: Int!): version_cms_items_db

  # insert data into the table: "base_colours"
  insert_base_colours(
    # the rows to be inserted
    objects: [base_colours_insert_input!]!

    # on conflict condition
    on_conflict: base_colours_on_conflict
  ): base_colours_mutation_response

  # insert a single row into the table: "base_colours"
  insert_base_colours_one(
    # the row to be inserted
    object: base_colours_insert_input!

    # on conflict condition
    on_conflict: base_colours_on_conflict
  ): base_colours

  # insert data into the table: "body_groups"
  insert_body_groups(
    # the rows to be inserted
    objects: [body_groups_insert_input!]!

    # on conflict condition
    on_conflict: body_groups_on_conflict
  ): body_groups_mutation_response

  # insert a single row into the table: "body_groups"
  insert_body_groups_one(
    # the row to be inserted
    object: body_groups_insert_input!

    # on conflict condition
    on_conflict: body_groups_on_conflict
  ): body_groups

  # insert data into the table: "body_segment_mask_shapes"
  insert_body_segment_mask_shapes(
    # the rows to be inserted
    objects: [body_segment_mask_shapes_insert_input!]!

    # on conflict condition
    on_conflict: body_segment_mask_shapes_on_conflict
  ): body_segment_mask_shapes_mutation_response

  # insert a single row into the table: "body_segment_mask_shapes"
  insert_body_segment_mask_shapes_one(
    # the row to be inserted
    object: body_segment_mask_shapes_insert_input!

    # on conflict condition
    on_conflict: body_segment_mask_shapes_on_conflict
  ): body_segment_mask_shapes

  # insert data into the table: "body_segment_masks"
  insert_body_segment_masks(
    # the rows to be inserted
    objects: [body_segment_masks_insert_input!]!

    # on conflict condition
    on_conflict: body_segment_masks_on_conflict
  ): body_segment_masks_mutation_response

  # insert a single row into the table: "body_segment_masks"
  insert_body_segment_masks_one(
    # the row to be inserted
    object: body_segment_masks_insert_input!

    # on conflict condition
    on_conflict: body_segment_masks_on_conflict
  ): body_segment_masks

  # insert data into the table: "body_segments"
  insert_body_segments(
    # the rows to be inserted
    objects: [body_segments_insert_input!]!

    # on conflict condition
    on_conflict: body_segments_on_conflict
  ): body_segments_mutation_response

  # insert a single row into the table: "body_segments"
  insert_body_segments_one(
    # the row to be inserted
    object: body_segments_insert_input!

    # on conflict condition
    on_conflict: body_segments_on_conflict
  ): body_segments

  # insert data into the table: "clothing_features"
  insert_clothing_features(
    # the rows to be inserted
    objects: [clothing_features_insert_input!]!

    # on conflict condition
    on_conflict: clothing_features_on_conflict
  ): clothing_features_mutation_response

  # insert a single row into the table: "clothing_features"
  insert_clothing_features_one(
    # the row to be inserted
    object: clothing_features_insert_input!

    # on conflict condition
    on_conflict: clothing_features_on_conflict
  ): clothing_features

  # insert data into the table: "clothing_masks"
  insert_clothing_masks(
    # the rows to be inserted
    objects: [clothing_masks_insert_input!]!

    # on conflict condition
    on_conflict: clothing_masks_on_conflict
  ): clothing_masks_mutation_response

  # insert a single row into the table: "clothing_masks"
  insert_clothing_masks_one(
    # the row to be inserted
    object: clothing_masks_insert_input!

    # on conflict condition
    on_conflict: clothing_masks_on_conflict
  ): clothing_masks

  # insert data into the table: "clothing_segment_bounds"
  insert_clothing_segment_bounds(
    # the rows to be inserted
    objects: [clothing_segment_bounds_insert_input!]!

    # on conflict condition
    on_conflict: clothing_segment_bounds_on_conflict
  ): clothing_segment_bounds_mutation_response

  # insert a single row into the table: "clothing_segment_bounds"
  insert_clothing_segment_bounds_one(
    # the row to be inserted
    object: clothing_segment_bounds_insert_input!

    # on conflict condition
    on_conflict: clothing_segment_bounds_on_conflict
  ): clothing_segment_bounds

  # insert data into the table: "clothing_segment_data"
  insert_clothing_segment_data(
    # the rows to be inserted
    objects: [clothing_segment_data_insert_input!]!

    # on conflict condition
    on_conflict: clothing_segment_data_on_conflict
  ): clothing_segment_data_mutation_response

  # insert a single row into the table: "clothing_segment_data"
  insert_clothing_segment_data_one(
    # the row to be inserted
    object: clothing_segment_data_insert_input!

    # on conflict condition
    on_conflict: clothing_segment_data_on_conflict
  ): clothing_segment_data

  # insert data into the table: "clothing_shell_and_body_segment_mask"
  insert_clothing_shell_and_body_segment_mask(
    # the rows to be inserted
    objects: [clothing_shell_and_body_segment_mask_insert_input!]!

    # on conflict condition
    on_conflict: clothing_shell_and_body_segment_mask_on_conflict
  ): clothing_shell_and_body_segment_mask_mutation_response

  # insert a single row into the table: "clothing_shell_and_body_segment_mask"
  insert_clothing_shell_and_body_segment_mask_one(
    # the row to be inserted
    object: clothing_shell_and_body_segment_mask_insert_input!

    # on conflict condition
    on_conflict: clothing_shell_and_body_segment_mask_on_conflict
  ): clothing_shell_and_body_segment_mask

  # insert data into the table: "clothing_shell_and_clothing_feature"
  insert_clothing_shell_and_clothing_feature(
    # the rows to be inserted
    objects: [clothing_shell_and_clothing_feature_insert_input!]!

    # on conflict condition
    on_conflict: clothing_shell_and_clothing_feature_on_conflict
  ): clothing_shell_and_clothing_feature_mutation_response

  # insert a single row into the table: "clothing_shell_and_clothing_feature"
  insert_clothing_shell_and_clothing_feature_one(
    # the row to be inserted
    object: clothing_shell_and_clothing_feature_insert_input!

    # on conflict condition
    on_conflict: clothing_shell_and_clothing_feature_on_conflict
  ): clothing_shell_and_clothing_feature

  # insert data into the table: "clothing_shell_counts"
  insert_clothing_shell_counts(
    # the rows to be inserted
    objects: [clothing_shell_counts_insert_input!]!

    # on conflict condition
    on_conflict: clothing_shell_counts_on_conflict
  ): clothing_shell_counts_mutation_response

  # insert a single row into the table: "clothing_shell_counts"
  insert_clothing_shell_counts_one(
    # the row to be inserted
    object: clothing_shell_counts_insert_input!

    # on conflict condition
    on_conflict: clothing_shell_counts_on_conflict
  ): clothing_shell_counts

  # insert data into the table: "clothing_shell_maindata"
  insert_clothing_shell_maindata(
    # the rows to be inserted
    objects: [clothing_shell_maindata_insert_input!]!

    # on conflict condition
    on_conflict: clothing_shell_maindata_on_conflict
  ): clothing_shell_maindata_mutation_response

  # insert a single row into the table: "clothing_shell_maindata"
  insert_clothing_shell_maindata_one(
    # the row to be inserted
    object: clothing_shell_maindata_insert_input!

    # on conflict condition
    on_conflict: clothing_shell_maindata_on_conflict
  ): clothing_shell_maindata

  # insert data into the table: "clothing_shell_maindata_revision_changes"
  insert_clothing_shell_maindata_revision_changes(
    # the rows to be inserted
    objects: [clothing_shell_maindata_revision_changes_insert_input!]!

    # on conflict condition
    on_conflict: clothing_shell_maindata_revision_changes_on_conflict
  ): clothing_shell_maindata_revision_changes_mutation_response

  # insert a single row into the table: "clothing_shell_maindata_revision_changes"
  insert_clothing_shell_maindata_revision_changes_one(
    # the row to be inserted
    object: clothing_shell_maindata_revision_changes_insert_input!

    # on conflict condition
    on_conflict: clothing_shell_maindata_revision_changes_on_conflict
  ): clothing_shell_maindata_revision_changes

  # insert data into the table: "clothing_shell_maindata_revisions"
  insert_clothing_shell_maindata_revisions(
    # the rows to be inserted
    objects: [clothing_shell_maindata_revisions_insert_input!]!

    # on conflict condition
    on_conflict: clothing_shell_maindata_revisions_on_conflict
  ): clothing_shell_maindata_revisions_mutation_response

  # insert a single row into the table: "clothing_shell_maindata_revisions"
  insert_clothing_shell_maindata_revisions_one(
    # the row to be inserted
    object: clothing_shell_maindata_revisions_insert_input!

    # on conflict condition
    on_conflict: clothing_shell_maindata_revisions_on_conflict
  ): clothing_shell_maindata_revisions

  # insert data into the table: "clothing_shells"
  insert_clothing_shells(
    # the rows to be inserted
    objects: [clothing_shells_insert_input!]!

    # on conflict condition
    on_conflict: clothing_shells_on_conflict
  ): clothing_shells_mutation_response

  # insert a single row into the table: "clothing_shells"
  insert_clothing_shells_one(
    # the row to be inserted
    object: clothing_shells_insert_input!

    # on conflict condition
    on_conflict: clothing_shells_on_conflict
  ): clothing_shells

  # insert data into the table: "collab_company_and_collection"
  insert_collab_company_and_collection(
    # the rows to be inserted
    objects: [collab_company_and_collection_insert_input!]!

    # on conflict condition
    on_conflict: collab_company_and_collection_on_conflict
  ): collab_company_and_collection_mutation_response

  # insert a single row into the table: "collab_company_and_collection"
  insert_collab_company_and_collection_one(
    # the row to be inserted
    object: collab_company_and_collection_insert_input!

    # on conflict condition
    on_conflict: collab_company_and_collection_on_conflict
  ): collab_company_and_collection

  # insert data into the table: "collections"
  insert_collections(
    # the rows to be inserted
    objects: [collections_insert_input!]!

    # on conflict condition
    on_conflict: collections_on_conflict
  ): collections_mutation_response

  # insert a single row into the table: "collections"
  insert_collections_one(
    # the row to be inserted
    object: collections_insert_input!

    # on conflict condition
    on_conflict: collections_on_conflict
  ): collections

  # insert data into the table: "colour_mix_parts"
  insert_colour_mix_parts(
    # the rows to be inserted
    objects: [colour_mix_parts_insert_input!]!

    # on conflict condition
    on_conflict: colour_mix_parts_on_conflict
  ): colour_mix_parts_mutation_response

  # insert a single row into the table: "colour_mix_parts"
  insert_colour_mix_parts_one(
    # the row to be inserted
    object: colour_mix_parts_insert_input!

    # on conflict condition
    on_conflict: colour_mix_parts_on_conflict
  ): colour_mix_parts

  # insert data into the table: "colours"
  insert_colours(
    # the rows to be inserted
    objects: [colours_insert_input!]!

    # on conflict condition
    on_conflict: colours_on_conflict
  ): colours_mutation_response

  # insert a single row into the table: "colours"
  insert_colours_one(
    # the row to be inserted
    object: colours_insert_input!

    # on conflict condition
    on_conflict: colours_on_conflict
  ): colours

  # insert data into the table: "companies"
  insert_companies(
    # the rows to be inserted
    objects: [companies_insert_input!]!

    # on conflict condition
    on_conflict: companies_on_conflict
  ): companies_mutation_response

  # insert a single row into the table: "companies"
  insert_companies_one(
    # the row to be inserted
    object: companies_insert_input!

    # on conflict condition
    on_conflict: companies_on_conflict
  ): companies

  # insert data into the table: "company_counts"
  insert_company_counts(
    # the rows to be inserted
    objects: [company_counts_insert_input!]!

    # on conflict condition
    on_conflict: company_counts_on_conflict
  ): company_counts_mutation_response

  # insert a single row into the table: "company_counts"
  insert_company_counts_one(
    # the row to be inserted
    object: company_counts_insert_input!

    # on conflict condition
    on_conflict: company_counts_on_conflict
  ): company_counts

  # insert data into the table: "company_translation_revision_changes"
  insert_company_translation_revision_changes(
    # the rows to be inserted
    objects: [company_translation_revision_changes_insert_input!]!

    # on conflict condition
    on_conflict: company_translation_revision_changes_on_conflict
  ): company_translation_revision_changes_mutation_response

  # insert a single row into the table: "company_translation_revision_changes"
  insert_company_translation_revision_changes_one(
    # the row to be inserted
    object: company_translation_revision_changes_insert_input!

    # on conflict condition
    on_conflict: company_translation_revision_changes_on_conflict
  ): company_translation_revision_changes

  # insert data into the table: "company_translation_revisions"
  insert_company_translation_revisions(
    # the rows to be inserted
    objects: [company_translation_revisions_insert_input!]!

    # on conflict condition
    on_conflict: company_translation_revisions_on_conflict
  ): company_translation_revisions_mutation_response

  # insert a single row into the table: "company_translation_revisions"
  insert_company_translation_revisions_one(
    # the row to be inserted
    object: company_translation_revisions_insert_input!

    # on conflict condition
    on_conflict: company_translation_revisions_on_conflict
  ): company_translation_revisions

  # insert data into the table: "company_translations"
  insert_company_translations(
    # the rows to be inserted
    objects: [company_translations_insert_input!]!

    # on conflict condition
    on_conflict: company_translations_on_conflict
  ): company_translations_mutation_response

  # insert a single row into the table: "company_translations"
  insert_company_translations_one(
    # the row to be inserted
    object: company_translations_insert_input!

    # on conflict condition
    on_conflict: company_translations_on_conflict
  ): company_translations

  # insert data into the table: "countries"
  insert_countries(
    # the rows to be inserted
    objects: [countries_insert_input!]!

    # on conflict condition
    on_conflict: countries_on_conflict
  ): countries_mutation_response

  # insert a single row into the table: "countries"
  insert_countries_one(
    # the row to be inserted
    object: countries_insert_input!

    # on conflict condition
    on_conflict: countries_on_conflict
  ): countries

  # insert data into the table: "data_actions"
  insert_data_actions(
    # the rows to be inserted
    objects: [data_actions_insert_input!]!

    # on conflict condition
    on_conflict: data_actions_on_conflict
  ): data_actions_mutation_response

  # insert a single row into the table: "data_actions"
  insert_data_actions_one(
    # the row to be inserted
    object: data_actions_insert_input!

    # on conflict condition
    on_conflict: data_actions_on_conflict
  ): data_actions

  # insert data into the table: "data_change_types"
  insert_data_change_types(
    # the rows to be inserted
    objects: [data_change_types_insert_input!]!

    # on conflict condition
    on_conflict: data_change_types_on_conflict
  ): data_change_types_mutation_response

  # insert a single row into the table: "data_change_types"
  insert_data_change_types_one(
    # the row to be inserted
    object: data_change_types_insert_input!

    # on conflict condition
    on_conflict: data_change_types_on_conflict
  ): data_change_types

  # insert data into the table: "data_promotions"
  insert_data_promotions(
    # the rows to be inserted
    objects: [data_promotions_insert_input!]!

    # on conflict condition
    on_conflict: data_promotions_on_conflict
  ): data_promotions_mutation_response

  # insert a single row into the table: "data_promotions"
  insert_data_promotions_one(
    # the row to be inserted
    object: data_promotions_insert_input!

    # on conflict condition
    on_conflict: data_promotions_on_conflict
  ): data_promotions

  # insert data into the table: "data_release_types"
  insert_data_release_types(
    # the rows to be inserted
    objects: [data_release_types_insert_input!]!

    # on conflict condition
    on_conflict: data_release_types_on_conflict
  ): data_release_types_mutation_response

  # insert a single row into the table: "data_release_types"
  insert_data_release_types_one(
    # the row to be inserted
    object: data_release_types_insert_input!

    # on conflict condition
    on_conflict: data_release_types_on_conflict
  ): data_release_types

  # insert data into the table: "data_states"
  insert_data_states(
    # the rows to be inserted
    objects: [data_states_insert_input!]!

    # on conflict condition
    on_conflict: data_states_on_conflict
  ): data_states_mutation_response

  # insert a single row into the table: "data_states"
  insert_data_states_one(
    # the row to be inserted
    object: data_states_insert_input!

    # on conflict condition
    on_conflict: data_states_on_conflict
  ): data_states

  # insert data into the table: "fabric_layer_and_colour_mix_part"
  insert_fabric_layer_and_colour_mix_part(
    # the rows to be inserted
    objects: [fabric_layer_and_colour_mix_part_insert_input!]!

    # on conflict condition
    on_conflict: fabric_layer_and_colour_mix_part_on_conflict
  ): fabric_layer_and_colour_mix_part_mutation_response

  # insert a single row into the table: "fabric_layer_and_colour_mix_part"
  insert_fabric_layer_and_colour_mix_part_one(
    # the row to be inserted
    object: fabric_layer_and_colour_mix_part_insert_input!

    # on conflict condition
    on_conflict: fabric_layer_and_colour_mix_part_on_conflict
  ): fabric_layer_and_colour_mix_part

  # insert data into the table: "fabric_layer_types"
  insert_fabric_layer_types(
    # the rows to be inserted
    objects: [fabric_layer_types_insert_input!]!

    # on conflict condition
    on_conflict: fabric_layer_types_on_conflict
  ): fabric_layer_types_mutation_response

  # insert a single row into the table: "fabric_layer_types"
  insert_fabric_layer_types_one(
    # the row to be inserted
    object: fabric_layer_types_insert_input!

    # on conflict condition
    on_conflict: fabric_layer_types_on_conflict
  ): fabric_layer_types

  # insert data into the table: "fabric_layers"
  insert_fabric_layers(
    # the rows to be inserted
    objects: [fabric_layers_insert_input!]!

    # on conflict condition
    on_conflict: fabric_layers_on_conflict
  ): fabric_layers_mutation_response

  # insert a single row into the table: "fabric_layers"
  insert_fabric_layers_one(
    # the row to be inserted
    object: fabric_layers_insert_input!

    # on conflict condition
    on_conflict: fabric_layers_on_conflict
  ): fabric_layers

  # insert data into the table: "fabric_types"
  insert_fabric_types(
    # the rows to be inserted
    objects: [fabric_types_insert_input!]!

    # on conflict condition
    on_conflict: fabric_types_on_conflict
  ): fabric_types_mutation_response

  # insert a single row into the table: "fabric_types"
  insert_fabric_types_one(
    # the row to be inserted
    object: fabric_types_insert_input!

    # on conflict condition
    on_conflict: fabric_types_on_conflict
  ): fabric_types

  # insert data into the table: "genders"
  insert_genders(
    # the rows to be inserted
    objects: [genders_insert_input!]!

    # on conflict condition
    on_conflict: genders_on_conflict
  ): genders_mutation_response

  # insert a single row into the table: "genders"
  insert_genders_one(
    # the row to be inserted
    object: genders_insert_input!

    # on conflict condition
    on_conflict: genders_on_conflict
  ): genders

  # insert data into the table: "item_and_clothing_shell"
  insert_item_and_clothing_shell(
    # the rows to be inserted
    objects: [item_and_clothing_shell_insert_input!]!

    # on conflict condition
    on_conflict: item_and_clothing_shell_on_conflict
  ): item_and_clothing_shell_mutation_response

  # insert a single row into the table: "item_and_clothing_shell"
  insert_item_and_clothing_shell_one(
    # the row to be inserted
    object: item_and_clothing_shell_insert_input!

    # on conflict condition
    on_conflict: item_and_clothing_shell_on_conflict
  ): item_and_clothing_shell

  # insert data into the table: "item_families"
  insert_item_families(
    # the rows to be inserted
    objects: [item_families_insert_input!]!

    # on conflict condition
    on_conflict: item_families_on_conflict
  ): item_families_mutation_response

  # insert a single row into the table: "item_families"
  insert_item_families_one(
    # the row to be inserted
    object: item_families_insert_input!

    # on conflict condition
    on_conflict: item_families_on_conflict
  ): item_families

  # insert data into the table: "item_maindata"
  insert_item_maindata(
    # the rows to be inserted
    objects: [item_maindata_insert_input!]!

    # on conflict condition
    on_conflict: item_maindata_on_conflict
  ): item_maindata_mutation_response

  # insert a single row into the table: "item_maindata"
  insert_item_maindata_one(
    # the row to be inserted
    object: item_maindata_insert_input!

    # on conflict condition
    on_conflict: item_maindata_on_conflict
  ): item_maindata

  # insert data into the table: "item_maindata_revision_changes"
  insert_item_maindata_revision_changes(
    # the rows to be inserted
    objects: [item_maindata_revision_changes_insert_input!]!

    # on conflict condition
    on_conflict: item_maindata_revision_changes_on_conflict
  ): item_maindata_revision_changes_mutation_response

  # insert a single row into the table: "item_maindata_revision_changes"
  insert_item_maindata_revision_changes_one(
    # the row to be inserted
    object: item_maindata_revision_changes_insert_input!

    # on conflict condition
    on_conflict: item_maindata_revision_changes_on_conflict
  ): item_maindata_revision_changes

  # insert data into the table: "item_maindata_revisions"
  insert_item_maindata_revisions(
    # the rows to be inserted
    objects: [item_maindata_revisions_insert_input!]!

    # on conflict condition
    on_conflict: item_maindata_revisions_on_conflict
  ): item_maindata_revisions_mutation_response

  # insert a single row into the table: "item_maindata_revisions"
  insert_item_maindata_revisions_one(
    # the row to be inserted
    object: item_maindata_revisions_insert_input!

    # on conflict condition
    on_conflict: item_maindata_revisions_on_conflict
  ): item_maindata_revisions

  # insert data into the table: "item_translation_revision_changes"
  insert_item_translation_revision_changes(
    # the rows to be inserted
    objects: [item_translation_revision_changes_insert_input!]!

    # on conflict condition
    on_conflict: item_translation_revision_changes_on_conflict
  ): item_translation_revision_changes_mutation_response

  # insert a single row into the table: "item_translation_revision_changes"
  insert_item_translation_revision_changes_one(
    # the row to be inserted
    object: item_translation_revision_changes_insert_input!

    # on conflict condition
    on_conflict: item_translation_revision_changes_on_conflict
  ): item_translation_revision_changes

  # insert data into the table: "item_translation_revisions"
  insert_item_translation_revisions(
    # the rows to be inserted
    objects: [item_translation_revisions_insert_input!]!

    # on conflict condition
    on_conflict: item_translation_revisions_on_conflict
  ): item_translation_revisions_mutation_response

  # insert a single row into the table: "item_translation_revisions"
  insert_item_translation_revisions_one(
    # the row to be inserted
    object: item_translation_revisions_insert_input!

    # on conflict condition
    on_conflict: item_translation_revisions_on_conflict
  ): item_translation_revisions

  # insert data into the table: "item_translations"
  insert_item_translations(
    # the rows to be inserted
    objects: [item_translations_insert_input!]!

    # on conflict condition
    on_conflict: item_translations_on_conflict
  ): item_translations_mutation_response

  # insert a single row into the table: "item_translations"
  insert_item_translations_one(
    # the row to be inserted
    object: item_translations_insert_input!

    # on conflict condition
    on_conflict: item_translations_on_conflict
  ): item_translations

  # insert data into the table: "item_types"
  insert_item_types(
    # the rows to be inserted
    objects: [item_types_insert_input!]!

    # on conflict condition
    on_conflict: item_types_on_conflict
  ): item_types_mutation_response

  # insert a single row into the table: "item_types"
  insert_item_types_one(
    # the row to be inserted
    object: item_types_insert_input!

    # on conflict condition
    on_conflict: item_types_on_conflict
  ): item_types

  # insert data into the table: "items"
  insert_items(
    # the rows to be inserted
    objects: [items_insert_input!]!

    # on conflict condition
    on_conflict: items_on_conflict
  ): items_mutation_response

  # insert a single row into the table: "items"
  insert_items_one(
    # the row to be inserted
    object: items_insert_input!

    # on conflict condition
    on_conflict: items_on_conflict
  ): items

  # insert data into the table: "language_families"
  insert_language_families(
    # the rows to be inserted
    objects: [language_families_insert_input!]!

    # on conflict condition
    on_conflict: language_families_on_conflict
  ): language_families_mutation_response

  # insert a single row into the table: "language_families"
  insert_language_families_one(
    # the row to be inserted
    object: language_families_insert_input!

    # on conflict condition
    on_conflict: language_families_on_conflict
  ): language_families

  # insert data into the table: "locales"
  insert_locales(
    # the rows to be inserted
    objects: [locales_insert_input!]!

    # on conflict condition
    on_conflict: locales_on_conflict
  ): locales_mutation_response

  # insert a single row into the table: "locales"
  insert_locales_one(
    # the row to be inserted
    object: locales_insert_input!

    # on conflict condition
    on_conflict: locales_on_conflict
  ): locales

  # insert data into the table: "materials"
  insert_materials(
    # the rows to be inserted
    objects: [materials_insert_input!]!

    # on conflict condition
    on_conflict: materials_on_conflict
  ): materials_mutation_response

  # insert data into the table: "materials_mix_parts"
  insert_materials_mix_parts(
    # the rows to be inserted
    objects: [materials_mix_parts_insert_input!]!

    # on conflict condition
    on_conflict: materials_mix_parts_on_conflict
  ): materials_mix_parts_mutation_response

  # insert a single row into the table: "materials_mix_parts"
  insert_materials_mix_parts_one(
    # the row to be inserted
    object: materials_mix_parts_insert_input!

    # on conflict condition
    on_conflict: materials_mix_parts_on_conflict
  ): materials_mix_parts

  # insert a single row into the table: "materials"
  insert_materials_one(
    # the row to be inserted
    object: materials_insert_input!

    # on conflict condition
    on_conflict: materials_on_conflict
  ): materials

  # insert data into the table: "staff_users"
  insert_staff_users(
    # the rows to be inserted
    objects: [staff_users_insert_input!]!

    # on conflict condition
    on_conflict: staff_users_on_conflict
  ): staff_users_mutation_response

  # insert a single row into the table: "staff_users"
  insert_staff_users_one(
    # the row to be inserted
    object: staff_users_insert_input!

    # on conflict condition
    on_conflict: staff_users_on_conflict
  ): staff_users

  # insert data into the table: "version_cms_items_db"
  insert_version_cms_items_db(
    # the rows to be inserted
    objects: [version_cms_items_db_insert_input!]!

    # on conflict condition
    on_conflict: version_cms_items_db_on_conflict
  ): version_cms_items_db_mutation_response

  # insert a single row into the table: "version_cms_items_db"
  insert_version_cms_items_db_one(
    # the row to be inserted
    object: version_cms_items_db_insert_input!

    # on conflict condition
    on_conflict: version_cms_items_db_on_conflict
  ): version_cms_items_db

  # update data of the table: "base_colours"
  update_base_colours(
    # sets the columns of the filtered rows to the given values
    _set: base_colours_set_input

    # filter the rows which have to be updated
    where: base_colours_bool_exp!
  ): base_colours_mutation_response

  # update single row of the table: "base_colours"
  update_base_colours_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: base_colours_set_input
    pk_columns: base_colours_pk_columns_input!
  ): base_colours

  # update data of the table: "body_groups"
  update_body_groups(
    # sets the columns of the filtered rows to the given values
    _set: body_groups_set_input

    # filter the rows which have to be updated
    where: body_groups_bool_exp!
  ): body_groups_mutation_response

  # update single row of the table: "body_groups"
  update_body_groups_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: body_groups_set_input
    pk_columns: body_groups_pk_columns_input!
  ): body_groups

  # update data of the table: "body_segment_mask_shapes"
  update_body_segment_mask_shapes(
    # sets the columns of the filtered rows to the given values
    _set: body_segment_mask_shapes_set_input

    # filter the rows which have to be updated
    where: body_segment_mask_shapes_bool_exp!
  ): body_segment_mask_shapes_mutation_response

  # update single row of the table: "body_segment_mask_shapes"
  update_body_segment_mask_shapes_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: body_segment_mask_shapes_set_input
    pk_columns: body_segment_mask_shapes_pk_columns_input!
  ): body_segment_mask_shapes

  # update data of the table: "body_segment_masks"
  update_body_segment_masks(
    # increments the integer columns with given value of the filtered values
    _inc: body_segment_masks_inc_input

    # sets the columns of the filtered rows to the given values
    _set: body_segment_masks_set_input

    # filter the rows which have to be updated
    where: body_segment_masks_bool_exp!
  ): body_segment_masks_mutation_response

  # update single row of the table: "body_segment_masks"
  update_body_segment_masks_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: body_segment_masks_inc_input

    # sets the columns of the filtered rows to the given values
    _set: body_segment_masks_set_input
    pk_columns: body_segment_masks_pk_columns_input!
  ): body_segment_masks

  # update data of the table: "body_segments"
  update_body_segments(
    # increments the integer columns with given value of the filtered values
    _inc: body_segments_inc_input

    # sets the columns of the filtered rows to the given values
    _set: body_segments_set_input

    # filter the rows which have to be updated
    where: body_segments_bool_exp!
  ): body_segments_mutation_response

  # update single row of the table: "body_segments"
  update_body_segments_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: body_segments_inc_input

    # sets the columns of the filtered rows to the given values
    _set: body_segments_set_input
    pk_columns: body_segments_pk_columns_input!
  ): body_segments

  # update data of the table: "clothing_features"
  update_clothing_features(
    # sets the columns of the filtered rows to the given values
    _set: clothing_features_set_input

    # filter the rows which have to be updated
    where: clothing_features_bool_exp!
  ): clothing_features_mutation_response

  # update single row of the table: "clothing_features"
  update_clothing_features_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: clothing_features_set_input
    pk_columns: clothing_features_pk_columns_input!
  ): clothing_features

  # update data of the table: "clothing_masks"
  update_clothing_masks(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_masks_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_masks_set_input

    # filter the rows which have to be updated
    where: clothing_masks_bool_exp!
  ): clothing_masks_mutation_response

  # update single row of the table: "clothing_masks"
  update_clothing_masks_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_masks_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_masks_set_input
    pk_columns: clothing_masks_pk_columns_input!
  ): clothing_masks

  # update data of the table: "clothing_segment_bounds"
  update_clothing_segment_bounds(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_segment_bounds_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_segment_bounds_set_input

    # filter the rows which have to be updated
    where: clothing_segment_bounds_bool_exp!
  ): clothing_segment_bounds_mutation_response

  # update single row of the table: "clothing_segment_bounds"
  update_clothing_segment_bounds_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_segment_bounds_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_segment_bounds_set_input
    pk_columns: clothing_segment_bounds_pk_columns_input!
  ): clothing_segment_bounds

  # update data of the table: "clothing_segment_data"
  update_clothing_segment_data(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_segment_data_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_segment_data_set_input

    # filter the rows which have to be updated
    where: clothing_segment_data_bool_exp!
  ): clothing_segment_data_mutation_response

  # update single row of the table: "clothing_segment_data"
  update_clothing_segment_data_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_segment_data_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_segment_data_set_input
    pk_columns: clothing_segment_data_pk_columns_input!
  ): clothing_segment_data

  # update data of the table: "clothing_shell_and_body_segment_mask"
  update_clothing_shell_and_body_segment_mask(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_and_body_segment_mask_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_and_body_segment_mask_set_input

    # filter the rows which have to be updated
    where: clothing_shell_and_body_segment_mask_bool_exp!
  ): clothing_shell_and_body_segment_mask_mutation_response

  # update single row of the table: "clothing_shell_and_body_segment_mask"
  update_clothing_shell_and_body_segment_mask_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_and_body_segment_mask_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_and_body_segment_mask_set_input
    pk_columns: clothing_shell_and_body_segment_mask_pk_columns_input!
  ): clothing_shell_and_body_segment_mask

  # update data of the table: "clothing_shell_and_clothing_feature"
  update_clothing_shell_and_clothing_feature(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_and_clothing_feature_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_and_clothing_feature_set_input

    # filter the rows which have to be updated
    where: clothing_shell_and_clothing_feature_bool_exp!
  ): clothing_shell_and_clothing_feature_mutation_response

  # update single row of the table: "clothing_shell_and_clothing_feature"
  update_clothing_shell_and_clothing_feature_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_and_clothing_feature_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_and_clothing_feature_set_input
    pk_columns: clothing_shell_and_clothing_feature_pk_columns_input!
  ): clothing_shell_and_clothing_feature

  # update data of the table: "clothing_shell_counts"
  update_clothing_shell_counts(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_counts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_counts_set_input

    # filter the rows which have to be updated
    where: clothing_shell_counts_bool_exp!
  ): clothing_shell_counts_mutation_response

  # update single row of the table: "clothing_shell_counts"
  update_clothing_shell_counts_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_counts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_counts_set_input
    pk_columns: clothing_shell_counts_pk_columns_input!
  ): clothing_shell_counts

  # update data of the table: "clothing_shell_maindata"
  update_clothing_shell_maindata(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_maindata_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_maindata_set_input

    # filter the rows which have to be updated
    where: clothing_shell_maindata_bool_exp!
  ): clothing_shell_maindata_mutation_response

  # update single row of the table: "clothing_shell_maindata"
  update_clothing_shell_maindata_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_maindata_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_maindata_set_input
    pk_columns: clothing_shell_maindata_pk_columns_input!
  ): clothing_shell_maindata

  # update data of the table: "clothing_shell_maindata_revision_changes"
  update_clothing_shell_maindata_revision_changes(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_maindata_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_maindata_revision_changes_set_input

    # filter the rows which have to be updated
    where: clothing_shell_maindata_revision_changes_bool_exp!
  ): clothing_shell_maindata_revision_changes_mutation_response

  # update single row of the table: "clothing_shell_maindata_revision_changes"
  update_clothing_shell_maindata_revision_changes_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_maindata_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_maindata_revision_changes_set_input
    pk_columns: clothing_shell_maindata_revision_changes_pk_columns_input!
  ): clothing_shell_maindata_revision_changes

  # update data of the table: "clothing_shell_maindata_revisions"
  update_clothing_shell_maindata_revisions(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_maindata_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_maindata_revisions_set_input

    # filter the rows which have to be updated
    where: clothing_shell_maindata_revisions_bool_exp!
  ): clothing_shell_maindata_revisions_mutation_response

  # update single row of the table: "clothing_shell_maindata_revisions"
  update_clothing_shell_maindata_revisions_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shell_maindata_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shell_maindata_revisions_set_input
    pk_columns: clothing_shell_maindata_revisions_pk_columns_input!
  ): clothing_shell_maindata_revisions

  # update data of the table: "clothing_shells"
  update_clothing_shells(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shells_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shells_set_input

    # filter the rows which have to be updated
    where: clothing_shells_bool_exp!
  ): clothing_shells_mutation_response

  # update single row of the table: "clothing_shells"
  update_clothing_shells_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: clothing_shells_inc_input

    # sets the columns of the filtered rows to the given values
    _set: clothing_shells_set_input
    pk_columns: clothing_shells_pk_columns_input!
  ): clothing_shells

  # update data of the table: "collab_company_and_collection"
  update_collab_company_and_collection(
    # increments the integer columns with given value of the filtered values
    _inc: collab_company_and_collection_inc_input

    # sets the columns of the filtered rows to the given values
    _set: collab_company_and_collection_set_input

    # filter the rows which have to be updated
    where: collab_company_and_collection_bool_exp!
  ): collab_company_and_collection_mutation_response

  # update single row of the table: "collab_company_and_collection"
  update_collab_company_and_collection_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: collab_company_and_collection_inc_input

    # sets the columns of the filtered rows to the given values
    _set: collab_company_and_collection_set_input
    pk_columns: collab_company_and_collection_pk_columns_input!
  ): collab_company_and_collection

  # update data of the table: "collections"
  update_collections(
    # increments the integer columns with given value of the filtered values
    _inc: collections_inc_input

    # sets the columns of the filtered rows to the given values
    _set: collections_set_input

    # filter the rows which have to be updated
    where: collections_bool_exp!
  ): collections_mutation_response

  # update single row of the table: "collections"
  update_collections_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: collections_inc_input

    # sets the columns of the filtered rows to the given values
    _set: collections_set_input
    pk_columns: collections_pk_columns_input!
  ): collections

  # update data of the table: "colour_mix_parts"
  update_colour_mix_parts(
    # increments the integer columns with given value of the filtered values
    _inc: colour_mix_parts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: colour_mix_parts_set_input

    # filter the rows which have to be updated
    where: colour_mix_parts_bool_exp!
  ): colour_mix_parts_mutation_response

  # update single row of the table: "colour_mix_parts"
  update_colour_mix_parts_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: colour_mix_parts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: colour_mix_parts_set_input
    pk_columns: colour_mix_parts_pk_columns_input!
  ): colour_mix_parts

  # update data of the table: "colours"
  update_colours(
    # increments the integer columns with given value of the filtered values
    _inc: colours_inc_input

    # sets the columns of the filtered rows to the given values
    _set: colours_set_input

    # filter the rows which have to be updated
    where: colours_bool_exp!
  ): colours_mutation_response

  # update single row of the table: "colours"
  update_colours_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: colours_inc_input

    # sets the columns of the filtered rows to the given values
    _set: colours_set_input
    pk_columns: colours_pk_columns_input!
  ): colours

  # update data of the table: "companies"
  update_companies(
    # increments the integer columns with given value of the filtered values
    _inc: companies_inc_input

    # sets the columns of the filtered rows to the given values
    _set: companies_set_input

    # filter the rows which have to be updated
    where: companies_bool_exp!
  ): companies_mutation_response

  # update single row of the table: "companies"
  update_companies_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: companies_inc_input

    # sets the columns of the filtered rows to the given values
    _set: companies_set_input
    pk_columns: companies_pk_columns_input!
  ): companies

  # update data of the table: "company_counts"
  update_company_counts(
    # increments the integer columns with given value of the filtered values
    _inc: company_counts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: company_counts_set_input

    # filter the rows which have to be updated
    where: company_counts_bool_exp!
  ): company_counts_mutation_response

  # update single row of the table: "company_counts"
  update_company_counts_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: company_counts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: company_counts_set_input
    pk_columns: company_counts_pk_columns_input!
  ): company_counts

  # update data of the table: "company_translation_revision_changes"
  update_company_translation_revision_changes(
    # increments the integer columns with given value of the filtered values
    _inc: company_translation_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: company_translation_revision_changes_set_input

    # filter the rows which have to be updated
    where: company_translation_revision_changes_bool_exp!
  ): company_translation_revision_changes_mutation_response

  # update single row of the table: "company_translation_revision_changes"
  update_company_translation_revision_changes_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: company_translation_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: company_translation_revision_changes_set_input
    pk_columns: company_translation_revision_changes_pk_columns_input!
  ): company_translation_revision_changes

  # update data of the table: "company_translation_revisions"
  update_company_translation_revisions(
    # increments the integer columns with given value of the filtered values
    _inc: company_translation_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: company_translation_revisions_set_input

    # filter the rows which have to be updated
    where: company_translation_revisions_bool_exp!
  ): company_translation_revisions_mutation_response

  # update single row of the table: "company_translation_revisions"
  update_company_translation_revisions_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: company_translation_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: company_translation_revisions_set_input
    pk_columns: company_translation_revisions_pk_columns_input!
  ): company_translation_revisions

  # update data of the table: "company_translations"
  update_company_translations(
    # sets the columns of the filtered rows to the given values
    _set: company_translations_set_input

    # filter the rows which have to be updated
    where: company_translations_bool_exp!
  ): company_translations_mutation_response

  # update single row of the table: "company_translations"
  update_company_translations_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: company_translations_set_input
    pk_columns: company_translations_pk_columns_input!
  ): company_translations

  # update data of the table: "countries"
  update_countries(
    # sets the columns of the filtered rows to the given values
    _set: countries_set_input

    # filter the rows which have to be updated
    where: countries_bool_exp!
  ): countries_mutation_response

  # update single row of the table: "countries"
  update_countries_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: countries_set_input
    pk_columns: countries_pk_columns_input!
  ): countries

  # update data of the table: "data_actions"
  update_data_actions(
    # sets the columns of the filtered rows to the given values
    _set: data_actions_set_input

    # filter the rows which have to be updated
    where: data_actions_bool_exp!
  ): data_actions_mutation_response

  # update single row of the table: "data_actions"
  update_data_actions_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: data_actions_set_input
    pk_columns: data_actions_pk_columns_input!
  ): data_actions

  # update data of the table: "data_change_types"
  update_data_change_types(
    # sets the columns of the filtered rows to the given values
    _set: data_change_types_set_input

    # filter the rows which have to be updated
    where: data_change_types_bool_exp!
  ): data_change_types_mutation_response

  # update single row of the table: "data_change_types"
  update_data_change_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: data_change_types_set_input
    pk_columns: data_change_types_pk_columns_input!
  ): data_change_types

  # update data of the table: "data_promotions"
  update_data_promotions(
    # increments the integer columns with given value of the filtered values
    _inc: data_promotions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: data_promotions_set_input

    # filter the rows which have to be updated
    where: data_promotions_bool_exp!
  ): data_promotions_mutation_response

  # update single row of the table: "data_promotions"
  update_data_promotions_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: data_promotions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: data_promotions_set_input
    pk_columns: data_promotions_pk_columns_input!
  ): data_promotions

  # update data of the table: "data_release_types"
  update_data_release_types(
    # sets the columns of the filtered rows to the given values
    _set: data_release_types_set_input

    # filter the rows which have to be updated
    where: data_release_types_bool_exp!
  ): data_release_types_mutation_response

  # update single row of the table: "data_release_types"
  update_data_release_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: data_release_types_set_input
    pk_columns: data_release_types_pk_columns_input!
  ): data_release_types

  # update data of the table: "data_states"
  update_data_states(
    # sets the columns of the filtered rows to the given values
    _set: data_states_set_input

    # filter the rows which have to be updated
    where: data_states_bool_exp!
  ): data_states_mutation_response

  # update single row of the table: "data_states"
  update_data_states_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: data_states_set_input
    pk_columns: data_states_pk_columns_input!
  ): data_states

  # update data of the table: "fabric_layer_and_colour_mix_part"
  update_fabric_layer_and_colour_mix_part(
    # increments the integer columns with given value of the filtered values
    _inc: fabric_layer_and_colour_mix_part_inc_input

    # sets the columns of the filtered rows to the given values
    _set: fabric_layer_and_colour_mix_part_set_input

    # filter the rows which have to be updated
    where: fabric_layer_and_colour_mix_part_bool_exp!
  ): fabric_layer_and_colour_mix_part_mutation_response

  # update single row of the table: "fabric_layer_and_colour_mix_part"
  update_fabric_layer_and_colour_mix_part_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: fabric_layer_and_colour_mix_part_inc_input

    # sets the columns of the filtered rows to the given values
    _set: fabric_layer_and_colour_mix_part_set_input
    pk_columns: fabric_layer_and_colour_mix_part_pk_columns_input!
  ): fabric_layer_and_colour_mix_part

  # update data of the table: "fabric_layer_types"
  update_fabric_layer_types(
    # sets the columns of the filtered rows to the given values
    _set: fabric_layer_types_set_input

    # filter the rows which have to be updated
    where: fabric_layer_types_bool_exp!
  ): fabric_layer_types_mutation_response

  # update single row of the table: "fabric_layer_types"
  update_fabric_layer_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: fabric_layer_types_set_input
    pk_columns: fabric_layer_types_pk_columns_input!
  ): fabric_layer_types

  # update data of the table: "fabric_layers"
  update_fabric_layers(
    # increments the integer columns with given value of the filtered values
    _inc: fabric_layers_inc_input

    # sets the columns of the filtered rows to the given values
    _set: fabric_layers_set_input

    # filter the rows which have to be updated
    where: fabric_layers_bool_exp!
  ): fabric_layers_mutation_response

  # update single row of the table: "fabric_layers"
  update_fabric_layers_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: fabric_layers_inc_input

    # sets the columns of the filtered rows to the given values
    _set: fabric_layers_set_input
    pk_columns: fabric_layers_pk_columns_input!
  ): fabric_layers

  # update data of the table: "fabric_types"
  update_fabric_types(
    # increments the integer columns with given value of the filtered values
    _inc: fabric_types_inc_input

    # sets the columns of the filtered rows to the given values
    _set: fabric_types_set_input

    # filter the rows which have to be updated
    where: fabric_types_bool_exp!
  ): fabric_types_mutation_response

  # update single row of the table: "fabric_types"
  update_fabric_types_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: fabric_types_inc_input

    # sets the columns of the filtered rows to the given values
    _set: fabric_types_set_input
    pk_columns: fabric_types_pk_columns_input!
  ): fabric_types

  # update data of the table: "genders"
  update_genders(
    # sets the columns of the filtered rows to the given values
    _set: genders_set_input

    # filter the rows which have to be updated
    where: genders_bool_exp!
  ): genders_mutation_response

  # update single row of the table: "genders"
  update_genders_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: genders_set_input
    pk_columns: genders_pk_columns_input!
  ): genders

  # update data of the table: "item_and_clothing_shell"
  update_item_and_clothing_shell(
    # increments the integer columns with given value of the filtered values
    _inc: item_and_clothing_shell_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_and_clothing_shell_set_input

    # filter the rows which have to be updated
    where: item_and_clothing_shell_bool_exp!
  ): item_and_clothing_shell_mutation_response

  # update single row of the table: "item_and_clothing_shell"
  update_item_and_clothing_shell_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_and_clothing_shell_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_and_clothing_shell_set_input
    pk_columns: item_and_clothing_shell_pk_columns_input!
  ): item_and_clothing_shell

  # update data of the table: "item_families"
  update_item_families(
    # increments the integer columns with given value of the filtered values
    _inc: item_families_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_families_set_input

    # filter the rows which have to be updated
    where: item_families_bool_exp!
  ): item_families_mutation_response

  # update single row of the table: "item_families"
  update_item_families_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_families_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_families_set_input
    pk_columns: item_families_pk_columns_input!
  ): item_families

  # update data of the table: "item_maindata"
  update_item_maindata(
    # increments the integer columns with given value of the filtered values
    _inc: item_maindata_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_maindata_set_input

    # filter the rows which have to be updated
    where: item_maindata_bool_exp!
  ): item_maindata_mutation_response

  # update single row of the table: "item_maindata"
  update_item_maindata_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_maindata_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_maindata_set_input
    pk_columns: item_maindata_pk_columns_input!
  ): item_maindata

  # update data of the table: "item_maindata_revision_changes"
  update_item_maindata_revision_changes(
    # increments the integer columns with given value of the filtered values
    _inc: item_maindata_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_maindata_revision_changes_set_input

    # filter the rows which have to be updated
    where: item_maindata_revision_changes_bool_exp!
  ): item_maindata_revision_changes_mutation_response

  # update single row of the table: "item_maindata_revision_changes"
  update_item_maindata_revision_changes_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_maindata_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_maindata_revision_changes_set_input
    pk_columns: item_maindata_revision_changes_pk_columns_input!
  ): item_maindata_revision_changes

  # update data of the table: "item_maindata_revisions"
  update_item_maindata_revisions(
    # increments the integer columns with given value of the filtered values
    _inc: item_maindata_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_maindata_revisions_set_input

    # filter the rows which have to be updated
    where: item_maindata_revisions_bool_exp!
  ): item_maindata_revisions_mutation_response

  # update single row of the table: "item_maindata_revisions"
  update_item_maindata_revisions_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_maindata_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_maindata_revisions_set_input
    pk_columns: item_maindata_revisions_pk_columns_input!
  ): item_maindata_revisions

  # update data of the table: "item_translation_revision_changes"
  update_item_translation_revision_changes(
    # increments the integer columns with given value of the filtered values
    _inc: item_translation_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_translation_revision_changes_set_input

    # filter the rows which have to be updated
    where: item_translation_revision_changes_bool_exp!
  ): item_translation_revision_changes_mutation_response

  # update single row of the table: "item_translation_revision_changes"
  update_item_translation_revision_changes_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_translation_revision_changes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_translation_revision_changes_set_input
    pk_columns: item_translation_revision_changes_pk_columns_input!
  ): item_translation_revision_changes

  # update data of the table: "item_translation_revisions"
  update_item_translation_revisions(
    # increments the integer columns with given value of the filtered values
    _inc: item_translation_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_translation_revisions_set_input

    # filter the rows which have to be updated
    where: item_translation_revisions_bool_exp!
  ): item_translation_revisions_mutation_response

  # update single row of the table: "item_translation_revisions"
  update_item_translation_revisions_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_translation_revisions_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_translation_revisions_set_input
    pk_columns: item_translation_revisions_pk_columns_input!
  ): item_translation_revisions

  # update data of the table: "item_translations"
  update_item_translations(
    # sets the columns of the filtered rows to the given values
    _set: item_translations_set_input

    # filter the rows which have to be updated
    where: item_translations_bool_exp!
  ): item_translations_mutation_response

  # update single row of the table: "item_translations"
  update_item_translations_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: item_translations_set_input
    pk_columns: item_translations_pk_columns_input!
  ): item_translations

  # update data of the table: "item_types"
  update_item_types(
    # sets the columns of the filtered rows to the given values
    _set: item_types_set_input

    # filter the rows which have to be updated
    where: item_types_bool_exp!
  ): item_types_mutation_response

  # update single row of the table: "item_types"
  update_item_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: item_types_set_input
    pk_columns: item_types_pk_columns_input!
  ): item_types

  # update data of the table: "items"
  update_items(
    # increments the integer columns with given value of the filtered values
    _inc: items_inc_input

    # sets the columns of the filtered rows to the given values
    _set: items_set_input

    # filter the rows which have to be updated
    where: items_bool_exp!
  ): items_mutation_response

  # update single row of the table: "items"
  update_items_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: items_inc_input

    # sets the columns of the filtered rows to the given values
    _set: items_set_input
    pk_columns: items_pk_columns_input!
  ): items

  # update data of the table: "language_families"
  update_language_families(
    # sets the columns of the filtered rows to the given values
    _set: language_families_set_input

    # filter the rows which have to be updated
    where: language_families_bool_exp!
  ): language_families_mutation_response

  # update single row of the table: "language_families"
  update_language_families_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: language_families_set_input
    pk_columns: language_families_pk_columns_input!
  ): language_families

  # update data of the table: "locales"
  update_locales(
    # sets the columns of the filtered rows to the given values
    _set: locales_set_input

    # filter the rows which have to be updated
    where: locales_bool_exp!
  ): locales_mutation_response

  # update single row of the table: "locales"
  update_locales_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: locales_set_input
    pk_columns: locales_pk_columns_input!
  ): locales

  # update data of the table: "materials"
  update_materials(
    # increments the integer columns with given value of the filtered values
    _inc: materials_inc_input

    # sets the columns of the filtered rows to the given values
    _set: materials_set_input

    # filter the rows which have to be updated
    where: materials_bool_exp!
  ): materials_mutation_response

  # update single row of the table: "materials"
  update_materials_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: materials_inc_input

    # sets the columns of the filtered rows to the given values
    _set: materials_set_input
    pk_columns: materials_pk_columns_input!
  ): materials

  # update data of the table: "materials_mix_parts"
  update_materials_mix_parts(
    # increments the integer columns with given value of the filtered values
    _inc: materials_mix_parts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: materials_mix_parts_set_input

    # filter the rows which have to be updated
    where: materials_mix_parts_bool_exp!
  ): materials_mix_parts_mutation_response

  # update single row of the table: "materials_mix_parts"
  update_materials_mix_parts_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: materials_mix_parts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: materials_mix_parts_set_input
    pk_columns: materials_mix_parts_pk_columns_input!
  ): materials_mix_parts

  # update data of the table: "staff_users"
  update_staff_users(
    # increments the integer columns with given value of the filtered values
    _inc: staff_users_inc_input

    # sets the columns of the filtered rows to the given values
    _set: staff_users_set_input

    # filter the rows which have to be updated
    where: staff_users_bool_exp!
  ): staff_users_mutation_response

  # update single row of the table: "staff_users"
  update_staff_users_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: staff_users_inc_input

    # sets the columns of the filtered rows to the given values
    _set: staff_users_set_input
    pk_columns: staff_users_pk_columns_input!
  ): staff_users

  # update data of the table: "version_cms_items_db"
  update_version_cms_items_db(
    # increments the integer columns with given value of the filtered values
    _inc: version_cms_items_db_inc_input

    # sets the columns of the filtered rows to the given values
    _set: version_cms_items_db_set_input

    # filter the rows which have to be updated
    where: version_cms_items_db_bool_exp!
  ): version_cms_items_db_mutation_response

  # update single row of the table: "version_cms_items_db"
  update_version_cms_items_db_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: version_cms_items_db_inc_input

    # sets the columns of the filtered rows to the given values
    _set: version_cms_items_db_set_input
    pk_columns: version_cms_items_db_pk_columns_input!
  ): version_cms_items_db
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# query root
type query_root {
  # fetch data from the table: "base_colours"
  base_colours(
    # distinct select on columns
    distinct_on: [base_colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [base_colours_order_by!]

    # filter the rows returned
    where: base_colours_bool_exp
  ): [base_colours!]!

  # fetch aggregated fields from the table: "base_colours"
  base_colours_aggregate(
    # distinct select on columns
    distinct_on: [base_colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [base_colours_order_by!]

    # filter the rows returned
    where: base_colours_bool_exp
  ): base_colours_aggregate!

  # fetch data from the table: "base_colours" using primary key columns
  base_colours_by_pk(value: String!): base_colours

  # fetch data from the table: "body_groups"
  body_groups(
    # distinct select on columns
    distinct_on: [body_groups_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_groups_order_by!]

    # filter the rows returned
    where: body_groups_bool_exp
  ): [body_groups!]!

  # fetch aggregated fields from the table: "body_groups"
  body_groups_aggregate(
    # distinct select on columns
    distinct_on: [body_groups_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_groups_order_by!]

    # filter the rows returned
    where: body_groups_bool_exp
  ): body_groups_aggregate!

  # fetch data from the table: "body_groups" using primary key columns
  body_groups_by_pk(value: String!): body_groups

  # fetch data from the table: "body_segment_mask_shapes"
  body_segment_mask_shapes(
    # distinct select on columns
    distinct_on: [body_segment_mask_shapes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_mask_shapes_order_by!]

    # filter the rows returned
    where: body_segment_mask_shapes_bool_exp
  ): [body_segment_mask_shapes!]!

  # fetch aggregated fields from the table: "body_segment_mask_shapes"
  body_segment_mask_shapes_aggregate(
    # distinct select on columns
    distinct_on: [body_segment_mask_shapes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_mask_shapes_order_by!]

    # filter the rows returned
    where: body_segment_mask_shapes_bool_exp
  ): body_segment_mask_shapes_aggregate!

  # fetch data from the table: "body_segment_mask_shapes" using primary key columns
  body_segment_mask_shapes_by_pk(value: String!): body_segment_mask_shapes

  # fetch data from the table: "body_segment_masks"
  body_segment_masks(
    # distinct select on columns
    distinct_on: [body_segment_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_masks_order_by!]

    # filter the rows returned
    where: body_segment_masks_bool_exp
  ): [body_segment_masks!]!

  # fetch aggregated fields from the table: "body_segment_masks"
  body_segment_masks_aggregate(
    # distinct select on columns
    distinct_on: [body_segment_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_masks_order_by!]

    # filter the rows returned
    where: body_segment_masks_bool_exp
  ): body_segment_masks_aggregate!

  # fetch data from the table: "body_segment_masks" using primary key columns
  body_segment_masks_by_pk(id: Int!): body_segment_masks

  # fetch data from the table: "body_segments"
  body_segments(
    # distinct select on columns
    distinct_on: [body_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segments_order_by!]

    # filter the rows returned
    where: body_segments_bool_exp
  ): [body_segments!]!

  # fetch aggregated fields from the table: "body_segments"
  body_segments_aggregate(
    # distinct select on columns
    distinct_on: [body_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segments_order_by!]

    # filter the rows returned
    where: body_segments_bool_exp
  ): body_segments_aggregate!

  # fetch data from the table: "body_segments" using primary key columns
  body_segments_by_pk(id: Int!): body_segments

  # fetch data from the table: "clothing_features"
  clothing_features(
    # distinct select on columns
    distinct_on: [clothing_features_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_features_order_by!]

    # filter the rows returned
    where: clothing_features_bool_exp
  ): [clothing_features!]!

  # fetch aggregated fields from the table: "clothing_features"
  clothing_features_aggregate(
    # distinct select on columns
    distinct_on: [clothing_features_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_features_order_by!]

    # filter the rows returned
    where: clothing_features_bool_exp
  ): clothing_features_aggregate!

  # fetch data from the table: "clothing_features" using primary key columns
  clothing_features_by_pk(value: String!): clothing_features

  # fetch data from the table: "clothing_masks"
  clothing_masks(
    # distinct select on columns
    distinct_on: [clothing_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_masks_order_by!]

    # filter the rows returned
    where: clothing_masks_bool_exp
  ): [clothing_masks!]!

  # fetch aggregated fields from the table: "clothing_masks"
  clothing_masks_aggregate(
    # distinct select on columns
    distinct_on: [clothing_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_masks_order_by!]

    # filter the rows returned
    where: clothing_masks_bool_exp
  ): clothing_masks_aggregate!

  # fetch data from the table: "clothing_masks" using primary key columns
  clothing_masks_by_pk(id: Int!): clothing_masks

  # fetch data from the table: "clothing_segment_bounds"
  clothing_segment_bounds(
    # distinct select on columns
    distinct_on: [clothing_segment_bounds_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_bounds_order_by!]

    # filter the rows returned
    where: clothing_segment_bounds_bool_exp
  ): [clothing_segment_bounds!]!

  # fetch aggregated fields from the table: "clothing_segment_bounds"
  clothing_segment_bounds_aggregate(
    # distinct select on columns
    distinct_on: [clothing_segment_bounds_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_bounds_order_by!]

    # filter the rows returned
    where: clothing_segment_bounds_bool_exp
  ): clothing_segment_bounds_aggregate!

  # fetch data from the table: "clothing_segment_bounds" using primary key columns
  clothing_segment_bounds_by_pk(value: smallint!): clothing_segment_bounds

  # fetch data from the table: "clothing_segment_data"
  clothing_segment_data(
    # distinct select on columns
    distinct_on: [clothing_segment_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_data_order_by!]

    # filter the rows returned
    where: clothing_segment_data_bool_exp
  ): [clothing_segment_data!]!

  # fetch aggregated fields from the table: "clothing_segment_data"
  clothing_segment_data_aggregate(
    # distinct select on columns
    distinct_on: [clothing_segment_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_data_order_by!]

    # filter the rows returned
    where: clothing_segment_data_bool_exp
  ): clothing_segment_data_aggregate!

  # fetch data from the table: "clothing_segment_data" using primary key columns
  clothing_segment_data_by_pk(id: uuid!): clothing_segment_data

  # fetch data from the table: "clothing_shell_and_body_segment_mask"
  clothing_shell_and_body_segment_mask(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): [clothing_shell_and_body_segment_mask!]!

  # fetch aggregated fields from the table: "clothing_shell_and_body_segment_mask"
  clothing_shell_and_body_segment_mask_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): clothing_shell_and_body_segment_mask_aggregate!

  # fetch data from the table: "clothing_shell_and_body_segment_mask" using primary key columns
  clothing_shell_and_body_segment_mask_by_pk(body_segment_mask_id: Int!, clothing_shell_id: Int!): clothing_shell_and_body_segment_mask

  # fetch data from the table: "clothing_shell_and_clothing_feature"
  clothing_shell_and_clothing_feature(
    # distinct select on columns
    distinct_on: [clothing_shell_and_clothing_feature_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_clothing_feature_order_by!]

    # filter the rows returned
    where: clothing_shell_and_clothing_feature_bool_exp
  ): [clothing_shell_and_clothing_feature!]!

  # fetch aggregated fields from the table: "clothing_shell_and_clothing_feature"
  clothing_shell_and_clothing_feature_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_and_clothing_feature_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_clothing_feature_order_by!]

    # filter the rows returned
    where: clothing_shell_and_clothing_feature_bool_exp
  ): clothing_shell_and_clothing_feature_aggregate!

  # fetch data from the table: "clothing_shell_and_clothing_feature" using primary key columns
  clothing_shell_and_clothing_feature_by_pk(clothing_feature: String!, clothing_shell_id: Int!): clothing_shell_and_clothing_feature

  # fetch data from the table: "clothing_shell_counts"
  clothing_shell_counts(
    # distinct select on columns
    distinct_on: [clothing_shell_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_counts_order_by!]

    # filter the rows returned
    where: clothing_shell_counts_bool_exp
  ): [clothing_shell_counts!]!

  # fetch aggregated fields from the table: "clothing_shell_counts"
  clothing_shell_counts_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_counts_order_by!]

    # filter the rows returned
    where: clothing_shell_counts_bool_exp
  ): clothing_shell_counts_aggregate!

  # fetch data from the table: "clothing_shell_counts" using primary key columns
  clothing_shell_counts_by_pk(id: Int!): clothing_shell_counts

  # fetch data from the table: "clothing_shell_maindata"
  clothing_shell_maindata(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_bool_exp
  ): [clothing_shell_maindata!]!

  # fetch aggregated fields from the table: "clothing_shell_maindata"
  clothing_shell_maindata_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_bool_exp
  ): clothing_shell_maindata_aggregate!

  # fetch data from the table: "clothing_shell_maindata" using primary key columns
  clothing_shell_maindata_by_pk(id: uuid!): clothing_shell_maindata

  # fetch data from the table: "clothing_shell_maindata_revision_changes"
  clothing_shell_maindata_revision_changes(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revision_changes_bool_exp
  ): [clothing_shell_maindata_revision_changes!]!

  # fetch aggregated fields from the table: "clothing_shell_maindata_revision_changes"
  clothing_shell_maindata_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revision_changes_bool_exp
  ): clothing_shell_maindata_revision_changes_aggregate!

  # fetch data from the table: "clothing_shell_maindata_revision_changes" using primary key columns
  clothing_shell_maindata_revision_changes_by_pk(id: uuid!): clothing_shell_maindata_revision_changes

  # fetch data from the table: "clothing_shell_maindata_revisions"
  clothing_shell_maindata_revisions(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revisions_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revisions_bool_exp
  ): [clothing_shell_maindata_revisions!]!

  # fetch aggregated fields from the table: "clothing_shell_maindata_revisions"
  clothing_shell_maindata_revisions_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revisions_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revisions_bool_exp
  ): clothing_shell_maindata_revisions_aggregate!

  # fetch data from the table: "clothing_shell_maindata_revisions" using primary key columns
  clothing_shell_maindata_revisions_by_pk(id: uuid!): clothing_shell_maindata_revisions

  # fetch data from the table: "clothing_shells"
  clothing_shells(
    # distinct select on columns
    distinct_on: [clothing_shells_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shells_order_by!]

    # filter the rows returned
    where: clothing_shells_bool_exp
  ): [clothing_shells!]!

  # fetch aggregated fields from the table: "clothing_shells"
  clothing_shells_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shells_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shells_order_by!]

    # filter the rows returned
    where: clothing_shells_bool_exp
  ): clothing_shells_aggregate!

  # fetch data from the table: "clothing_shells" using primary key columns
  clothing_shells_by_pk(id: Int!): clothing_shells

  # fetch data from the table: "collab_company_and_collection"
  collab_company_and_collection(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): [collab_company_and_collection!]!

  # fetch aggregated fields from the table: "collab_company_and_collection"
  collab_company_and_collection_aggregate(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): collab_company_and_collection_aggregate!

  # fetch data from the table: "collab_company_and_collection" using primary key columns
  collab_company_and_collection_by_pk(collection_id: Int!, company_id: Int!): collab_company_and_collection

  # fetch data from the table: "collections"
  collections(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): [collections!]!

  # fetch aggregated fields from the table: "collections"
  collections_aggregate(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): collections_aggregate!

  # fetch data from the table: "collections" using primary key columns
  collections_by_pk(id: Int!): collections

  # fetch data from the table: "colour_mix_parts"
  colour_mix_parts(
    # distinct select on columns
    distinct_on: [colour_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colour_mix_parts_order_by!]

    # filter the rows returned
    where: colour_mix_parts_bool_exp
  ): [colour_mix_parts!]!

  # fetch aggregated fields from the table: "colour_mix_parts"
  colour_mix_parts_aggregate(
    # distinct select on columns
    distinct_on: [colour_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colour_mix_parts_order_by!]

    # filter the rows returned
    where: colour_mix_parts_bool_exp
  ): colour_mix_parts_aggregate!

  # fetch data from the table: "colour_mix_parts" using primary key columns
  colour_mix_parts_by_pk(id: Int!): colour_mix_parts

  # fetch data from the table: "colours"
  colours(
    # distinct select on columns
    distinct_on: [colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colours_order_by!]

    # filter the rows returned
    where: colours_bool_exp
  ): [colours!]!

  # fetch aggregated fields from the table: "colours"
  colours_aggregate(
    # distinct select on columns
    distinct_on: [colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colours_order_by!]

    # filter the rows returned
    where: colours_bool_exp
  ): colours_aggregate!

  # fetch data from the table: "colours" using primary key columns
  colours_by_pk(id: Int!): colours

  # fetch data from the table: "companies"
  companies(
    # distinct select on columns
    distinct_on: [companies_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [companies_order_by!]

    # filter the rows returned
    where: companies_bool_exp
  ): [companies!]!

  # fetch aggregated fields from the table: "companies"
  companies_aggregate(
    # distinct select on columns
    distinct_on: [companies_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [companies_order_by!]

    # filter the rows returned
    where: companies_bool_exp
  ): companies_aggregate!

  # fetch data from the table: "companies" using primary key columns
  companies_by_pk(id: Int!): companies

  # fetch data from the table: "company_counts"
  company_counts(
    # distinct select on columns
    distinct_on: [company_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_counts_order_by!]

    # filter the rows returned
    where: company_counts_bool_exp
  ): [company_counts!]!

  # fetch aggregated fields from the table: "company_counts"
  company_counts_aggregate(
    # distinct select on columns
    distinct_on: [company_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_counts_order_by!]

    # filter the rows returned
    where: company_counts_bool_exp
  ): company_counts_aggregate!

  # fetch data from the table: "company_counts" using primary key columns
  company_counts_by_pk(id: Int!): company_counts

  # fetch data from the table: "company_translation_revision_changes"
  company_translation_revision_changes(
    # distinct select on columns
    distinct_on: [company_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revision_changes_order_by!]

    # filter the rows returned
    where: company_translation_revision_changes_bool_exp
  ): [company_translation_revision_changes!]!

  # fetch aggregated fields from the table: "company_translation_revision_changes"
  company_translation_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [company_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revision_changes_order_by!]

    # filter the rows returned
    where: company_translation_revision_changes_bool_exp
  ): company_translation_revision_changes_aggregate!

  # fetch data from the table: "company_translation_revision_changes" using primary key columns
  company_translation_revision_changes_by_pk(id: uuid!): company_translation_revision_changes

  # fetch data from the table: "company_translation_revisions"
  company_translation_revisions(
    # distinct select on columns
    distinct_on: [company_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revisions_order_by!]

    # filter the rows returned
    where: company_translation_revisions_bool_exp
  ): [company_translation_revisions!]!

  # fetch aggregated fields from the table: "company_translation_revisions"
  company_translation_revisions_aggregate(
    # distinct select on columns
    distinct_on: [company_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revisions_order_by!]

    # filter the rows returned
    where: company_translation_revisions_bool_exp
  ): company_translation_revisions_aggregate!

  # fetch data from the table: "company_translation_revisions" using primary key columns
  company_translation_revisions_by_pk(id: uuid!): company_translation_revisions

  # fetch data from the table: "company_translations"
  company_translations(
    # distinct select on columns
    distinct_on: [company_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translations_order_by!]

    # filter the rows returned
    where: company_translations_bool_exp
  ): [company_translations!]!

  # fetch aggregated fields from the table: "company_translations"
  company_translations_aggregate(
    # distinct select on columns
    distinct_on: [company_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translations_order_by!]

    # filter the rows returned
    where: company_translations_bool_exp
  ): company_translations_aggregate!

  # fetch data from the table: "company_translations" using primary key columns
  company_translations_by_pk(id: uuid!): company_translations

  # fetch data from the table: "countries"
  countries(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): [countries!]!

  # fetch aggregated fields from the table: "countries"
  countries_aggregate(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): countries_aggregate!

  # fetch data from the table: "countries" using primary key columns
  countries_by_pk(
    # In this enum implementation, the value is the 2-letter Alpha-2 code of the country, according to ISO 3166-1.
    value: String!
  ): countries

  # fetch data from the table: "data_actions"
  data_actions(
    # distinct select on columns
    distinct_on: [data_actions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_actions_order_by!]

    # filter the rows returned
    where: data_actions_bool_exp
  ): [data_actions!]!

  # fetch aggregated fields from the table: "data_actions"
  data_actions_aggregate(
    # distinct select on columns
    distinct_on: [data_actions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_actions_order_by!]

    # filter the rows returned
    where: data_actions_bool_exp
  ): data_actions_aggregate!

  # fetch data from the table: "data_actions" using primary key columns
  data_actions_by_pk(value: String!): data_actions

  # fetch data from the table: "data_change_types"
  data_change_types(
    # distinct select on columns
    distinct_on: [data_change_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_change_types_order_by!]

    # filter the rows returned
    where: data_change_types_bool_exp
  ): [data_change_types!]!

  # fetch aggregated fields from the table: "data_change_types"
  data_change_types_aggregate(
    # distinct select on columns
    distinct_on: [data_change_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_change_types_order_by!]

    # filter the rows returned
    where: data_change_types_bool_exp
  ): data_change_types_aggregate!

  # fetch data from the table: "data_change_types" using primary key columns
  data_change_types_by_pk(value: String!): data_change_types

  # fetch data from the table: "data_promotions"
  data_promotions(
    # distinct select on columns
    distinct_on: [data_promotions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_promotions_order_by!]

    # filter the rows returned
    where: data_promotions_bool_exp
  ): [data_promotions!]!

  # fetch aggregated fields from the table: "data_promotions"
  data_promotions_aggregate(
    # distinct select on columns
    distinct_on: [data_promotions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_promotions_order_by!]

    # filter the rows returned
    where: data_promotions_bool_exp
  ): data_promotions_aggregate!

  # fetch data from the table: "data_promotions" using primary key columns
  data_promotions_by_pk(id: Int!): data_promotions

  # fetch data from the table: "data_release_types"
  data_release_types(
    # distinct select on columns
    distinct_on: [data_release_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_release_types_order_by!]

    # filter the rows returned
    where: data_release_types_bool_exp
  ): [data_release_types!]!

  # fetch aggregated fields from the table: "data_release_types"
  data_release_types_aggregate(
    # distinct select on columns
    distinct_on: [data_release_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_release_types_order_by!]

    # filter the rows returned
    where: data_release_types_bool_exp
  ): data_release_types_aggregate!

  # fetch data from the table: "data_release_types" using primary key columns
  data_release_types_by_pk(value: String!): data_release_types

  # fetch data from the table: "data_states"
  data_states(
    # distinct select on columns
    distinct_on: [data_states_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_states_order_by!]

    # filter the rows returned
    where: data_states_bool_exp
  ): [data_states!]!

  # fetch aggregated fields from the table: "data_states"
  data_states_aggregate(
    # distinct select on columns
    distinct_on: [data_states_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_states_order_by!]

    # filter the rows returned
    where: data_states_bool_exp
  ): data_states_aggregate!

  # fetch data from the table: "data_states" using primary key columns
  data_states_by_pk(value: String!): data_states

  # fetch data from the table: "fabric_layer_and_colour_mix_part"
  fabric_layer_and_colour_mix_part(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): [fabric_layer_and_colour_mix_part!]!

  # fetch aggregated fields from the table: "fabric_layer_and_colour_mix_part"
  fabric_layer_and_colour_mix_part_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): fabric_layer_and_colour_mix_part_aggregate!

  # fetch data from the table: "fabric_layer_and_colour_mix_part" using primary key columns
  fabric_layer_and_colour_mix_part_by_pk(colour_mix_part_id: Int!, fabric_layer_id: Int!): fabric_layer_and_colour_mix_part

  # fetch data from the table: "fabric_layer_types"
  fabric_layer_types(
    # distinct select on columns
    distinct_on: [fabric_layer_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_types_order_by!]

    # filter the rows returned
    where: fabric_layer_types_bool_exp
  ): [fabric_layer_types!]!

  # fetch aggregated fields from the table: "fabric_layer_types"
  fabric_layer_types_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layer_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_types_order_by!]

    # filter the rows returned
    where: fabric_layer_types_bool_exp
  ): fabric_layer_types_aggregate!

  # fetch data from the table: "fabric_layer_types" using primary key columns
  fabric_layer_types_by_pk(value: String!): fabric_layer_types

  # fetch data from the table: "fabric_layers"
  fabric_layers(
    # distinct select on columns
    distinct_on: [fabric_layers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layers_order_by!]

    # filter the rows returned
    where: fabric_layers_bool_exp
  ): [fabric_layers!]!

  # fetch aggregated fields from the table: "fabric_layers"
  fabric_layers_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layers_order_by!]

    # filter the rows returned
    where: fabric_layers_bool_exp
  ): fabric_layers_aggregate!

  # fetch data from the table: "fabric_layers" using primary key columns
  fabric_layers_by_pk(id: Int!): fabric_layers

  # fetch data from the table: "fabric_types"
  fabric_types(
    # distinct select on columns
    distinct_on: [fabric_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_types_order_by!]

    # filter the rows returned
    where: fabric_types_bool_exp
  ): [fabric_types!]!

  # fetch aggregated fields from the table: "fabric_types"
  fabric_types_aggregate(
    # distinct select on columns
    distinct_on: [fabric_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_types_order_by!]

    # filter the rows returned
    where: fabric_types_bool_exp
  ): fabric_types_aggregate!

  # fetch data from the table: "fabric_types" using primary key columns
  fabric_types_by_pk(id: smallint!): fabric_types

  # fetch data from the table: "genders"
  genders(
    # distinct select on columns
    distinct_on: [genders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genders_order_by!]

    # filter the rows returned
    where: genders_bool_exp
  ): [genders!]!

  # fetch aggregated fields from the table: "genders"
  genders_aggregate(
    # distinct select on columns
    distinct_on: [genders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genders_order_by!]

    # filter the rows returned
    where: genders_bool_exp
  ): genders_aggregate!

  # fetch data from the table: "genders" using primary key columns
  genders_by_pk(value: String!): genders

  # fetch data from the table: "item_and_clothing_shell"
  item_and_clothing_shell(
    # distinct select on columns
    distinct_on: [item_and_clothing_shell_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_and_clothing_shell_order_by!]

    # filter the rows returned
    where: item_and_clothing_shell_bool_exp
  ): [item_and_clothing_shell!]!

  # fetch aggregated fields from the table: "item_and_clothing_shell"
  item_and_clothing_shell_aggregate(
    # distinct select on columns
    distinct_on: [item_and_clothing_shell_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_and_clothing_shell_order_by!]

    # filter the rows returned
    where: item_and_clothing_shell_bool_exp
  ): item_and_clothing_shell_aggregate!

  # fetch data from the table: "item_and_clothing_shell" using primary key columns
  item_and_clothing_shell_by_pk(clothing_shell_id: Int!, item_id: Int!): item_and_clothing_shell

  # fetch data from the table: "item_families"
  item_families(
    # distinct select on columns
    distinct_on: [item_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_families_order_by!]

    # filter the rows returned
    where: item_families_bool_exp
  ): [item_families!]!

  # fetch aggregated fields from the table: "item_families"
  item_families_aggregate(
    # distinct select on columns
    distinct_on: [item_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_families_order_by!]

    # filter the rows returned
    where: item_families_bool_exp
  ): item_families_aggregate!

  # fetch data from the table: "item_families" using primary key columns
  item_families_by_pk(id: Int!): item_families

  # fetch data from the table: "item_maindata"
  item_maindata(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): [item_maindata!]!

  # fetch aggregated fields from the table: "item_maindata"
  item_maindata_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): item_maindata_aggregate!

  # fetch data from the table: "item_maindata" using primary key columns
  item_maindata_by_pk(id: uuid!): item_maindata

  # fetch data from the table: "item_maindata_revision_changes"
  item_maindata_revision_changes(
    # distinct select on columns
    distinct_on: [item_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: item_maindata_revision_changes_bool_exp
  ): [item_maindata_revision_changes!]!

  # fetch aggregated fields from the table: "item_maindata_revision_changes"
  item_maindata_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: item_maindata_revision_changes_bool_exp
  ): item_maindata_revision_changes_aggregate!

  # fetch data from the table: "item_maindata_revision_changes" using primary key columns
  item_maindata_revision_changes_by_pk(id: uuid!): item_maindata_revision_changes

  # fetch data from the table: "item_maindata_revisions"
  item_maindata_revisions(
    # distinct select on columns
    distinct_on: [item_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revisions_order_by!]

    # filter the rows returned
    where: item_maindata_revisions_bool_exp
  ): [item_maindata_revisions!]!

  # fetch aggregated fields from the table: "item_maindata_revisions"
  item_maindata_revisions_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revisions_order_by!]

    # filter the rows returned
    where: item_maindata_revisions_bool_exp
  ): item_maindata_revisions_aggregate!

  # fetch data from the table: "item_maindata_revisions" using primary key columns
  item_maindata_revisions_by_pk(id: uuid!): item_maindata_revisions

  # fetch data from the table: "item_translation_revision_changes"
  item_translation_revision_changes(
    # distinct select on columns
    distinct_on: [item_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revision_changes_order_by!]

    # filter the rows returned
    where: item_translation_revision_changes_bool_exp
  ): [item_translation_revision_changes!]!

  # fetch aggregated fields from the table: "item_translation_revision_changes"
  item_translation_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [item_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revision_changes_order_by!]

    # filter the rows returned
    where: item_translation_revision_changes_bool_exp
  ): item_translation_revision_changes_aggregate!

  # fetch data from the table: "item_translation_revision_changes" using primary key columns
  item_translation_revision_changes_by_pk(id: uuid!): item_translation_revision_changes

  # fetch data from the table: "item_translation_revisions"
  item_translation_revisions(
    # distinct select on columns
    distinct_on: [item_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revisions_order_by!]

    # filter the rows returned
    where: item_translation_revisions_bool_exp
  ): [item_translation_revisions!]!

  # fetch aggregated fields from the table: "item_translation_revisions"
  item_translation_revisions_aggregate(
    # distinct select on columns
    distinct_on: [item_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revisions_order_by!]

    # filter the rows returned
    where: item_translation_revisions_bool_exp
  ): item_translation_revisions_aggregate!

  # fetch data from the table: "item_translation_revisions" using primary key columns
  item_translation_revisions_by_pk(id: uuid!): item_translation_revisions

  # fetch data from the table: "item_translations"
  item_translations(
    # distinct select on columns
    distinct_on: [item_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translations_order_by!]

    # filter the rows returned
    where: item_translations_bool_exp
  ): [item_translations!]!

  # fetch aggregated fields from the table: "item_translations"
  item_translations_aggregate(
    # distinct select on columns
    distinct_on: [item_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translations_order_by!]

    # filter the rows returned
    where: item_translations_bool_exp
  ): item_translations_aggregate!

  # fetch data from the table: "item_translations" using primary key columns
  item_translations_by_pk(id: uuid!): item_translations

  # fetch data from the table: "item_types"
  item_types(
    # distinct select on columns
    distinct_on: [item_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_types_order_by!]

    # filter the rows returned
    where: item_types_bool_exp
  ): [item_types!]!

  # fetch aggregated fields from the table: "item_types"
  item_types_aggregate(
    # distinct select on columns
    distinct_on: [item_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_types_order_by!]

    # filter the rows returned
    where: item_types_bool_exp
  ): item_types_aggregate!

  # fetch data from the table: "item_types" using primary key columns
  item_types_by_pk(value: String!): item_types

  # fetch data from the table: "items"
  items(
    # distinct select on columns
    distinct_on: [items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [items_order_by!]

    # filter the rows returned
    where: items_bool_exp
  ): [items!]!

  # fetch aggregated fields from the table: "items"
  items_aggregate(
    # distinct select on columns
    distinct_on: [items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [items_order_by!]

    # filter the rows returned
    where: items_bool_exp
  ): items_aggregate!

  # fetch data from the table: "items" using primary key columns
  items_by_pk(id: Int!): items

  # fetch data from the table: "language_families"
  language_families(
    # distinct select on columns
    distinct_on: [language_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [language_families_order_by!]

    # filter the rows returned
    where: language_families_bool_exp
  ): [language_families!]!

  # fetch aggregated fields from the table: "language_families"
  language_families_aggregate(
    # distinct select on columns
    distinct_on: [language_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [language_families_order_by!]

    # filter the rows returned
    where: language_families_bool_exp
  ): language_families_aggregate!

  # fetch data from the table: "language_families" using primary key columns
  language_families_by_pk(
    # In this enum implementation, the value is the 2-letter code of the language, according to ISO 639-1.
    value: String!
  ): language_families

  # fetch data from the table: "locales"
  locales(
    # distinct select on columns
    distinct_on: [locales_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [locales_order_by!]

    # filter the rows returned
    where: locales_bool_exp
  ): [locales!]!

  # fetch aggregated fields from the table: "locales"
  locales_aggregate(
    # distinct select on columns
    distinct_on: [locales_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [locales_order_by!]

    # filter the rows returned
    where: locales_bool_exp
  ): locales_aggregate!

  # fetch data from the table: "locales" using primary key columns
  locales_by_pk(
    # The unique code of the locale, expressed in a format "xx-YY", where "xx" is
    # the language family code (ISO 639-1) and "YY" is the country code (ISO 3166-1).
    code: String!
  ): locales

  # fetch data from the table: "materials"
  materials(
    # distinct select on columns
    distinct_on: [materials_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_order_by!]

    # filter the rows returned
    where: materials_bool_exp
  ): [materials!]!

  # fetch aggregated fields from the table: "materials"
  materials_aggregate(
    # distinct select on columns
    distinct_on: [materials_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_order_by!]

    # filter the rows returned
    where: materials_bool_exp
  ): materials_aggregate!

  # fetch data from the table: "materials" using primary key columns
  materials_by_pk(id: smallint!): materials

  # fetch data from the table: "materials_mix_parts"
  materials_mix_parts(
    # distinct select on columns
    distinct_on: [materials_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_mix_parts_order_by!]

    # filter the rows returned
    where: materials_mix_parts_bool_exp
  ): [materials_mix_parts!]!

  # fetch aggregated fields from the table: "materials_mix_parts"
  materials_mix_parts_aggregate(
    # distinct select on columns
    distinct_on: [materials_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_mix_parts_order_by!]

    # filter the rows returned
    where: materials_mix_parts_bool_exp
  ): materials_mix_parts_aggregate!

  # fetch data from the table: "materials_mix_parts" using primary key columns
  materials_mix_parts_by_pk(id: Int!): materials_mix_parts

  # fetch data from the table: "staff_users"
  staff_users(
    # distinct select on columns
    distinct_on: [staff_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [staff_users_order_by!]

    # filter the rows returned
    where: staff_users_bool_exp
  ): [staff_users!]!

  # fetch aggregated fields from the table: "staff_users"
  staff_users_aggregate(
    # distinct select on columns
    distinct_on: [staff_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [staff_users_order_by!]

    # filter the rows returned
    where: staff_users_bool_exp
  ): staff_users_aggregate!

  # fetch data from the table: "staff_users" using primary key columns
  staff_users_by_pk(id: Int!): staff_users

  # fetch data from the table: "version_cms_items_db"
  version_cms_items_db(
    # distinct select on columns
    distinct_on: [version_cms_items_db_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [version_cms_items_db_order_by!]

    # filter the rows returned
    where: version_cms_items_db_bool_exp
  ): [version_cms_items_db!]!

  # fetch aggregated fields from the table: "version_cms_items_db"
  version_cms_items_db_aggregate(
    # distinct select on columns
    distinct_on: [version_cms_items_db_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [version_cms_items_db_order_by!]

    # filter the rows returned
    where: version_cms_items_db_bool_exp
  ): version_cms_items_db_aggregate!

  # fetch data from the table: "version_cms_items_db" using primary key columns
  version_cms_items_db_by_pk(id: Int!): version_cms_items_db
}

scalar smallint

# expression to compare columns of type smallint. All fields are combined with logical 'AND'.
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

# The staff user accounts of this Content Management System application.
#
#
# columns and relationships of "staff_users"
#
type staff_users {
  avatar_url: String
  created_at: timestamptz!
  email: String!
  id: Int!
  last_online: date
  name: String!
  password: String!
  role_id: Int
  title: String!
  updated_at: timestamptz!
}

# aggregated selection of "staff_users"
type staff_users_aggregate {
  aggregate: staff_users_aggregate_fields
  nodes: [staff_users!]!
}

# aggregate fields of "staff_users"
type staff_users_aggregate_fields {
  avg: staff_users_avg_fields
  count(columns: [staff_users_select_column!], distinct: Boolean): Int
  max: staff_users_max_fields
  min: staff_users_min_fields
  stddev: staff_users_stddev_fields
  stddev_pop: staff_users_stddev_pop_fields
  stddev_samp: staff_users_stddev_samp_fields
  sum: staff_users_sum_fields
  var_pop: staff_users_var_pop_fields
  var_samp: staff_users_var_samp_fields
  variance: staff_users_variance_fields
}

# order by aggregate values of table "staff_users"
input staff_users_aggregate_order_by {
  avg: staff_users_avg_order_by
  count: order_by
  max: staff_users_max_order_by
  min: staff_users_min_order_by
  stddev: staff_users_stddev_order_by
  stddev_pop: staff_users_stddev_pop_order_by
  stddev_samp: staff_users_stddev_samp_order_by
  sum: staff_users_sum_order_by
  var_pop: staff_users_var_pop_order_by
  var_samp: staff_users_var_samp_order_by
  variance: staff_users_variance_order_by
}

# input type for inserting array relation for remote table "staff_users"
input staff_users_arr_rel_insert_input {
  data: [staff_users_insert_input!]!
  on_conflict: staff_users_on_conflict
}

# aggregate avg on columns
type staff_users_avg_fields {
  id: Float
  role_id: Float
}

# order by avg() on columns of table "staff_users"
input staff_users_avg_order_by {
  id: order_by
  role_id: order_by
}

# Boolean expression to filter rows from the table "staff_users". All fields are combined with a logical 'AND'.
input staff_users_bool_exp {
  _and: [staff_users_bool_exp]
  _not: staff_users_bool_exp
  _or: [staff_users_bool_exp]
  avatar_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: Int_comparison_exp
  last_online: date_comparison_exp
  name: String_comparison_exp
  password: String_comparison_exp
  role_id: Int_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "staff_users"
enum staff_users_constraint {
  # unique or primary key constraint
  staff_users_email_key

  # unique or primary key constraint
  staff_users_pkey
}

# input type for incrementing integer column in table "staff_users"
input staff_users_inc_input {
  id: Int
  role_id: Int
}

# input type for inserting data into table "staff_users"
input staff_users_insert_input {
  avatar_url: String
  created_at: timestamptz
  email: String
  id: Int
  last_online: date
  name: String
  password: String
  role_id: Int
  title: String
  updated_at: timestamptz
}

# aggregate max on columns
type staff_users_max_fields {
  avatar_url: String
  created_at: timestamptz
  email: String
  id: Int
  last_online: date
  name: String
  password: String
  role_id: Int
  title: String
  updated_at: timestamptz
}

# order by max() on columns of table "staff_users"
input staff_users_max_order_by {
  avatar_url: order_by
  created_at: order_by
  email: order_by
  id: order_by
  last_online: order_by
  name: order_by
  password: order_by
  role_id: order_by
  title: order_by
  updated_at: order_by
}

# aggregate min on columns
type staff_users_min_fields {
  avatar_url: String
  created_at: timestamptz
  email: String
  id: Int
  last_online: date
  name: String
  password: String
  role_id: Int
  title: String
  updated_at: timestamptz
}

# order by min() on columns of table "staff_users"
input staff_users_min_order_by {
  avatar_url: order_by
  created_at: order_by
  email: order_by
  id: order_by
  last_online: order_by
  name: order_by
  password: order_by
  role_id: order_by
  title: order_by
  updated_at: order_by
}

# response of any mutation on the table "staff_users"
type staff_users_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [staff_users!]!
}

# input type for inserting object relation for remote table "staff_users"
input staff_users_obj_rel_insert_input {
  data: staff_users_insert_input!
  on_conflict: staff_users_on_conflict
}

# on conflict condition type for table "staff_users"
input staff_users_on_conflict {
  constraint: staff_users_constraint!
  update_columns: [staff_users_update_column!]!
  where: staff_users_bool_exp
}

# ordering options when selecting data from "staff_users"
input staff_users_order_by {
  avatar_url: order_by
  created_at: order_by
  email: order_by
  id: order_by
  last_online: order_by
  name: order_by
  password: order_by
  role_id: order_by
  title: order_by
  updated_at: order_by
}

# primary key columns input for table: "staff_users"
input staff_users_pk_columns_input {
  id: Int!
}

# select columns of table "staff_users"
enum staff_users_select_column {
  # column name
  avatar_url

  # column name
  created_at

  # column name
  email

  # column name
  id

  # column name
  last_online

  # column name
  name

  # column name
  password

  # column name
  role_id

  # column name
  title

  # column name
  updated_at
}

# input type for updating data in table "staff_users"
input staff_users_set_input {
  avatar_url: String
  created_at: timestamptz
  email: String
  id: Int
  last_online: date
  name: String
  password: String
  role_id: Int
  title: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type staff_users_stddev_fields {
  id: Float
  role_id: Float
}

# order by stddev() on columns of table "staff_users"
input staff_users_stddev_order_by {
  id: order_by
  role_id: order_by
}

# aggregate stddev_pop on columns
type staff_users_stddev_pop_fields {
  id: Float
  role_id: Float
}

# order by stddev_pop() on columns of table "staff_users"
input staff_users_stddev_pop_order_by {
  id: order_by
  role_id: order_by
}

# aggregate stddev_samp on columns
type staff_users_stddev_samp_fields {
  id: Float
  role_id: Float
}

# order by stddev_samp() on columns of table "staff_users"
input staff_users_stddev_samp_order_by {
  id: order_by
  role_id: order_by
}

# aggregate sum on columns
type staff_users_sum_fields {
  id: Int
  role_id: Int
}

# order by sum() on columns of table "staff_users"
input staff_users_sum_order_by {
  id: order_by
  role_id: order_by
}

# update columns of table "staff_users"
enum staff_users_update_column {
  # column name
  avatar_url

  # column name
  created_at

  # column name
  email

  # column name
  id

  # column name
  last_online

  # column name
  name

  # column name
  password

  # column name
  role_id

  # column name
  title

  # column name
  updated_at
}

# aggregate var_pop on columns
type staff_users_var_pop_fields {
  id: Float
  role_id: Float
}

# order by var_pop() on columns of table "staff_users"
input staff_users_var_pop_order_by {
  id: order_by
  role_id: order_by
}

# aggregate var_samp on columns
type staff_users_var_samp_fields {
  id: Float
  role_id: Float
}

# order by var_samp() on columns of table "staff_users"
input staff_users_var_samp_order_by {
  id: order_by
  role_id: order_by
}

# aggregate variance on columns
type staff_users_variance_fields {
  id: Float
  role_id: Float
}

# order by variance() on columns of table "staff_users"
input staff_users_variance_order_by {
  id: order_by
  role_id: order_by
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "base_colours"
  base_colours(
    # distinct select on columns
    distinct_on: [base_colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [base_colours_order_by!]

    # filter the rows returned
    where: base_colours_bool_exp
  ): [base_colours!]!

  # fetch aggregated fields from the table: "base_colours"
  base_colours_aggregate(
    # distinct select on columns
    distinct_on: [base_colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [base_colours_order_by!]

    # filter the rows returned
    where: base_colours_bool_exp
  ): base_colours_aggregate!

  # fetch data from the table: "base_colours" using primary key columns
  base_colours_by_pk(value: String!): base_colours

  # fetch data from the table: "body_groups"
  body_groups(
    # distinct select on columns
    distinct_on: [body_groups_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_groups_order_by!]

    # filter the rows returned
    where: body_groups_bool_exp
  ): [body_groups!]!

  # fetch aggregated fields from the table: "body_groups"
  body_groups_aggregate(
    # distinct select on columns
    distinct_on: [body_groups_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_groups_order_by!]

    # filter the rows returned
    where: body_groups_bool_exp
  ): body_groups_aggregate!

  # fetch data from the table: "body_groups" using primary key columns
  body_groups_by_pk(value: String!): body_groups

  # fetch data from the table: "body_segment_mask_shapes"
  body_segment_mask_shapes(
    # distinct select on columns
    distinct_on: [body_segment_mask_shapes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_mask_shapes_order_by!]

    # filter the rows returned
    where: body_segment_mask_shapes_bool_exp
  ): [body_segment_mask_shapes!]!

  # fetch aggregated fields from the table: "body_segment_mask_shapes"
  body_segment_mask_shapes_aggregate(
    # distinct select on columns
    distinct_on: [body_segment_mask_shapes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_mask_shapes_order_by!]

    # filter the rows returned
    where: body_segment_mask_shapes_bool_exp
  ): body_segment_mask_shapes_aggregate!

  # fetch data from the table: "body_segment_mask_shapes" using primary key columns
  body_segment_mask_shapes_by_pk(value: String!): body_segment_mask_shapes

  # fetch data from the table: "body_segment_masks"
  body_segment_masks(
    # distinct select on columns
    distinct_on: [body_segment_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_masks_order_by!]

    # filter the rows returned
    where: body_segment_masks_bool_exp
  ): [body_segment_masks!]!

  # fetch aggregated fields from the table: "body_segment_masks"
  body_segment_masks_aggregate(
    # distinct select on columns
    distinct_on: [body_segment_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segment_masks_order_by!]

    # filter the rows returned
    where: body_segment_masks_bool_exp
  ): body_segment_masks_aggregate!

  # fetch data from the table: "body_segment_masks" using primary key columns
  body_segment_masks_by_pk(id: Int!): body_segment_masks

  # fetch data from the table: "body_segments"
  body_segments(
    # distinct select on columns
    distinct_on: [body_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segments_order_by!]

    # filter the rows returned
    where: body_segments_bool_exp
  ): [body_segments!]!

  # fetch aggregated fields from the table: "body_segments"
  body_segments_aggregate(
    # distinct select on columns
    distinct_on: [body_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [body_segments_order_by!]

    # filter the rows returned
    where: body_segments_bool_exp
  ): body_segments_aggregate!

  # fetch data from the table: "body_segments" using primary key columns
  body_segments_by_pk(id: Int!): body_segments

  # fetch data from the table: "clothing_features"
  clothing_features(
    # distinct select on columns
    distinct_on: [clothing_features_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_features_order_by!]

    # filter the rows returned
    where: clothing_features_bool_exp
  ): [clothing_features!]!

  # fetch aggregated fields from the table: "clothing_features"
  clothing_features_aggregate(
    # distinct select on columns
    distinct_on: [clothing_features_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_features_order_by!]

    # filter the rows returned
    where: clothing_features_bool_exp
  ): clothing_features_aggregate!

  # fetch data from the table: "clothing_features" using primary key columns
  clothing_features_by_pk(value: String!): clothing_features

  # fetch data from the table: "clothing_masks"
  clothing_masks(
    # distinct select on columns
    distinct_on: [clothing_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_masks_order_by!]

    # filter the rows returned
    where: clothing_masks_bool_exp
  ): [clothing_masks!]!

  # fetch aggregated fields from the table: "clothing_masks"
  clothing_masks_aggregate(
    # distinct select on columns
    distinct_on: [clothing_masks_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_masks_order_by!]

    # filter the rows returned
    where: clothing_masks_bool_exp
  ): clothing_masks_aggregate!

  # fetch data from the table: "clothing_masks" using primary key columns
  clothing_masks_by_pk(id: Int!): clothing_masks

  # fetch data from the table: "clothing_segment_bounds"
  clothing_segment_bounds(
    # distinct select on columns
    distinct_on: [clothing_segment_bounds_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_bounds_order_by!]

    # filter the rows returned
    where: clothing_segment_bounds_bool_exp
  ): [clothing_segment_bounds!]!

  # fetch aggregated fields from the table: "clothing_segment_bounds"
  clothing_segment_bounds_aggregate(
    # distinct select on columns
    distinct_on: [clothing_segment_bounds_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_bounds_order_by!]

    # filter the rows returned
    where: clothing_segment_bounds_bool_exp
  ): clothing_segment_bounds_aggregate!

  # fetch data from the table: "clothing_segment_bounds" using primary key columns
  clothing_segment_bounds_by_pk(value: smallint!): clothing_segment_bounds

  # fetch data from the table: "clothing_segment_data"
  clothing_segment_data(
    # distinct select on columns
    distinct_on: [clothing_segment_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_data_order_by!]

    # filter the rows returned
    where: clothing_segment_data_bool_exp
  ): [clothing_segment_data!]!

  # fetch aggregated fields from the table: "clothing_segment_data"
  clothing_segment_data_aggregate(
    # distinct select on columns
    distinct_on: [clothing_segment_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_segment_data_order_by!]

    # filter the rows returned
    where: clothing_segment_data_bool_exp
  ): clothing_segment_data_aggregate!

  # fetch data from the table: "clothing_segment_data" using primary key columns
  clothing_segment_data_by_pk(id: uuid!): clothing_segment_data

  # fetch data from the table: "clothing_shell_and_body_segment_mask"
  clothing_shell_and_body_segment_mask(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): [clothing_shell_and_body_segment_mask!]!

  # fetch aggregated fields from the table: "clothing_shell_and_body_segment_mask"
  clothing_shell_and_body_segment_mask_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_and_body_segment_mask_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_body_segment_mask_order_by!]

    # filter the rows returned
    where: clothing_shell_and_body_segment_mask_bool_exp
  ): clothing_shell_and_body_segment_mask_aggregate!

  # fetch data from the table: "clothing_shell_and_body_segment_mask" using primary key columns
  clothing_shell_and_body_segment_mask_by_pk(body_segment_mask_id: Int!, clothing_shell_id: Int!): clothing_shell_and_body_segment_mask

  # fetch data from the table: "clothing_shell_and_clothing_feature"
  clothing_shell_and_clothing_feature(
    # distinct select on columns
    distinct_on: [clothing_shell_and_clothing_feature_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_clothing_feature_order_by!]

    # filter the rows returned
    where: clothing_shell_and_clothing_feature_bool_exp
  ): [clothing_shell_and_clothing_feature!]!

  # fetch aggregated fields from the table: "clothing_shell_and_clothing_feature"
  clothing_shell_and_clothing_feature_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_and_clothing_feature_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_and_clothing_feature_order_by!]

    # filter the rows returned
    where: clothing_shell_and_clothing_feature_bool_exp
  ): clothing_shell_and_clothing_feature_aggregate!

  # fetch data from the table: "clothing_shell_and_clothing_feature" using primary key columns
  clothing_shell_and_clothing_feature_by_pk(clothing_feature: String!, clothing_shell_id: Int!): clothing_shell_and_clothing_feature

  # fetch data from the table: "clothing_shell_counts"
  clothing_shell_counts(
    # distinct select on columns
    distinct_on: [clothing_shell_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_counts_order_by!]

    # filter the rows returned
    where: clothing_shell_counts_bool_exp
  ): [clothing_shell_counts!]!

  # fetch aggregated fields from the table: "clothing_shell_counts"
  clothing_shell_counts_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_counts_order_by!]

    # filter the rows returned
    where: clothing_shell_counts_bool_exp
  ): clothing_shell_counts_aggregate!

  # fetch data from the table: "clothing_shell_counts" using primary key columns
  clothing_shell_counts_by_pk(id: Int!): clothing_shell_counts

  # fetch data from the table: "clothing_shell_maindata"
  clothing_shell_maindata(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_bool_exp
  ): [clothing_shell_maindata!]!

  # fetch aggregated fields from the table: "clothing_shell_maindata"
  clothing_shell_maindata_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_bool_exp
  ): clothing_shell_maindata_aggregate!

  # fetch data from the table: "clothing_shell_maindata" using primary key columns
  clothing_shell_maindata_by_pk(id: uuid!): clothing_shell_maindata

  # fetch data from the table: "clothing_shell_maindata_revision_changes"
  clothing_shell_maindata_revision_changes(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revision_changes_bool_exp
  ): [clothing_shell_maindata_revision_changes!]!

  # fetch aggregated fields from the table: "clothing_shell_maindata_revision_changes"
  clothing_shell_maindata_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revision_changes_bool_exp
  ): clothing_shell_maindata_revision_changes_aggregate!

  # fetch data from the table: "clothing_shell_maindata_revision_changes" using primary key columns
  clothing_shell_maindata_revision_changes_by_pk(id: uuid!): clothing_shell_maindata_revision_changes

  # fetch data from the table: "clothing_shell_maindata_revisions"
  clothing_shell_maindata_revisions(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revisions_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revisions_bool_exp
  ): [clothing_shell_maindata_revisions!]!

  # fetch aggregated fields from the table: "clothing_shell_maindata_revisions"
  clothing_shell_maindata_revisions_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shell_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shell_maindata_revisions_order_by!]

    # filter the rows returned
    where: clothing_shell_maindata_revisions_bool_exp
  ): clothing_shell_maindata_revisions_aggregate!

  # fetch data from the table: "clothing_shell_maindata_revisions" using primary key columns
  clothing_shell_maindata_revisions_by_pk(id: uuid!): clothing_shell_maindata_revisions

  # fetch data from the table: "clothing_shells"
  clothing_shells(
    # distinct select on columns
    distinct_on: [clothing_shells_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shells_order_by!]

    # filter the rows returned
    where: clothing_shells_bool_exp
  ): [clothing_shells!]!

  # fetch aggregated fields from the table: "clothing_shells"
  clothing_shells_aggregate(
    # distinct select on columns
    distinct_on: [clothing_shells_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [clothing_shells_order_by!]

    # filter the rows returned
    where: clothing_shells_bool_exp
  ): clothing_shells_aggregate!

  # fetch data from the table: "clothing_shells" using primary key columns
  clothing_shells_by_pk(id: Int!): clothing_shells

  # fetch data from the table: "collab_company_and_collection"
  collab_company_and_collection(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): [collab_company_and_collection!]!

  # fetch aggregated fields from the table: "collab_company_and_collection"
  collab_company_and_collection_aggregate(
    # distinct select on columns
    distinct_on: [collab_company_and_collection_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collab_company_and_collection_order_by!]

    # filter the rows returned
    where: collab_company_and_collection_bool_exp
  ): collab_company_and_collection_aggregate!

  # fetch data from the table: "collab_company_and_collection" using primary key columns
  collab_company_and_collection_by_pk(collection_id: Int!, company_id: Int!): collab_company_and_collection

  # fetch data from the table: "collections"
  collections(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): [collections!]!

  # fetch aggregated fields from the table: "collections"
  collections_aggregate(
    # distinct select on columns
    distinct_on: [collections_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [collections_order_by!]

    # filter the rows returned
    where: collections_bool_exp
  ): collections_aggregate!

  # fetch data from the table: "collections" using primary key columns
  collections_by_pk(id: Int!): collections

  # fetch data from the table: "colour_mix_parts"
  colour_mix_parts(
    # distinct select on columns
    distinct_on: [colour_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colour_mix_parts_order_by!]

    # filter the rows returned
    where: colour_mix_parts_bool_exp
  ): [colour_mix_parts!]!

  # fetch aggregated fields from the table: "colour_mix_parts"
  colour_mix_parts_aggregate(
    # distinct select on columns
    distinct_on: [colour_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colour_mix_parts_order_by!]

    # filter the rows returned
    where: colour_mix_parts_bool_exp
  ): colour_mix_parts_aggregate!

  # fetch data from the table: "colour_mix_parts" using primary key columns
  colour_mix_parts_by_pk(id: Int!): colour_mix_parts

  # fetch data from the table: "colours"
  colours(
    # distinct select on columns
    distinct_on: [colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colours_order_by!]

    # filter the rows returned
    where: colours_bool_exp
  ): [colours!]!

  # fetch aggregated fields from the table: "colours"
  colours_aggregate(
    # distinct select on columns
    distinct_on: [colours_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [colours_order_by!]

    # filter the rows returned
    where: colours_bool_exp
  ): colours_aggregate!

  # fetch data from the table: "colours" using primary key columns
  colours_by_pk(id: Int!): colours

  # fetch data from the table: "companies"
  companies(
    # distinct select on columns
    distinct_on: [companies_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [companies_order_by!]

    # filter the rows returned
    where: companies_bool_exp
  ): [companies!]!

  # fetch aggregated fields from the table: "companies"
  companies_aggregate(
    # distinct select on columns
    distinct_on: [companies_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [companies_order_by!]

    # filter the rows returned
    where: companies_bool_exp
  ): companies_aggregate!

  # fetch data from the table: "companies" using primary key columns
  companies_by_pk(id: Int!): companies

  # fetch data from the table: "company_counts"
  company_counts(
    # distinct select on columns
    distinct_on: [company_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_counts_order_by!]

    # filter the rows returned
    where: company_counts_bool_exp
  ): [company_counts!]!

  # fetch aggregated fields from the table: "company_counts"
  company_counts_aggregate(
    # distinct select on columns
    distinct_on: [company_counts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_counts_order_by!]

    # filter the rows returned
    where: company_counts_bool_exp
  ): company_counts_aggregate!

  # fetch data from the table: "company_counts" using primary key columns
  company_counts_by_pk(id: Int!): company_counts

  # fetch data from the table: "company_translation_revision_changes"
  company_translation_revision_changes(
    # distinct select on columns
    distinct_on: [company_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revision_changes_order_by!]

    # filter the rows returned
    where: company_translation_revision_changes_bool_exp
  ): [company_translation_revision_changes!]!

  # fetch aggregated fields from the table: "company_translation_revision_changes"
  company_translation_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [company_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revision_changes_order_by!]

    # filter the rows returned
    where: company_translation_revision_changes_bool_exp
  ): company_translation_revision_changes_aggregate!

  # fetch data from the table: "company_translation_revision_changes" using primary key columns
  company_translation_revision_changes_by_pk(id: uuid!): company_translation_revision_changes

  # fetch data from the table: "company_translation_revisions"
  company_translation_revisions(
    # distinct select on columns
    distinct_on: [company_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revisions_order_by!]

    # filter the rows returned
    where: company_translation_revisions_bool_exp
  ): [company_translation_revisions!]!

  # fetch aggregated fields from the table: "company_translation_revisions"
  company_translation_revisions_aggregate(
    # distinct select on columns
    distinct_on: [company_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translation_revisions_order_by!]

    # filter the rows returned
    where: company_translation_revisions_bool_exp
  ): company_translation_revisions_aggregate!

  # fetch data from the table: "company_translation_revisions" using primary key columns
  company_translation_revisions_by_pk(id: uuid!): company_translation_revisions

  # fetch data from the table: "company_translations"
  company_translations(
    # distinct select on columns
    distinct_on: [company_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translations_order_by!]

    # filter the rows returned
    where: company_translations_bool_exp
  ): [company_translations!]!

  # fetch aggregated fields from the table: "company_translations"
  company_translations_aggregate(
    # distinct select on columns
    distinct_on: [company_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_translations_order_by!]

    # filter the rows returned
    where: company_translations_bool_exp
  ): company_translations_aggregate!

  # fetch data from the table: "company_translations" using primary key columns
  company_translations_by_pk(id: uuid!): company_translations

  # fetch data from the table: "countries"
  countries(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): [countries!]!

  # fetch aggregated fields from the table: "countries"
  countries_aggregate(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): countries_aggregate!

  # fetch data from the table: "countries" using primary key columns
  countries_by_pk(
    # In this enum implementation, the value is the 2-letter Alpha-2 code of the country, according to ISO 3166-1.
    value: String!
  ): countries

  # fetch data from the table: "data_actions"
  data_actions(
    # distinct select on columns
    distinct_on: [data_actions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_actions_order_by!]

    # filter the rows returned
    where: data_actions_bool_exp
  ): [data_actions!]!

  # fetch aggregated fields from the table: "data_actions"
  data_actions_aggregate(
    # distinct select on columns
    distinct_on: [data_actions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_actions_order_by!]

    # filter the rows returned
    where: data_actions_bool_exp
  ): data_actions_aggregate!

  # fetch data from the table: "data_actions" using primary key columns
  data_actions_by_pk(value: String!): data_actions

  # fetch data from the table: "data_change_types"
  data_change_types(
    # distinct select on columns
    distinct_on: [data_change_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_change_types_order_by!]

    # filter the rows returned
    where: data_change_types_bool_exp
  ): [data_change_types!]!

  # fetch aggregated fields from the table: "data_change_types"
  data_change_types_aggregate(
    # distinct select on columns
    distinct_on: [data_change_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_change_types_order_by!]

    # filter the rows returned
    where: data_change_types_bool_exp
  ): data_change_types_aggregate!

  # fetch data from the table: "data_change_types" using primary key columns
  data_change_types_by_pk(value: String!): data_change_types

  # fetch data from the table: "data_promotions"
  data_promotions(
    # distinct select on columns
    distinct_on: [data_promotions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_promotions_order_by!]

    # filter the rows returned
    where: data_promotions_bool_exp
  ): [data_promotions!]!

  # fetch aggregated fields from the table: "data_promotions"
  data_promotions_aggregate(
    # distinct select on columns
    distinct_on: [data_promotions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_promotions_order_by!]

    # filter the rows returned
    where: data_promotions_bool_exp
  ): data_promotions_aggregate!

  # fetch data from the table: "data_promotions" using primary key columns
  data_promotions_by_pk(id: Int!): data_promotions

  # fetch data from the table: "data_release_types"
  data_release_types(
    # distinct select on columns
    distinct_on: [data_release_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_release_types_order_by!]

    # filter the rows returned
    where: data_release_types_bool_exp
  ): [data_release_types!]!

  # fetch aggregated fields from the table: "data_release_types"
  data_release_types_aggregate(
    # distinct select on columns
    distinct_on: [data_release_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_release_types_order_by!]

    # filter the rows returned
    where: data_release_types_bool_exp
  ): data_release_types_aggregate!

  # fetch data from the table: "data_release_types" using primary key columns
  data_release_types_by_pk(value: String!): data_release_types

  # fetch data from the table: "data_states"
  data_states(
    # distinct select on columns
    distinct_on: [data_states_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_states_order_by!]

    # filter the rows returned
    where: data_states_bool_exp
  ): [data_states!]!

  # fetch aggregated fields from the table: "data_states"
  data_states_aggregate(
    # distinct select on columns
    distinct_on: [data_states_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [data_states_order_by!]

    # filter the rows returned
    where: data_states_bool_exp
  ): data_states_aggregate!

  # fetch data from the table: "data_states" using primary key columns
  data_states_by_pk(value: String!): data_states

  # fetch data from the table: "fabric_layer_and_colour_mix_part"
  fabric_layer_and_colour_mix_part(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): [fabric_layer_and_colour_mix_part!]!

  # fetch aggregated fields from the table: "fabric_layer_and_colour_mix_part"
  fabric_layer_and_colour_mix_part_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layer_and_colour_mix_part_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_and_colour_mix_part_order_by!]

    # filter the rows returned
    where: fabric_layer_and_colour_mix_part_bool_exp
  ): fabric_layer_and_colour_mix_part_aggregate!

  # fetch data from the table: "fabric_layer_and_colour_mix_part" using primary key columns
  fabric_layer_and_colour_mix_part_by_pk(colour_mix_part_id: Int!, fabric_layer_id: Int!): fabric_layer_and_colour_mix_part

  # fetch data from the table: "fabric_layer_types"
  fabric_layer_types(
    # distinct select on columns
    distinct_on: [fabric_layer_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_types_order_by!]

    # filter the rows returned
    where: fabric_layer_types_bool_exp
  ): [fabric_layer_types!]!

  # fetch aggregated fields from the table: "fabric_layer_types"
  fabric_layer_types_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layer_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layer_types_order_by!]

    # filter the rows returned
    where: fabric_layer_types_bool_exp
  ): fabric_layer_types_aggregate!

  # fetch data from the table: "fabric_layer_types" using primary key columns
  fabric_layer_types_by_pk(value: String!): fabric_layer_types

  # fetch data from the table: "fabric_layers"
  fabric_layers(
    # distinct select on columns
    distinct_on: [fabric_layers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layers_order_by!]

    # filter the rows returned
    where: fabric_layers_bool_exp
  ): [fabric_layers!]!

  # fetch aggregated fields from the table: "fabric_layers"
  fabric_layers_aggregate(
    # distinct select on columns
    distinct_on: [fabric_layers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_layers_order_by!]

    # filter the rows returned
    where: fabric_layers_bool_exp
  ): fabric_layers_aggregate!

  # fetch data from the table: "fabric_layers" using primary key columns
  fabric_layers_by_pk(id: Int!): fabric_layers

  # fetch data from the table: "fabric_types"
  fabric_types(
    # distinct select on columns
    distinct_on: [fabric_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_types_order_by!]

    # filter the rows returned
    where: fabric_types_bool_exp
  ): [fabric_types!]!

  # fetch aggregated fields from the table: "fabric_types"
  fabric_types_aggregate(
    # distinct select on columns
    distinct_on: [fabric_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [fabric_types_order_by!]

    # filter the rows returned
    where: fabric_types_bool_exp
  ): fabric_types_aggregate!

  # fetch data from the table: "fabric_types" using primary key columns
  fabric_types_by_pk(id: smallint!): fabric_types

  # fetch data from the table: "genders"
  genders(
    # distinct select on columns
    distinct_on: [genders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genders_order_by!]

    # filter the rows returned
    where: genders_bool_exp
  ): [genders!]!

  # fetch aggregated fields from the table: "genders"
  genders_aggregate(
    # distinct select on columns
    distinct_on: [genders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [genders_order_by!]

    # filter the rows returned
    where: genders_bool_exp
  ): genders_aggregate!

  # fetch data from the table: "genders" using primary key columns
  genders_by_pk(value: String!): genders

  # fetch data from the table: "item_and_clothing_shell"
  item_and_clothing_shell(
    # distinct select on columns
    distinct_on: [item_and_clothing_shell_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_and_clothing_shell_order_by!]

    # filter the rows returned
    where: item_and_clothing_shell_bool_exp
  ): [item_and_clothing_shell!]!

  # fetch aggregated fields from the table: "item_and_clothing_shell"
  item_and_clothing_shell_aggregate(
    # distinct select on columns
    distinct_on: [item_and_clothing_shell_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_and_clothing_shell_order_by!]

    # filter the rows returned
    where: item_and_clothing_shell_bool_exp
  ): item_and_clothing_shell_aggregate!

  # fetch data from the table: "item_and_clothing_shell" using primary key columns
  item_and_clothing_shell_by_pk(clothing_shell_id: Int!, item_id: Int!): item_and_clothing_shell

  # fetch data from the table: "item_families"
  item_families(
    # distinct select on columns
    distinct_on: [item_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_families_order_by!]

    # filter the rows returned
    where: item_families_bool_exp
  ): [item_families!]!

  # fetch aggregated fields from the table: "item_families"
  item_families_aggregate(
    # distinct select on columns
    distinct_on: [item_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_families_order_by!]

    # filter the rows returned
    where: item_families_bool_exp
  ): item_families_aggregate!

  # fetch data from the table: "item_families" using primary key columns
  item_families_by_pk(id: Int!): item_families

  # fetch data from the table: "item_maindata"
  item_maindata(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): [item_maindata!]!

  # fetch aggregated fields from the table: "item_maindata"
  item_maindata_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_order_by!]

    # filter the rows returned
    where: item_maindata_bool_exp
  ): item_maindata_aggregate!

  # fetch data from the table: "item_maindata" using primary key columns
  item_maindata_by_pk(id: uuid!): item_maindata

  # fetch data from the table: "item_maindata_revision_changes"
  item_maindata_revision_changes(
    # distinct select on columns
    distinct_on: [item_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: item_maindata_revision_changes_bool_exp
  ): [item_maindata_revision_changes!]!

  # fetch aggregated fields from the table: "item_maindata_revision_changes"
  item_maindata_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revision_changes_order_by!]

    # filter the rows returned
    where: item_maindata_revision_changes_bool_exp
  ): item_maindata_revision_changes_aggregate!

  # fetch data from the table: "item_maindata_revision_changes" using primary key columns
  item_maindata_revision_changes_by_pk(id: uuid!): item_maindata_revision_changes

  # fetch data from the table: "item_maindata_revisions"
  item_maindata_revisions(
    # distinct select on columns
    distinct_on: [item_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revisions_order_by!]

    # filter the rows returned
    where: item_maindata_revisions_bool_exp
  ): [item_maindata_revisions!]!

  # fetch aggregated fields from the table: "item_maindata_revisions"
  item_maindata_revisions_aggregate(
    # distinct select on columns
    distinct_on: [item_maindata_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_maindata_revisions_order_by!]

    # filter the rows returned
    where: item_maindata_revisions_bool_exp
  ): item_maindata_revisions_aggregate!

  # fetch data from the table: "item_maindata_revisions" using primary key columns
  item_maindata_revisions_by_pk(id: uuid!): item_maindata_revisions

  # fetch data from the table: "item_translation_revision_changes"
  item_translation_revision_changes(
    # distinct select on columns
    distinct_on: [item_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revision_changes_order_by!]

    # filter the rows returned
    where: item_translation_revision_changes_bool_exp
  ): [item_translation_revision_changes!]!

  # fetch aggregated fields from the table: "item_translation_revision_changes"
  item_translation_revision_changes_aggregate(
    # distinct select on columns
    distinct_on: [item_translation_revision_changes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revision_changes_order_by!]

    # filter the rows returned
    where: item_translation_revision_changes_bool_exp
  ): item_translation_revision_changes_aggregate!

  # fetch data from the table: "item_translation_revision_changes" using primary key columns
  item_translation_revision_changes_by_pk(id: uuid!): item_translation_revision_changes

  # fetch data from the table: "item_translation_revisions"
  item_translation_revisions(
    # distinct select on columns
    distinct_on: [item_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revisions_order_by!]

    # filter the rows returned
    where: item_translation_revisions_bool_exp
  ): [item_translation_revisions!]!

  # fetch aggregated fields from the table: "item_translation_revisions"
  item_translation_revisions_aggregate(
    # distinct select on columns
    distinct_on: [item_translation_revisions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translation_revisions_order_by!]

    # filter the rows returned
    where: item_translation_revisions_bool_exp
  ): item_translation_revisions_aggregate!

  # fetch data from the table: "item_translation_revisions" using primary key columns
  item_translation_revisions_by_pk(id: uuid!): item_translation_revisions

  # fetch data from the table: "item_translations"
  item_translations(
    # distinct select on columns
    distinct_on: [item_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translations_order_by!]

    # filter the rows returned
    where: item_translations_bool_exp
  ): [item_translations!]!

  # fetch aggregated fields from the table: "item_translations"
  item_translations_aggregate(
    # distinct select on columns
    distinct_on: [item_translations_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_translations_order_by!]

    # filter the rows returned
    where: item_translations_bool_exp
  ): item_translations_aggregate!

  # fetch data from the table: "item_translations" using primary key columns
  item_translations_by_pk(id: uuid!): item_translations

  # fetch data from the table: "item_types"
  item_types(
    # distinct select on columns
    distinct_on: [item_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_types_order_by!]

    # filter the rows returned
    where: item_types_bool_exp
  ): [item_types!]!

  # fetch aggregated fields from the table: "item_types"
  item_types_aggregate(
    # distinct select on columns
    distinct_on: [item_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_types_order_by!]

    # filter the rows returned
    where: item_types_bool_exp
  ): item_types_aggregate!

  # fetch data from the table: "item_types" using primary key columns
  item_types_by_pk(value: String!): item_types

  # fetch data from the table: "items"
  items(
    # distinct select on columns
    distinct_on: [items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [items_order_by!]

    # filter the rows returned
    where: items_bool_exp
  ): [items!]!

  # fetch aggregated fields from the table: "items"
  items_aggregate(
    # distinct select on columns
    distinct_on: [items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [items_order_by!]

    # filter the rows returned
    where: items_bool_exp
  ): items_aggregate!

  # fetch data from the table: "items" using primary key columns
  items_by_pk(id: Int!): items

  # fetch data from the table: "language_families"
  language_families(
    # distinct select on columns
    distinct_on: [language_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [language_families_order_by!]

    # filter the rows returned
    where: language_families_bool_exp
  ): [language_families!]!

  # fetch aggregated fields from the table: "language_families"
  language_families_aggregate(
    # distinct select on columns
    distinct_on: [language_families_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [language_families_order_by!]

    # filter the rows returned
    where: language_families_bool_exp
  ): language_families_aggregate!

  # fetch data from the table: "language_families" using primary key columns
  language_families_by_pk(
    # In this enum implementation, the value is the 2-letter code of the language, according to ISO 639-1.
    value: String!
  ): language_families

  # fetch data from the table: "locales"
  locales(
    # distinct select on columns
    distinct_on: [locales_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [locales_order_by!]

    # filter the rows returned
    where: locales_bool_exp
  ): [locales!]!

  # fetch aggregated fields from the table: "locales"
  locales_aggregate(
    # distinct select on columns
    distinct_on: [locales_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [locales_order_by!]

    # filter the rows returned
    where: locales_bool_exp
  ): locales_aggregate!

  # fetch data from the table: "locales" using primary key columns
  locales_by_pk(
    # The unique code of the locale, expressed in a format "xx-YY", where "xx" is
    # the language family code (ISO 639-1) and "YY" is the country code (ISO 3166-1).
    code: String!
  ): locales

  # fetch data from the table: "materials"
  materials(
    # distinct select on columns
    distinct_on: [materials_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_order_by!]

    # filter the rows returned
    where: materials_bool_exp
  ): [materials!]!

  # fetch aggregated fields from the table: "materials"
  materials_aggregate(
    # distinct select on columns
    distinct_on: [materials_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_order_by!]

    # filter the rows returned
    where: materials_bool_exp
  ): materials_aggregate!

  # fetch data from the table: "materials" using primary key columns
  materials_by_pk(id: smallint!): materials

  # fetch data from the table: "materials_mix_parts"
  materials_mix_parts(
    # distinct select on columns
    distinct_on: [materials_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_mix_parts_order_by!]

    # filter the rows returned
    where: materials_mix_parts_bool_exp
  ): [materials_mix_parts!]!

  # fetch aggregated fields from the table: "materials_mix_parts"
  materials_mix_parts_aggregate(
    # distinct select on columns
    distinct_on: [materials_mix_parts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [materials_mix_parts_order_by!]

    # filter the rows returned
    where: materials_mix_parts_bool_exp
  ): materials_mix_parts_aggregate!

  # fetch data from the table: "materials_mix_parts" using primary key columns
  materials_mix_parts_by_pk(id: Int!): materials_mix_parts

  # fetch data from the table: "staff_users"
  staff_users(
    # distinct select on columns
    distinct_on: [staff_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [staff_users_order_by!]

    # filter the rows returned
    where: staff_users_bool_exp
  ): [staff_users!]!

  # fetch aggregated fields from the table: "staff_users"
  staff_users_aggregate(
    # distinct select on columns
    distinct_on: [staff_users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [staff_users_order_by!]

    # filter the rows returned
    where: staff_users_bool_exp
  ): staff_users_aggregate!

  # fetch data from the table: "staff_users" using primary key columns
  staff_users_by_pk(id: Int!): staff_users

  # fetch data from the table: "version_cms_items_db"
  version_cms_items_db(
    # distinct select on columns
    distinct_on: [version_cms_items_db_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [version_cms_items_db_order_by!]

    # filter the rows returned
    where: version_cms_items_db_bool_exp
  ): [version_cms_items_db!]!

  # fetch aggregated fields from the table: "version_cms_items_db"
  version_cms_items_db_aggregate(
    # distinct select on columns
    distinct_on: [version_cms_items_db_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [version_cms_items_db_order_by!]

    # filter the rows returned
    where: version_cms_items_db_bool_exp
  ): version_cms_items_db_aggregate!

  # fetch data from the table: "version_cms_items_db" using primary key columns
  version_cms_items_db_by_pk(id: Int!): version_cms_items_db
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

# columns and relationships of "version_cms_items_db"
type version_cms_items_db {
  description: String
  id: Int!
  value: String!
}

# aggregated selection of "version_cms_items_db"
type version_cms_items_db_aggregate {
  aggregate: version_cms_items_db_aggregate_fields
  nodes: [version_cms_items_db!]!
}

# aggregate fields of "version_cms_items_db"
type version_cms_items_db_aggregate_fields {
  avg: version_cms_items_db_avg_fields
  count(columns: [version_cms_items_db_select_column!], distinct: Boolean): Int
  max: version_cms_items_db_max_fields
  min: version_cms_items_db_min_fields
  stddev: version_cms_items_db_stddev_fields
  stddev_pop: version_cms_items_db_stddev_pop_fields
  stddev_samp: version_cms_items_db_stddev_samp_fields
  sum: version_cms_items_db_sum_fields
  var_pop: version_cms_items_db_var_pop_fields
  var_samp: version_cms_items_db_var_samp_fields
  variance: version_cms_items_db_variance_fields
}

# order by aggregate values of table "version_cms_items_db"
input version_cms_items_db_aggregate_order_by {
  avg: version_cms_items_db_avg_order_by
  count: order_by
  max: version_cms_items_db_max_order_by
  min: version_cms_items_db_min_order_by
  stddev: version_cms_items_db_stddev_order_by
  stddev_pop: version_cms_items_db_stddev_pop_order_by
  stddev_samp: version_cms_items_db_stddev_samp_order_by
  sum: version_cms_items_db_sum_order_by
  var_pop: version_cms_items_db_var_pop_order_by
  var_samp: version_cms_items_db_var_samp_order_by
  variance: version_cms_items_db_variance_order_by
}

# input type for inserting array relation for remote table "version_cms_items_db"
input version_cms_items_db_arr_rel_insert_input {
  data: [version_cms_items_db_insert_input!]!
  on_conflict: version_cms_items_db_on_conflict
}

# aggregate avg on columns
type version_cms_items_db_avg_fields {
  id: Float
}

# order by avg() on columns of table "version_cms_items_db"
input version_cms_items_db_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "version_cms_items_db". All fields are combined with a logical 'AND'.
input version_cms_items_db_bool_exp {
  _and: [version_cms_items_db_bool_exp]
  _not: version_cms_items_db_bool_exp
  _or: [version_cms_items_db_bool_exp]
  description: String_comparison_exp
  id: Int_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "version_cms_items_db"
enum version_cms_items_db_constraint {
  # unique or primary key constraint
  version_pkey

  # unique or primary key constraint
  version_value_key
}

# input type for incrementing integer column in table "version_cms_items_db"
input version_cms_items_db_inc_input {
  id: Int
}

# input type for inserting data into table "version_cms_items_db"
input version_cms_items_db_insert_input {
  description: String
  id: Int
  value: String
}

# aggregate max on columns
type version_cms_items_db_max_fields {
  description: String
  id: Int
  value: String
}

# order by max() on columns of table "version_cms_items_db"
input version_cms_items_db_max_order_by {
  description: order_by
  id: order_by
  value: order_by
}

# aggregate min on columns
type version_cms_items_db_min_fields {
  description: String
  id: Int
  value: String
}

# order by min() on columns of table "version_cms_items_db"
input version_cms_items_db_min_order_by {
  description: order_by
  id: order_by
  value: order_by
}

# response of any mutation on the table "version_cms_items_db"
type version_cms_items_db_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [version_cms_items_db!]!
}

# input type for inserting object relation for remote table "version_cms_items_db"
input version_cms_items_db_obj_rel_insert_input {
  data: version_cms_items_db_insert_input!
  on_conflict: version_cms_items_db_on_conflict
}

# on conflict condition type for table "version_cms_items_db"
input version_cms_items_db_on_conflict {
  constraint: version_cms_items_db_constraint!
  update_columns: [version_cms_items_db_update_column!]!
  where: version_cms_items_db_bool_exp
}

# ordering options when selecting data from "version_cms_items_db"
input version_cms_items_db_order_by {
  description: order_by
  id: order_by
  value: order_by
}

# primary key columns input for table: "version_cms_items_db"
input version_cms_items_db_pk_columns_input {
  id: Int!
}

# select columns of table "version_cms_items_db"
enum version_cms_items_db_select_column {
  # column name
  description

  # column name
  id

  # column name
  value
}

# input type for updating data in table "version_cms_items_db"
input version_cms_items_db_set_input {
  description: String
  id: Int
  value: String
}

# aggregate stddev on columns
type version_cms_items_db_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "version_cms_items_db"
input version_cms_items_db_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type version_cms_items_db_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "version_cms_items_db"
input version_cms_items_db_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type version_cms_items_db_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "version_cms_items_db"
input version_cms_items_db_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type version_cms_items_db_sum_fields {
  id: Int
}

# order by sum() on columns of table "version_cms_items_db"
input version_cms_items_db_sum_order_by {
  id: order_by
}

# update columns of table "version_cms_items_db"
enum version_cms_items_db_update_column {
  # column name
  description

  # column name
  id

  # column name
  value
}

# aggregate var_pop on columns
type version_cms_items_db_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "version_cms_items_db"
input version_cms_items_db_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type version_cms_items_db_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "version_cms_items_db"
input version_cms_items_db_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type version_cms_items_db_variance_fields {
  id: Float
}

# order by variance() on columns of table "version_cms_items_db"
input version_cms_items_db_variance_order_by {
  id: order_by
}

